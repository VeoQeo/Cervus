


================================================================================
 FILE: ./README.md
================================================================================


<p align="center">
  <img src="https://github.com/VeoQeo/Cervus/blob/main/wallpapers/cervus_logo.jpg" alt="Cervus OS Logo" width="400px">
</p>


# Cervus x86_64 Operating System

[![License: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0)
[![Platform: x86_64](https://img.shields.io/badge/Platform-x86_64-lightgrey.svg)](https://en.wikipedia.org/wiki/X86-64)
[![Stage: Alpha](https://img.shields.io/badge/Stage-Alpha-orange.svg)]()

**Cervus** - This is a modern 64-bit operating system written for the x86_64 architecture. It is currently under development.

---

## Technical Features

Cervus is currently in the active development phase. The kernel implements core low-level primitives required for a stable execution environment:

### Core Architecture
- *Boot Protocol:* Utilizes the [Limine](https://github.com/limine-bootloader/limine) bootloader (Barebone profile).
- *Memory Management:*
    - *PMM:* Bitmap-based Physical Memory Manager.
    - *VMM:* Virtual Memory Management with 4-level paging support.
- *CPU Initialization:* Custom GDT (Global Descriptor Table) and IDT (Interrupt Descriptor Table) implementation.
- *Acceleration:* Native support for *SIMD* instructions (SSE/AVX) with proper state saving.

## Roadmap & Progress

| Component | Status | Description |
| :--- | :---: | :--- |
| *Bootloader* | Done | Limine Integration |
| *Graphics/PSF* | Done | Framebuffer & Text Rendering |
| *Memory (PMM/VMM)* | Done | Physical & Virtual Memory Management |
| *Interrupts (IDT)* | Done | Handling exceptions and IRQs |
| *ACPI* | Done(without rebooting) | Table parsing & SDT discovery |
| *APIC / IOAPIC* | Done | Advanced Interrupt Controllers |
| *Timers (HPET/APIC)* | Done | High Precision Event Timers |
| *SMP* | Done | Multicore Initialization |
| *Scheduler* | Done | Preemptive Multitasking |
| *Userspace* | TODO | Syscalls & Ring 3 execution |

---

## Build Environment

### Prerequisites

To build Cervus, you need a cross-compilation toolchain and the following utilities:

*   *Compiler:* `x86_64-elf-gcc`
*   *Assemblers:* `nasm`, `gas`
*   *Emulation:* `qemu-system-x86_64`
*   *ISO Tools:* `xorriso`, `mtools`

### Compiling and Running

*1. Clone the repository:*

```bash
bash
git clone https://github.com/VeoQeo/Cervus.git
cd Cervus
```

*2. Compile and launch in QEMU:*
```bash
./build run
```

*3. Deploy to hardware (Flash Drive):*
**WARNING: This will overwrite data on the target device.**
```bash
sudo ./build flash
```

## Contributing

Cervus is an open-source research project. Contributions regarding bug fixes, hardware support, or documentation are welcome. Please feel free to open an Issue or submit a Pull Request.

## License

This project is licensed under the *GPL-3.0 License*. See the [LICENSE](LICENSE) file for details.

---



================================================================================
 FILE: ./builder/build.c
================================================================================


#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <stdbool.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <dirent.h>
#include <time.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/wait.h>

#define IMAGE_NAME "Cervus"
#define VERSION "v0.0.1"
#define QEMUFLAGS "-m 12G -smp 8 -cpu qemu64,+fsgsbase"

#define WALLPAPER_SRC "wallpapers/cervus1280x720.png"
#define WALLPAPER_DST "boot():/boot/wallpapers/cervus.png"

#define HELLO_SRC     "test/hello.c"
#define HELLO_ELF     "test/hello.elf"

#define COLOR_RESET   "\033[0m"
#define COLOR_RED     "\033[91m"
#define COLOR_GREEN   "\033[92m"
#define COLOR_YELLOW  "\033[93m"
#define COLOR_BLUE    "\033[94m"
#define COLOR_MAGENTA "\033[95m"
#define COLOR_CYAN    "\033[96m"
#define COLOR_BOLD    "\033[1m"

const char *DIRS_TO_CLEAN[] = { "bin", "obj", "iso_root", "limine", "kernel/linker-scripts", "demo_iso", "limine-tools", "edk2-ovmf", NULL };
const char *FILES_TO_CLEAN[] = { "Cervus.iso", "Cervus.hdd", "kernel/.deps-obtained", "limine.conf", "OS-TREE.txt", "log.txt", NULL };

const char *SSE_FILES[] = {
    "sse.c", "fpu.c", "printf.c", "fabs.c", "pow.c", "pow10.c", "serial.c", "pmm.c", "paging.c", "apic.c", "kernel.c", NULL
};

struct Dependency {
    const char *name;
    const char *url;
    const char *commit;
};

struct Dependency DEPENDENCIES[] = {
    {"freestnd-c-hdrs", "https://codeberg.org/OSDev/freestnd-c-hdrs-0bsd.git", "5df91dd7062ad0c54f5ffd86193bb9f008677631"},
    {"cc-runtime", "https://codeberg.org/OSDev/cc-runtime.git", "dae79833b57a01b9fd3e359ee31def69f5ae899b"},
    {"limine-protocol", "https://codeberg.org/Limine/limine-protocol.git", "c4616df2572d77c60020bdefa617dd9bdcc6566a"},
    {NULL, NULL, NULL}
};

bool ARG_NO_CLEAN = false;
bool ARG_TREE = false;
bool ARG_STRUCTURE_ONLY = false;

char **TREE_FILES = NULL;
int TREE_FILES_COUNT = 0;
int TREE_FILES_CAPACITY = 0;

void print_color(const char *color, const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    printf("%s", color);
    vprintf(fmt, args);
    printf("%s\n", COLOR_RESET);
    va_end(args);
}

void add_tree_file(const char *filename) {
    if (TREE_FILES_COUNT >= TREE_FILES_CAPACITY) {
        TREE_FILES_CAPACITY = (TREE_FILES_CAPACITY == 0) ? 8 : TREE_FILES_CAPACITY * 2;
        TREE_FILES = realloc(TREE_FILES, TREE_FILES_CAPACITY * sizeof(char*));
    }
    TREE_FILES[TREE_FILES_COUNT++] = strdup(filename);
}

bool should_print_content(const char *filename) {
    if (TREE_FILES_COUNT == 0) return true;
    for (int i = 0; i < TREE_FILES_COUNT; i++) {
        if (strcmp(filename, TREE_FILES[i]) == 0) return true;
    }
    return false;
}

int cmd_run(bool capture, const char *fmt, ...) {
    char cmd[4096];
    va_list args;
    va_start(args, fmt);
    vsnprintf(cmd, sizeof(cmd), fmt, args);
    va_end(args);

    if (capture) {
        print_color(COLOR_BLUE, "Running: %s", cmd);
    }

    int ret = system(cmd);
    if (ret != 0) {
        return WEXITSTATUS(ret);
    }
    return 0;
}

void ensure_dir(const char *path) {
    char tmp[1024];
    snprintf(tmp, sizeof(tmp), "mkdir -p %s", path);
    system(tmp);
}

bool file_exists(const char *path) {
    return access(path, F_OK) == 0;
}

time_t get_mtime(const char *path) {
    struct stat attr;
    if (stat(path, &attr) == 0) return attr.st_mtime;
    return 0;
}

void rm_rf(const char *path) {
    if (file_exists(path)) {
        print_color(COLOR_BLUE, "Removing %s", path);
        cmd_run(false, "rm -rf %s", path);
    }
}

bool setup_dependencies() {
    print_color(COLOR_GREEN, "Checking dependencies...");
    ensure_dir("limine-tools");

    for (int i = 0; DEPENDENCIES[i].name != NULL; i++) {
        char path[PATH_MAX];
        snprintf(path, sizeof(path), "limine-tools/%s", DEPENDENCIES[i].name);

        if (!file_exists(path)) {
            print_color(COLOR_YELLOW, "Missing %s, setting up...", DEPENDENCIES[i].name);
            if (cmd_run(true, "git clone %s %s", DEPENDENCIES[i].url, path) != 0) return false;

            char git_cmd[PATH_MAX + 128];
            snprintf(git_cmd, sizeof(git_cmd), "git -C %s -c advice.detachedHead=false checkout %s", path, DEPENDENCIES[i].commit);
            if (system(git_cmd) != 0) return false;
        }
    }
    return true;
}

bool build_limine() {
    if (file_exists("limine/limine")) {
        print_color(COLOR_GREEN, "Limine already built");
        return true;
    }

    print_color(COLOR_GREEN, "Building Limine...");
    if (file_exists("limine")) rm_rf("limine");

    if (cmd_run(true, "git clone https://codeberg.org/Limine/Limine.git limine --branch=v10.7.0-binary --depth=1") != 0) return false;
    if (cmd_run(true, "make -C limine") != 0) return false;

    return true;
}

bool is_sse_file(const char *filename) {
    for (int i = 0; SSE_FILES[i] != NULL; i++) {
        if (strstr(filename, SSE_FILES[i]) != NULL) return true;
    }
    return false;
}

void ensure_linker_script() {
    ensure_dir("kernel/linker-scripts");
    const char *lds_path = "kernel/linker-scripts/x86_64.lds";
    if (file_exists(lds_path)) return;

    const char *linker_script = R"(
OUTPUT_FORMAT(elf64-x86-64)

ENTRY(kernel_main)

PHDRS
{
    limine_requests PT_LOAD;
    text PT_LOAD;
    rodata PT_LOAD;
    data PT_LOAD;
}

SECTIONS
{
    . = 0xffffffff80000000;

    .limine_requests : {
        KEEP(*(.limine_requests_start))
        KEEP(*(.limine_requests))
        KEEP(*(.limine_requests_end))
    } :limine_requests

    . = ALIGN(CONSTANT(MAXPAGESIZE));

    .text : {
        __start_isr_handlers = .;
        KEEP(*(.isr_handlers))
        __stop_isr_handlers = .;

        __start_irq_handlers = .;
        KEEP(*(.irq_handlers))
        __stop_irq_handlers = .;

        *(.text .text.*)
    } :text

    . = ALIGN(CONSTANT(MAXPAGESIZE));

    .rodata : {
        *(.rodata .rodata.*)
    } :rodata

    .note.gnu.build-id : {
        *(.note.gnu.build-id)
    } :rodata

    . = ALIGN(CONSTANT(MAXPAGESIZE));

    .data : {
        *(.data .data.*)

        . = ALIGN(4096);
        __percpu_start = .;
        KEEP(*(.percpu .percpu.*))
        . = ALIGN(4096);
        __percpu_end = .;
    } :data

    .bss : {
        *(.bss .bss.*)
        *(COMMON)
    } :data

    /DISCARD/ : {
        *(.eh_frame*)
        *(.note .note.*)
    }
}
)";

    FILE *f = fopen(lds_path, "w");
    if (!f) return;

    fprintf(f, "%s", linker_script);

    fclose(f);
    print_color(COLOR_GREEN, "x86_64.lds created");
}

bool build_hello_elf() {
    if (!file_exists(HELLO_SRC)) {
        print_color(COLOR_YELLOW, "[ELF] %s not found — skipping", HELLO_SRC);
        return true;
    }

    if (file_exists(HELLO_ELF) && get_mtime(HELLO_SRC) <= get_mtime(HELLO_ELF)) {
        print_color(COLOR_GREEN, "[ELF] %s is up to date", HELLO_ELF);
        return true;
    }

    print_color(COLOR_CYAN, "[ELF] Compiling %s -> %s", HELLO_SRC, HELLO_ELF);

    int ret = cmd_run(false,
        "gcc -nostdlib -nostartfiles -static -ffreestanding "
        "-O2 -o %s %s",
        HELLO_ELF, HELLO_SRC);

    if (ret != 0) {
        print_color(COLOR_RED, "[ELF] Failed to compile %s", HELLO_SRC);
        return false;
    }

    print_color(COLOR_GREEN, "[ELF] %s built successfully", HELLO_ELF);
    return true;
}

typedef struct {
    char **paths;
    int count;
    int capacity;
} FileList;

void file_list_add(FileList *list, const char *path) {
    if (list->count >= list->capacity) {
        list->capacity = list->capacity == 0 ? 16 : list->capacity * 2;
        list->paths = realloc(list->paths, list->capacity * sizeof(char*));
    }
    list->paths[list->count++] = strdup(path);
}

void find_src_files(const char *root_dir, FileList *list) {
    DIR *dir;
    struct dirent *entry;
    if (!(dir = opendir(root_dir))) return;

    while ((entry = readdir(dir)) != NULL) {
        if (entry->d_type == DT_DIR) {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0 ||
                strcmp(entry->d_name, ".git") == 0) continue;
            char path[PATH_MAX];
            snprintf(path, sizeof(path), "%s/%s", root_dir, entry->d_name);
            find_src_files(path, list);
        } else {
            const char *ext = strrchr(entry->d_name, '.');
            if (ext && (strcmp(ext, ".c") == 0 || strcmp(ext, ".asm") == 0 ||
                        strcmp(ext, ".S") == 0 || strcmp(ext, ".psf") == 0)) {
                char path[PATH_MAX];
                snprintf(path, sizeof(path), "%s/%s", root_dir, entry->d_name);
                file_list_add(list, path);
            }
        }
    }
    closedir(dir);
}

bool compile_kernel() {
    print_color(COLOR_GREEN, "Compiling kernel...");
    ensure_linker_script();
    if (!setup_dependencies()) return false;

    if (!build_hello_elf()) return false;

    ensure_dir("bin");
    ensure_dir("obj/kernel");
    ensure_dir("obj/libc");

    const char *base_cflags = "-g -O2 -pipe -Wall -Wextra -std=gnu11 -nostdinc -ffreestanding "
                              "-fno-stack-protector -fno-stack-check -fno-lto -fno-PIC "
                              "-ffunction-sections -fdata-sections "
                              "-m64 -march=x86-64 -mabi=sysv -mcmodel=kernel "
                              "-mno-red-zone -mgeneral-regs-only";

    const char *core_cflags = "-mno-sse -mno-sse2 -mno-mmx -mno-3dnow";
    const char *sse_cflags_suffix = "-msse -msse2 -mfpmath=sse -mno-mmx -mno-3dnow";

    char cppflags[2048];
    snprintf(cppflags, sizeof(cppflags),
             "-I kernel/src -I libc/include -I limine-tools/limine-protocol/include -isystem limine-tools/freestnd-c-hdrs/include -MMD -MP");

    FileList sources = {0};
    if (file_exists("kernel/src")) find_src_files("kernel/src", &sources);
    if (file_exists("libc/src")) find_src_files("libc/src", &sources);

    FileList objects = {0};
    bool compilation_failed = false;

    for (int i = 0; i < sources.count; i++) {
        char *src = sources.paths[i];

        char category[16] = "other";
        if (strncmp(src, "kernel/", 7) == 0) strcpy(category, "kernel");
        else if (strncmp(src, "libc/", 5) == 0) strcpy(category, "libc");

        char obj_path[PATH_MAX];
        char flat_name[PATH_MAX];
        strcpy(flat_name, src);
        for(int j=0; flat_name[j]; j++) if(flat_name[j] == '/' || flat_name[j] == '.') flat_name[j] = '_';

        snprintf(obj_path, sizeof(obj_path), "obj/%s/%s.o", category, flat_name);
        file_list_add(&objects, obj_path);

        if (file_exists(obj_path) && get_mtime(src) <= get_mtime(obj_path)) continue;

        const char *ext = strrchr(src, '.');
        if (strcmp(ext, ".psf") == 0) {
            print_color(COLOR_BLUE, "Converting binary: %s", src);
            char temp_path[PATH_MAX];
            snprintf(temp_path, sizeof(temp_path), "temp_%s", strrchr(src, '/') + 1);
            cmd_run(false, "cp %s %s", src, temp_path);
            cmd_run(false, "objcopy -I binary -O elf64-x86-64 -B i386:x86-64 --rename-section .data=.rodata,alloc,load,readonly,data,contents %s %s", temp_path, obj_path);
            remove(temp_path);
            char stem[256]; strcpy(stem, strrchr(src, '/') + 1); *strrchr(stem, '.') = '\0';
            char redefine_args[1024] = "";
            snprintf(redefine_args, sizeof(redefine_args),
                "--redefine-sym _binary_temp_%s_psf_start=_binary_%s_psf_start "
                "--redefine-sym _binary_temp_%s_psf_end=_binary_%s_psf_end "
                "--redefine-sym _binary_temp_%s_psf_size=_binary_%s_psf_size",
                stem, stem, stem, stem, stem, stem);
            cmd_run(false, "objcopy %s %s", redefine_args, obj_path);
        } else if (strcmp(ext, ".asm") == 0) {
            print_color(COLOR_CYAN, "[asm] %s", src);
            if (cmd_run(false, "nasm -g -F dwarf -f elf64 %s -o %s", src, obj_path) != 0) compilation_failed = true;
        } else {
            bool sse = is_sse_file(src);
            char final_flags[1024];
            if (sse) snprintf(final_flags, sizeof(final_flags), "%s %s", base_cflags, sse_cflags_suffix);
            else snprintf(final_flags, sizeof(final_flags), "%s %s", base_cflags, core_cflags);
            print_color(sse ? COLOR_MAGENTA : COLOR_CYAN, "[%s] %s", category, src);
            if (cmd_run(false, "gcc %s %s -c %s -o %s", final_flags, cppflags, src, obj_path) != 0) compilation_failed = true;
        }
    }

    if (compilation_failed) return false;

    print_color(COLOR_BLUE, "Linking kernel...");
    char ld_cmd[65536];
    snprintf(ld_cmd, sizeof(ld_cmd), "ld -m elf_x86_64 -nostdlib -static -z max-page-size=0x1000 --gc-sections -T kernel/linker-scripts/x86_64.lds -o bin/kernel");
    for (int i = 0; i < objects.count; i++) { strcat(ld_cmd, " "); strcat(ld_cmd, objects.paths[i]); }
    if (system(ld_cmd) != 0) return false;

    print_color(COLOR_GREEN, "Kernel linked: bin/kernel");
    return true;
}

bool create_iso() {
    print_color(COLOR_GREEN, "Creating ISO...");
    if (!build_limine()) return false;
    if (!file_exists("bin/kernel")) return false;

    rm_rf("iso_root");
    ensure_dir("iso_root/boot/limine");
    ensure_dir("iso_root/boot/wallpapers");
    ensure_dir("iso_root/EFI/BOOT");
    ensure_dir("demo_iso");

    if (file_exists(WALLPAPER_SRC)) {
        cmd_run(false, "cp %s iso_root/boot/wallpapers/cervus.png", WALLPAPER_SRC);
        print_color(COLOR_GREEN, "Wallpaper copied: %s", WALLPAPER_SRC);
    } else {
        print_color(COLOR_YELLOW, "Warning: Wallpaper not found at %s", WALLPAPER_SRC);
    }

    bool has_hello = file_exists(HELLO_ELF);
    if (has_hello) {
        cmd_run(false, "cp %s iso_root/boot/hello.elf", HELLO_ELF);
        print_color(COLOR_GREEN, "[ELF] hello.elf added to iso_root/boot/");
    } else {
        print_color(COLOR_YELLOW, "[ELF] hello.elf not found — booting without module");
    }

    FILE *f = fopen("limine.conf", "w");
    if (f) {
        if (file_exists(WALLPAPER_SRC)) {
            fprintf(f, "wallpaper: %s\n", WALLPAPER_DST);
        }

        fprintf(f,
            "timeout: 3\n"
            "/%s %s\n"
            "    protocol: limine\n"
            "    path: boot():/boot/kernel\n",
            IMAGE_NAME, VERSION
        );

        if (has_hello) {
            fprintf(f,
                "    module_path: boot():/boot/hello.elf\n"
            );
            print_color(COLOR_GREEN, "[ELF] module_path added to limine.conf");
        }

        fclose(f);
    }

    cmd_run(false, "cp bin/kernel iso_root/boot/");
    cmd_run(false, "cp limine.conf iso_root/boot/limine/");
    cmd_run(false, "cp limine/limine-bios.sys limine/limine-bios-cd.bin limine/limine-uefi-cd.bin iso_root/boot/limine/");
    cmd_run(false, "cp limine/BOOTX64.EFI limine/BOOTIA32.EFI iso_root/EFI/BOOT/");

    char timestamp[64]; time_t t = time(NULL); strftime(timestamp, sizeof(timestamp), "%Y%m%d_%H%M%S", localtime(&t));
    char iso_name[PATH_MAX]; snprintf(iso_name, sizeof(iso_name), "demo_iso/%s.%s.%s.iso", IMAGE_NAME, VERSION, timestamp);

    char xorriso_cmd[PATH_MAX + 1024];
    snprintf(xorriso_cmd, sizeof(xorriso_cmd),
        "xorriso -as mkisofs -R -r -J -b boot/limine/limine-bios-cd.bin "
        "-no-emul-boot -boot-load-size 4 -boot-info-table -hfsplus "
        "-apm-block-size 2048 --efi-boot boot/limine/limine-uefi-cd.bin "
        "-efi-boot-part --efi-boot-image --protective-msdos-label "
        "iso_root -o %s", iso_name);

    if (cmd_run(true, xorriso_cmd) != 0) return false;
    cmd_run(true, "./limine/limine bios-install %s", iso_name);

    char link_name[PATH_MAX]; snprintf(link_name, sizeof(link_name), "demo_iso/%s.latest.iso", IMAGE_NAME);
    unlink(link_name); symlink(strrchr(iso_name, '/') + 1, link_name);
    rm_rf("iso_root");
    return true;
}

void check_sudo() {
    if (geteuid() != 0) {
        print_color(COLOR_RED, "This command requires root privileges. Please run with sudo.");
        exit(1);
    }
}

void list_iso_files(FileList *list) {
    DIR *dir = opendir("demo_iso");
    if (!dir) return;
    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        if (strstr(entry->d_name, ".iso")) {
            char path[PATH_MAX];
            snprintf(path, sizeof(path), "demo_iso/%s", entry->d_name);
            file_list_add(list, path);
        }
    }
    closedir(dir);
}

void list_usb_devices(FileList *list) {
    DIR *dir = opendir("/sys/block");
    if (!dir) return;
    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        if (entry->d_name[0] == '.') continue;
        char path[PATH_MAX];
        snprintf(path, sizeof(path), "/sys/block/%s/removable", entry->d_name);
        FILE *f = fopen(path, "r");
        if (f) {
            int removable = 0;
            if (fscanf(f, "%d", &removable) == 1 && removable) {
                char dev_path[PATH_MAX];
                snprintf(dev_path, sizeof(dev_path), "/dev/%s", entry->d_name);
                file_list_add(list, dev_path);
            }
            fclose(f);
        }
    }
    closedir(dir);
}

void flash_iso() {
    check_sudo();
    FileList isos = {0}, devs = {0};
    list_iso_files(&isos);
    if (isos.count == 0) { print_color(COLOR_RED, "No ISO images found in demo_iso/"); return; }

    printf("\n%s--- SELECT ISO IMAGE ---%s\n", COLOR_CYAN, COLOR_RESET);
    for (int i = 0; i < isos.count; i++) printf("[%d] %s\n", i + 1, isos.paths[i]);
    int iso_choice; printf("Choice: "); if (scanf("%d", &iso_choice) < 1 || iso_choice > isos.count) return;

    list_usb_devices(&devs);
    if (devs.count == 0) { print_color(COLOR_RED, "No removable USB devices found!"); return; }

    printf("\n%s--- SELECT TARGET DEVICE ---%s\n", COLOR_RED, COLOR_RESET);
    for (int i = 0; i < devs.count; i++) {
        char model_path[PATH_MAX], model[256] = "Unknown Device";
        snprintf(model_path, sizeof(model_path), "/sys/block/%s/device/model", devs.paths[i] + 5);
        FILE *mf = fopen(model_path, "r");
        if (mf) { if(fgets(model, sizeof(model), mf)) model[strcspn(model, "\n")] = 0; fclose(mf); }
        printf("[%d] %s (%s)\n", i + 1, devs.paths[i], model);
    }
    int dev_choice; printf("Choice: "); if (scanf("%d", &dev_choice) < 1 || dev_choice > devs.count) return;

    printf("\n%sWARNING: ALL DATA ON %s WILL BE ERASED!%s\n", COLOR_BOLD, devs.paths[dev_choice-1], COLOR_RESET);
    printf("Type 'YES' to confirm: ");
    char confirm[10]; scanf("%s", confirm);
    if (strcmp(confirm, "YES") != 0) { printf("Aborted.\n"); return; }

    print_color(COLOR_YELLOW, "Flashing... This might take a while.");
    cmd_run(true, "dd if=%s of=%s bs=4M status=progress oflag=sync", isos.paths[iso_choice-1], devs.paths[dev_choice-1]);
    print_color(COLOR_GREEN, "Done!");
}

bool is_unreadable_file(const char *filename) {
    const char *no_ext_files[] = {"TODO", "LICENSE", "build", NULL};
    for (int i = 0; no_ext_files[i] != NULL; i++) {
        if (strcmp(filename, no_ext_files[i]) == 0) {
            return true;
        }
    }

    const char *ext = strrchr(filename, '.');
    if (!ext) return false;

    const char *binary_exts[] = {
        ".psf", ".jpg", ".png", ".jpeg", ".iso",
        ".hdd", ".img", ".bin", ".elf", ".o",
        ".txt", ".md", ".gitignore", ".json", NULL
    };

    for (int i = 0; binary_exts[i] != NULL; i++) {
        if (strcasecmp(ext, binary_exts[i]) == 0) {
            return true;
        }
    }

    return false;
}

void generate_tree_recursive(const char *base_dir, FILE *out, int level) {
    struct dirent **namelist;
    int n = scandir(base_dir, &namelist, NULL, alphasort);
    if (n < 0) return;

    const char *skip_dirs[] = {"wallpapers", "demo_iso", ".vscode", "builder", NULL};

    for (int i = 0; i < n; i++) {
        const char *name = namelist[i]->d_name;

        if (strcmp(name, ".") == 0 || strcmp(name, "..") == 0 ||
            strcmp(name, ".git") == 0 || strcmp(name, "obj") == 0 ||
            strcmp(name, "bin") == 0 || strcmp(name, "limine") == 0) {
            free(namelist[i]);
            continue;
        }

        char path[PATH_MAX];
        snprintf(path, sizeof(path), "%s/%s", base_dir, name);
        struct stat st;
        stat(path, &st);

        if (S_ISDIR(st.st_mode)) {
            bool skip = false;
            for (int j = 0; skip_dirs[j] != NULL; j++) {
                if (strcmp(name, skip_dirs[j]) == 0) {
                    skip = true;
                    break;
                }
            }
            if (skip) {
                free(namelist[i]);
                continue;
            }
        }

        if (!S_ISDIR(st.st_mode) && is_unreadable_file(name)) {
            free(namelist[i]);
            continue;
        }

        for (int j = 0; j < level; j++) fprintf(out, "│   ");

        if (S_ISDIR(st.st_mode)) {
            fprintf(out, "├── %s/\n", name);
            generate_tree_recursive(path, out, level + 1);
        } else {
            fprintf(out, "├── %s (%ld bytes)\n", name, st.st_size);
            if (!ARG_STRUCTURE_ONLY && should_print_content(name)) {
                FILE *src = fopen(path, "r");
                if (src) {
                    char line[4096]; int ln = 1;
                    while (fgets(line, sizeof(line), src) && ln <= 5000) {
                        for (int j = 0; j <= level; j++) fprintf(out, "│   ");
                        fprintf(out, "│ %4d: %s", ln++, line);
                    }
                    fclose(src);
                }
            }
        }
        free(namelist[i]);
    }
    free(namelist);
}

void do_generate_tree() {
    FILE *f = fopen("OS-TREE.txt", "w");
    if (!f) return;
    time_t t = time(NULL);
    fprintf(f, "OS Tree - %s %s | %s", IMAGE_NAME, VERSION, ctime(&t));
    generate_tree_recursive(".", f, 0);
    fclose(f);
    print_color(COLOR_GREEN, "Tree generated to OS-TREE.txt");
}

int main(int argc, char **argv) {
    char *command = NULL;

    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--tree") == 0) {
            ARG_TREE = true;
            int j = i + 1;
            while (j < argc && argv[j][0] != '-') add_tree_file(argv[j++]);
            i = j - 1;
        }
        else if (strcmp(argv[i], "--structure-only") == 0) ARG_STRUCTURE_ONLY = true;
        else if (strcmp(argv[i], "--no-clean") == 0) ARG_NO_CLEAN = true;
        else if (argv[i][0] != '-') command = argv[i];
    }

    if (ARG_TREE && !command) { do_generate_tree(); return 0; }
    if (!command || strcmp(command, "help") == 0) {
        printf("Usage: ./build [command] [options]\n");
        printf("Commands: run, flash, clean, cleaniso, gitclean\n");
        return 0;
    }

    if (strcmp(command, "clean") == 0) {
        for (int i = 0; DIRS_TO_CLEAN[i]; i++) rm_rf(DIRS_TO_CLEAN[i]);
        for (int i = 0; FILES_TO_CLEAN[i]; i++) if(file_exists(FILES_TO_CLEAN[i])) remove(FILES_TO_CLEAN[i]);
        if (file_exists(HELLO_ELF)) {
            remove(HELLO_ELF);
            print_color(COLOR_BLUE, "Removed %s", HELLO_ELF);
        }
        cmd_run(false, "rm temp_* 2>/dev/null");
        print_color(COLOR_GREEN, "Cleanup complete");
        return 0;
    }

    if (strcmp(command, "cleaniso") == 0) {
        rm_rf("demo_iso");
        ensure_dir("demo_iso");
        return 0;
    }

    if (strcmp(command, "gitclean") == 0) {
        for (int i = 0; DIRS_TO_CLEAN[i]; i++) rm_rf(DIRS_TO_CLEAN[i]);
        for (int i = 0; FILES_TO_CLEAN[i]; i++) if(file_exists(FILES_TO_CLEAN[i])) remove(FILES_TO_CLEAN[i]);
        if (file_exists(HELLO_ELF)) {
            remove(HELLO_ELF);
            print_color(COLOR_BLUE, "Removed %s", HELLO_ELF);
        }
        print_color(COLOR_GREEN, "Git-ready cleanup complete");
        return 0;
    }

    if (strcmp(command, "flash") == 0) {
        flash_iso();
        return 0;
    }

    if (strcmp(command, "run") == 0) {
        if (!compile_kernel() || !create_iso()) return 1;
        if (ARG_TREE) do_generate_tree();
        char iso_path[PATH_MAX]; snprintf(iso_path, sizeof(iso_path), "demo_iso/%s.latest.iso", IMAGE_NAME);
        print_color(COLOR_GREEN, "Starting QEMU...");
        cmd_run(false, "qemu-system-x86_64 -M q35 -cdrom %s -boot d -serial stdio %s 2>&1 | tee log.txt", iso_path, QEMUFLAGS);
        if (!ARG_NO_CLEAN) { rm_rf("obj"); rm_rf("bin"); }
        return 0;
    }

    print_color(COLOR_RED, "Unknown command: %s", command);
    return 1;
}


================================================================================
 FILE: ./kernel/include/acpi/acpi.h
================================================================================


#ifndef ACPI_H
#define ACPI_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <limine.h>

typedef struct {
    char signature[4];
    uint32_t length;
    uint8_t revision;
    uint8_t checksum;
    char oem_id[6];
    char oem_table_id[8];
    uint32_t oem_revision;
    uint32_t creator_id;
    uint32_t creator_revision;
} __attribute__((packed)) acpi_sdt_header_t;

typedef struct {
    char signature[8];
    uint8_t checksum;
    char oem_id[6];
    uint8_t revision;
    uint32_t rsdt_address;
} __attribute__((packed)) acpi_rsdp_t;

typedef struct {
    acpi_rsdp_t rsdp_v1;
    uint32_t length;
    uint64_t xsdt_address;
    uint8_t extended_checksum;
    uint8_t reserved[3];
} __attribute__((packed)) acpi_rsdp2_t;

typedef struct {
    acpi_sdt_header_t header;
    uint32_t sdt_pointers[];
} __attribute__((packed)) acpi_rsdt_t;

typedef struct {
    acpi_sdt_header_t header;
    uint64_t sdt_pointers[];
} __attribute__((packed)) acpi_xsdt_t;

typedef struct {
    acpi_sdt_header_t header;
    uint32_t firmware_ctrl;
    uint32_t dsdt;
    uint8_t reserved;
    uint8_t preferred_power_management_profile;
    uint16_t sci_interrupt;
    uint32_t smi_command_port;
    uint8_t acpi_enable;
    uint8_t acpi_disable;
    uint8_t s4bios_req;
    uint8_t pstate_control;
    uint32_t pm1a_event_block;
    uint32_t pm1b_event_block;
    uint32_t pm1a_control_block;
    uint32_t pm1b_control_block;
    uint32_t pm2_control_block;
    uint32_t pm_timer_block;
    uint32_t gpe0_block;
    uint32_t gpe1_block;
    uint8_t pm1_event_length;
    uint8_t pm1_control_length;
    uint8_t pm2_control_length;
    uint8_t pm_timer_length;
    uint8_t gpe0_length;
    uint8_t gpe1_length;
    uint8_t gpe1_base;
    uint8_t cstate_control;
    uint16_t worst_c2_latency;
    uint16_t worst_c3_latency;
    uint16_t flush_size;
    uint16_t flush_stride;
    uint8_t duty_offset;
    uint8_t duty_width;
    uint8_t day_alarm;
    uint8_t month_alarm;
    uint8_t century;
    uint16_t boot_architecture_flags;
    uint8_t reserved2;
    uint32_t flags;
    uint8_t reset_reg[12];
    uint8_t reset_value;
    uint16_t arm_boot_architecture_flags;
    uint8_t fadt_minor_version;
    uint64_t x_firmware_ctrl;
    uint64_t x_dsdt;
    uint8_t x_pm1a_event_block[12];
    uint8_t x_pm1b_event_block[12];
    uint8_t x_pm1a_control_block[12];
    uint8_t x_pm1b_control_block[12];
    uint8_t x_pm2_control_block[12];
    uint8_t x_pm_timer_block[12];
    uint8_t x_gpe0_block[12];
    uint8_t x_gpe1_block[12];
} __attribute__((packed)) acpi_fadt_t;

typedef struct {
    acpi_sdt_header_t header;
    uint32_t local_apic_address;
    uint32_t flags;
    uint8_t entries[];
} __attribute__((packed)) acpi_madt_t;

#define MADT_ENTRY_LAPIC         0
#define MADT_ENTRY_IOAPIC        1
#define MADT_ENTRY_ISO           2
#define MADT_ENTRY_NMI           4
#define MADT_ENTRY_LAPIC_ADDR    5
#define MADT_ENTRY_IOAPIC_MMIO   6

typedef struct {
    uint8_t type;
    uint8_t length;
} __attribute__((packed)) madt_entry_header_t;

typedef struct {
    madt_entry_header_t header;
    uint8_t processor_id;
    uint8_t apic_id;
    uint32_t flags;
} __attribute__((packed)) madt_lapic_entry_t;

typedef struct {
    madt_entry_header_t header;
    uint8_t ioapic_id;
    uint8_t reserved;
    uint32_t ioapic_address;
    uint32_t global_system_interrupt_base;
} __attribute__((packed)) madt_ioapic_entry_t;

typedef struct {
    madt_entry_header_t header;
    uint8_t bus;
    uint8_t source;
    uint32_t global_system_interrupt;
    uint16_t flags;
} __attribute__((packed)) madt_iso_entry_t;

typedef struct {
    acpi_sdt_header_t header;
    uint8_t hardware_rev_id;
    uint8_t comparator_count : 5;
    uint8_t counter_size : 1;
    uint8_t reserved : 1;
    uint8_t legacy_replacement : 1;
    uint16_t pci_vendor_id;
    uint8_t address_space_id;
    uint8_t register_bit_width;
    uint8_t register_bit_offset;
    uint8_t reserved2;
    uint64_t address;
    uint8_t hpet_number;
    uint16_t minimum_tick;
    uint8_t page_protection;
} __attribute__((packed)) acpi_hpet_t;

typedef struct {
    acpi_sdt_header_t header;
    uint64_t reserved;
} __attribute__((packed)) acpi_mcfg_t;

typedef struct {
    uint64_t base_address;
    uint16_t pci_segment_group;
    uint8_t start_pci_bus;
    uint8_t end_pci_bus;
    uint32_t reserved;
} __attribute__((packed)) mcfg_entry_t;

typedef struct {
    acpi_sdt_header_t header;
    uint8_t definition_block[];
} __attribute__((packed)) acpi_ssdt_t;

void acpi_init(void);
bool acpi_is_available(void);
void* acpi_find_table(const char* signature, uint64_t index);
void acpi_print_tables(void);

extern volatile struct limine_rsdp_request rsdp_request;

void acpi_shutdown(void);

#endif


================================================================================
 FILE: ./kernel/include/apic/apic.h
================================================================================


#ifndef APIC_H
#define APIC_H

#include <stdint.h>
#include <stdbool.h>
#include "../acpi/acpi.h"

#define LAPIC_ID                0x0020
#define LAPIC_VERSION           0x0030
#define LAPIC_TPR               0x0080
#define LAPIC_EOI               0x00B0
#define LAPIC_SIVR              0x00F0
#define LAPIC_ISR0              0x0100
#define LAPIC_TIMER             0x0320
#define LAPIC_THERMAL           0x0330
#define LAPIC_PERFORMANCE       0x0340
#define LAPIC_LINT0             0x0350
#define LAPIC_LINT1             0x0360
#define LAPIC_ERROR             0x0370
#define LAPIC_TIMER_ICR         0x0380
#define LAPIC_TIMER_CCR         0x0390
#define LAPIC_TIMER_DCR         0x03E0

#define LAPIC_ENABLE            (1 << 8)
#define LAPIC_SPURIOUS_VECTOR   0xFF

#define LAPIC_TIMER_MASKED      (1 << 16)
#define LAPIC_TIMER_PERIODIC    (1 << 17)
#define LAPIC_TIMER_DIV1        0x0
#define LAPIC_TIMER_DIV2        0x1
#define LAPIC_TIMER_DIV4        0x2
#define LAPIC_TIMER_DIV8        0x3
#define LAPIC_TIMER_DIV16       0x4
#define LAPIC_TIMER_DIV32       0x5
#define LAPIC_TIMER_DIV64       0x6
#define LAPIC_TIMER_DIV128      0x7

#define IOAPIC_ID               0x00
#define IOAPIC_VERSION          0x01
#define IOAPIC_ARB              0x02
#define IOAPIC_REDIR_START      0x10

#define IOAPIC_INT_MASKED       (1 << 16)
#define IOAPIC_TRIGGER_LEVEL    (1 << 15)
#define IOAPIC_POLARITY_LOW     (1 << 13)
#define IOAPIC_DELIVERY_FIXED   0x0
#define IOAPIC_DELIVERY_NMI     0x4

#define HPET_CAPABILITIES      0x000
#define HPET_PERIOD            0x004
#define HPET_CONFIG            0x010
#define HPET_INTERRUPT_STATUS  0x020
#define HPET_MAIN_COUNTER      0x0F0
#define HPET_TIMER0_CONFIG     0x100
#define HPET_TIMER0_COMPARATOR 0x108

#define HPET_ENABLE_CNF        (1ULL << 0)
#define HPET_LEGACY_CNF        (1ULL << 1)

#define HPET_TN_INT_ENABLE_CNF   (1 << 2)
#define HPET_TN_INT_TYPE_CNF     (1 << 3)
#define HPET_TN_PERIODIC_CNF     (1 << 4)
#define HPET_TN_32BIT_CNF        (1 << 8)
#define HPET_TN_FSB_ENABLE_CNF   (1 << 14)
#define HPET_TN_FSB_INT_DEL_CNF  (1 << 15)

void apic_init(void);
bool apic_is_available(void);
bool hpet_is_available(void);
bool hpet_init(void);

void lapic_write(uint32_t reg, uint32_t value);
uint32_t lapic_read(uint32_t reg);
void lapic_eoi(void);
void lapic_enable(void);
uint32_t lapic_get_id(void);
void lapic_timer_init(uint32_t vector, uint32_t count, bool periodic, uint8_t divisor);
void lapic_timer_stop(void);
uint32_t lapic_timer_get_current(void);
void lapic_send_ipi(uint32_t target_lapic_id, uint8_t vector);
void lapic_send_ipi_to_all_but_self(uint8_t vector);

void ioapic_write(uintptr_t base, uint32_t reg, uint32_t value);
uint32_t ioapic_read(uintptr_t base, uint32_t reg);
uint32_t ioapic_get_max_redirects(uintptr_t base);
void ioapic_redirect_irq(uint8_t irq, uint8_t vector, uint32_t flags);
void ioapic_mask_irq(uint8_t irq);
void ioapic_unmask_irq(uint8_t irq);

void apic_setup_irq(uint8_t irq, uint8_t vector, bool mask, uint32_t flags);
void apic_timer_calibrate(void);

uint64_t hpet_read_counter(void);
uint64_t hpet_get_frequency(void);
void hpet_sleep_ns(uint64_t nanoseconds);
void hpet_sleep_us(uint64_t microseconds);
void hpet_sleep_ms(uint64_t milliseconds);

extern uintptr_t lapic_base;
extern uintptr_t ioapic_base;
extern uintptr_t hpet_base;
extern uint32_t hpet_period;

void ipi_reschedule_all(void);
void ipi_reschedule_cpu(uint32_t lapic_id);
void ipi_reschedule_single(uint32_t target_lapic_id);
void ipi_tlb_shootdown_broadcast(const uintptr_t* addrs, size_t count);
void ipi_tlb_shootdown_single(uint32_t target_lapic_id, uintptr_t addr);

#endif


================================================================================
 FILE: ./kernel/include/drivers/timer.h
================================================================================


#ifndef TIMER_H
#define TIMER_H

#include <stdint.h>
#include <stdbool.h>

bool timer_init(void);

uint64_t timer_get_ticks(void);

void timer_sleep_ms(uint64_t milliseconds);
void timer_sleep_us(uint64_t microseconds);
void timer_sleep_ns(uint64_t nanoseconds);

#endif


================================================================================
 FILE: ./kernel/include/elf/elf.h
================================================================================


#ifndef ELF_H
#define ELF_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include "../memory/vmm.h"
#include "../memory/paging.h"

#define ELF_MAGIC       0x464C457F

#define EI_CLASS        4
#define EI_DATA         5
#define EI_VERSION      6
#define EI_OSABI        7
#define EI_NIDENT       16

#define ELFCLASS64      2
#define ELFDATA2LSB     1
#define EV_CURRENT      1

#define ET_EXEC         2
#define ET_DYN          3

#define EM_X86_64       62

#define PT_NULL         0
#define PT_LOAD         1
#define PT_DYNAMIC      2
#define PT_INTERP       3
#define PT_NOTE         4
#define PT_PHDR         6
#define PT_TLS          7

#define PF_X            (1 << 0)
#define PF_W            (1 << 1)
#define PF_R            (1 << 2)

#define SHT_NULL        0
#define SHT_PROGBITS    1
#define SHT_SYMTAB      2
#define SHT_STRTAB      3
#define SHT_RELA        4
#define SHT_NOBITS      8

typedef struct {
    uint8_t  e_ident[EI_NIDENT];
    uint16_t e_type;
    uint16_t e_machine;
    uint32_t e_version;
    uint64_t e_entry;
    uint64_t e_phoff;
    uint64_t e_shoff;
    uint32_t e_flags;
    uint16_t e_ehsize;
    uint16_t e_phentsize;
    uint16_t e_phnum;
    uint16_t e_shentsize;
    uint16_t e_shnum;
    uint16_t e_shstrndx;
} __attribute__((packed)) elf64_ehdr_t;

typedef struct {
    uint32_t p_type;
    uint32_t p_flags;
    uint64_t p_offset;
    uint64_t p_vaddr;
    uint64_t p_paddr;
    uint64_t p_filesz;
    uint64_t p_memsz;
    uint64_t p_align;
} __attribute__((packed)) elf64_phdr_t;

typedef struct {
    uint32_t sh_name;
    uint32_t sh_type;
    uint64_t sh_flags;
    uint64_t sh_addr;
    uint64_t sh_offset;
    uint64_t sh_size;
    uint32_t sh_link;
    uint32_t sh_info;
    uint64_t sh_addralign;
    uint64_t sh_entsize;
} __attribute__((packed)) elf64_shdr_t;

typedef enum {
    ELF_OK = 0,
    ELF_ERR_NULL,
    ELF_ERR_TOO_SMALL,
    ELF_ERR_BAD_MAGIC,
    ELF_ERR_NOT_64,
    ELF_ERR_NOT_LE,
    ELF_ERR_BAD_VERSION,
    ELF_ERR_NOT_EXEC,
    ELF_ERR_WRONG_ARCH,
    ELF_ERR_NO_LOAD,
    ELF_ERR_MAP_FAIL,
    ELF_ERR_NO_MEM,
} elf_error_t;

typedef struct {
    uintptr_t       entry;
    vmm_pagemap_t*  pagemap;
    uintptr_t       load_base;
    uintptr_t       stack_top;
    size_t          stack_size;
    elf_error_t     error;
} elf_load_result_t;

elf_load_result_t elf_load(const void* data, size_t size, size_t stack_sz);

void elf_unload(elf_load_result_t* result);

const char* elf_strerror(elf_error_t err);

#endif


================================================================================
 FILE: ./kernel/include/gdt/gdt.h
================================================================================


#ifndef GDT_H
#define GDT_H

#include <stdint.h>

#define GDT_CODE_SEGMENT      0x08
#define GDT_DATA_SEGMENT      0x10
#define GDT_USER_CODE_SEGMENT 0x18
#define GDT_USER_DATA_SEGMENT 0x20
#define GDT_LIMIT_LOW(limit)  (limit & 0xFFFF)
#define GDT_BASE_LOW(base)    (base & 0xFFFF)
#define GDT_BASE_MIDDLE(base) ((base >> 16) & 0xFF)
#define GDT_FLAGS_HI_LIMIT(limit, flags)                                       \
    (((limit >> 16) & 0xF) | ((flags << 4) & 0xF0))
#define GDT_BASE_HIGH(base) ((base >> 24) & 0xFF)

#define GDT_ENTRY(base, limit, access, flags)                                  \
    {GDT_LIMIT_LOW(limit),                                                     \
     GDT_BASE_LOW(base),                                                       \
     GDT_BASE_MIDDLE(base),                                                    \
     access,                                                                   \
     GDT_FLAGS_HI_LIMIT(limit, flags),                                         \
     GDT_BASE_HIGH(base)}

#define TSS_SELECTOR_BASE 0x28
#define KERNEL_STACK_SIZE (4096 * 8)

typedef struct {
    uint32_t reserved0;
    uint64_t rsp0;
    uint64_t rsp1;
    uint64_t rsp2;
    uint64_t reserved1;
    uint64_t ist[7];
    uint64_t reserved2;
    uint32_t iobase;
}__attribute__((packed)) tss_t;

typedef struct {
    uint16_t limit_low;
    uint16_t base_low;
    uint8_t base_middle;
    uint8_t access;
    uint8_t limit_high_and_flags;
    uint8_t base_high;
}__attribute__((packed)) gdt_entry_t;

typedef struct {
    uint16_t limit_low;
    uint16_t base_low;
    uint8_t base_middle;
    uint8_t access;
    uint8_t limit_high_and_flags;
    uint8_t base_high;
    uint32_t base_higher;
    uint32_t zero;
}__attribute__((packed)) tss_entry_t;

typedef struct {
    uint16_t size;
    gdt_entry_t *pointer;
}__attribute__((packed)) gdt_pointer_t;
extern gdt_pointer_t gdtr;
extern void load_tss(uint16_t sel);
void gdt_init();
void gdt_load(void);

#endif


================================================================================
 FILE: ./kernel/include/graphics/fb/fb.h
================================================================================


#ifndef FB_H
#define FB_H

#include <stdint.h>
#include <stddef.h>
#include <limine.h>

#define RGB(r, g, b) (((r) << 16) | ((g) << 8) | (b))

#define COLOR_BLACK     RGB(  0,   0,   0)
#define COLOR_WHITE     RGB(255, 255, 255)
#define COLOR_RED       RGB(255,   0,   0)
#define COLOR_GREEN     RGB(  0, 255,   0)
#define COLOR_BLUE      RGB(  0,   0, 255)
#define COLOR_CYAN      RGB(  0, 255, 255)
#define COLOR_MAGENTA   RGB(255,   0, 255)
#define COLOR_YELLOW    RGB(255, 255,   0)
#define COLOR_ORANGE    RGB(255, 165,   0)
#define COLOR_GRAY      RGB(128, 128, 128)
#define COLOR_DARKGRAY  RGB( 64,  64,  64)
#define COLOR_BROWN     RGB(165,  42,  42)

// Структура заголовка PSFv2
struct psf_header {
    uint32_t magic;        // 0x72b54a86
    uint32_t version;      // 0
    uint32_t headersize;   // 32
    uint32_t flags;        // 0 или 1 (есть таблица Unicode)
    uint32_t numglyph;     // число глифов
    uint32_t bytesperglyph;// размер одного глифа
    uint32_t height;       // высота символа
    uint32_t width;        // ширина символа (обычно 8)
} __attribute__((packed));

extern uint8_t _binary_font_psf_start[];
extern uint8_t _binary_font_psf_end[];

static inline const uint8_t* get_font_data(void) {
    return (const uint8_t*)&_binary_font_psf_start;
}
static inline size_t get_font_data_size(void) {
    return _binary_font_psf_end - _binary_font_psf_start;
}

static inline const struct psf_header* get_psf_header(void) {
    return (const struct psf_header*)&_binary_font_psf_start;
}

int psf_validate(void);
void fb_draw_pixel(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t color);
void fb_fill_rect(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color);
void fb_clear(struct limine_framebuffer *fb, uint32_t color);
void fb_draw_char(struct limine_framebuffer *fb, char c, uint32_t x, uint32_t y, uint32_t color);
void fb_draw_string(struct limine_framebuffer *fb, const char *str, uint32_t x, uint32_t y, uint32_t color);

#endif 


================================================================================
 FILE: ./kernel/include/interrupts/idt.h
================================================================================


#ifndef IDT_H
#define IDT_H

#include <stdint.h>
#include <stdbool.h>

#define IDT_MAX_DESCRIPTORS 256

#define IS_FLAG_SETTED(x, flag)   ((x) | (flag))
#define FLAG_SET(x, flag)   ((x) |= (flag))
#define FLAG_UNSET(x, flag) ((x) &= ~(flag))

typedef enum {
    IDT_FLAG_GATE_TASK       = 0x5,
    IDT_FLAG_GATE_16BIT_INT  = 0x6,
    IDT_FLAG_GATE_16BIT_TRAP = 0x7,
    IDT_FLAG_GATE_32BIT_INT  = 0xE,
    IDT_FLAG_GATE_32BIT_TRAP = 0xF,

    IDT_FLAG_RING0 = (0 << 5),
    IDT_FLAG_RING1 = (1 << 5),
    IDT_FLAG_RING2 = (2 << 5),
    IDT_FLAG_RING3 = (3 << 5),

    IDT_FLAG_PRESENT = 0x80,

} IDT_FLAGS;

typedef struct {
    uint16_t base_low;
    uint16_t kernel_cs;
    uint8_t ist;
    uint8_t attributes;
    uint16_t base_mid;
    uint32_t base_high;
    uint32_t reserved;
}__attribute__((packed)) idt_entry_t;

typedef struct {
    uint16_t limit;
    idt_entry_t *base;
}__attribute__((packed)) idtr_t;
extern idtr_t idtr;
void setup_interrupt_descriptor_table(uint64_t kernel_code_segment);
void idt_load(void);

#endif



================================================================================
 FILE: ./kernel/include/interrupts/interrupts.h
================================================================================


#ifndef INTERRUPTS_H
#define INTERRUPTS_H

#include <stdint.h>

struct int_frame_t {
    uint64_t ds;

    uint64_t r15;
    uint64_t r14;
    uint64_t r13;
    uint64_t r12;
    uint64_t r11;
    uint64_t r10;
    uint64_t r9;
    uint64_t r8;

    uint64_t rbp;

    uint64_t rdi;
    uint64_t rsi;

    uint64_t rdx;
    uint64_t rcx;
    uint64_t rbx;
    uint64_t rax;

    uint64_t interrupt;
    uint64_t error;

    uint64_t rip;
    uint64_t cs;
    uint64_t rflags;
    uint64_t rsp;
    uint64_t ss;
} __attribute__((packed));

typedef void (*int_handler_f)(struct int_frame_t* frame);

typedef struct {
    uint64_t vector;
    int_handler_f handler;
} int_desc_t;

#define __CHECK_HANDLER(fn) \
    _Static_assert( \
        __builtin_types_compatible_p( \
            typeof(fn), void (*)(struct int_frame_t *)), \
        "Invalid interrupt handler signature")

#define __CONCAT(a, b) a##b
#define __UNIQUE_NAME(base) __CONCAT(base, __COUNTER__)

#define DEFINE_ISR(_vector, _name)                                  \
    static void _name(struct int_frame_t *frame);                  \
    static const int_desc_t __UNIQUE_NAME(__isr_desc_##_name)      \
    __attribute__((used, section(".isr_handlers"))) = {            \
        .vector  = (_vector),                                      \
        .handler = _name,                                          \
    };                                                             \
    static void _name(struct int_frame_t *frame)


#define DEFINE_IRQ(_vector, _name)                                  \
    static void _name(struct int_frame_t *frame);                  \
    static const int_desc_t __UNIQUE_NAME(__irq_desc_##_name)      \
    __attribute__((used, section(".irq_handlers"))) = {            \
        .vector  = (_vector),                                      \
        .handler = _name,                                          \
    };                                                             \
    static void _name(struct int_frame_t *frame)

#define IPI_RESCHEDULE_VECTOR   0x40
#define IPI_TLB_SHOOTDOWN   0x41
void init_interrupt_system();

#endif



================================================================================
 FILE: ./kernel/include/interrupts/irq.h
================================================================================


#ifndef IRQ_H
#define IRQ_H

#include <stdint.h>
#include "interrupts.h"

#define IRQ_INTERRUPTS_COUNT 224

static const char* irq_default_names[] __attribute__((unused)) = {
    "IRQ0 timer",
    "IRQ1 keyboard",
    "IRQ2 cascade",
    "IRQ3 COM2",
    "IRQ4 COM1",
    "IRQ5 LPT2",
    "IRQ6 floppy",
    "IRQ7 LPT1",
    "IRQ8 RTC",
    "IRQ9 ACPI",
    "IRQ10 reserved",
    "IRQ11 reserved",
    "IRQ12 mouse",
    "IRQ13 FPU",
    "IRQ14 ATA1",
    "IRQ15 ATA2"
};

void irq_common_handler(struct int_frame_t* regs);
void setup_defined_irq_handlers(void);

#endif



================================================================================
 FILE: ./kernel/include/interrupts/isr.h
================================================================================


#ifndef ISR_H
#define ISR_H

#include "interrupts.h"

#define ISR_EXCEPTION_COUNT 32

enum {
    EXCEPTION_DIVIDE_ERROR = 0,
    EXCEPTION_DEBUG,
    EXCEPTION_NMI,
    EXCEPTION_BREAKPOINT,
    EXCEPTION_OVERFLOW,
    EXCEPTION_BOUND_RANGE,
    EXCEPTION_INVALID_OPCODE,
    EXCEPTION_DEVICE_NOT_AVAILABLE,
    EXCEPTION_DOUBLE_FAULT,
    EXCEPTION_COPROCESSOR_SEGMENT_OVERRUN,
    EXCEPTION_INVALID_TSS,
    EXCEPTION_SEGMENT_NOT_PRESENT,
    EXCEPTION_STACK_SEGMENT_FAULT,
    EXCEPTION_GENERAL_PROTECTION_FAULT,
    EXCEPTION_PAGE_FAULT,
    EXCEPTION_RESERVED15,
    EXCEPTION_X87_FPU_ERROR,
    EXCEPTION_ALIGNMENT_CHECK,
    EXCEPTION_MACHINE_CHECK,
    EXCEPTION_SIMD_FPU_EXCEPTION,
    EXCEPTION_VIRTUALIZATION_EXCEPTION,
    EXCEPTION_RESERVED21,
    EXCEPTION_RESERVED22,
    EXCEPTION_RESERVED23,
    EXCEPTION_RESERVED24,
    EXCEPTION_RESERVED25,
    EXCEPTION_RESERVED26,
    EXCEPTION_RESERVED27,
    EXCEPTION_RESERVED28,
    EXCEPTION_RESERVED29,
    EXCEPTION_SECURITY_EXCEPTION = 30,
    EXCEPTION_RESERVED31
};

static const char* exception_names[] __attribute__((unused)) = {
    "Divide Error",
    "Debug",
    "Non-Maskable Interrupt",
    "Breakpoint",
    "Overflow",
    "Bound Range Exceeded",
    "Invalid Opcode",
    "Device Not Available",
    "Double Fault",
    "Coprocessor Segment Overrun",
    "Invalid TSS",
    "Segment Not Present",
    "Stack Segment Fault",
    "General Protection Fault",
    "Page Fault",
    "Reserved",
    "x87 Floating-Point Exception",
    "Alignment Check",
    "Machine Check",
    "SIMD Floating-Point Exception",
    "Virtualization Exception",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Security Exception",
    "Reserved"
};

void isr_common_handler(struct int_frame_t* regs);
void setup_defined_isr_handlers(void);

#endif



================================================================================
 FILE: ./kernel/include/io/ports.h
================================================================================


#ifndef PORTS_H
#define PORTS_H

#include <stdint.h>

static inline uint8_t inb(uint16_t port) {
    uint8_t result;
    asm volatile ("inb %1, %0" : "=a"(result) : "Nd"(port));
    return result;
}

static inline void outb(uint16_t port, uint8_t data) {
    asm volatile ("outb %0, %1" : : "a"(data), "Nd"(port));
}

static inline uint16_t inw(uint16_t port) {
    uint16_t result;
    asm volatile ("inw %1, %0" : "=a"(result) : "Nd"(port));
    return result;
}

static inline void outw(uint16_t port, uint16_t data) {
    asm volatile ("outw %0, %1" : : "a"(data), "Nd"(port));
}

static inline uint32_t inl(uint16_t port) {
    uint32_t result;
    asm volatile ("inl %1, %0" : "=a"(result) : "Nd"(port));
    return result;
}

static inline void outl(uint16_t port, uint32_t data) {
    asm volatile ("outl %0, %1" : : "a"(data), "Nd"(port));
}

static inline void io_wait(void) {
    outb(0x80, 0);
}

#endif 


================================================================================
 FILE: ./kernel/include/io/serial.h
================================================================================


#ifndef SERIAL_H
#define SERIAL_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <stdarg.h>

#define COM1 0x3F8
#define COM2 0x2F8
#define COM3 0x3E8
#define COM4 0x2E8

#define SERIAL_DATA_PORT(base)          (base)
#define SERIAL_FIFO_COMMAND_PORT(base)  (base + 2)
#define SERIAL_LINE_COMMAND_PORT(base)  (base + 3)
#define SERIAL_MODEM_COMMAND_PORT(base) (base + 4)
#define SERIAL_LINE_STATUS_PORT(base)   (base + 5)

#define SERIAL_LSR_DATA_READY           0x01
#define SERIAL_LSR_OVERRUN_ERROR        0x02
#define SERIAL_LSR_PARITY_ERROR          0x04
#define SERIAL_LSR_FRAMING_ERROR         0x08
#define SERIAL_LSR_BREAK_INDICATOR       0x10
#define SERIAL_LSR_TRANSMIT_HOLDING_EMPTY 0x20
#define SERIAL_LSR_TRANSMIT_EMPTY        0x40
#define SERIAL_LSR_FIFO_ERROR            0x80

void serial_initialize(uint16_t port, uint32_t baud_rate);

int serial_received_port(uint16_t port);
char serial_read_port(uint16_t port);
int serial_is_transmit_empty_port(uint16_t port);
void serial_write_port(uint16_t port, char c);
void serial_writestring_port(uint16_t port, const char* str);
void serial_printf_port(uint16_t port, const char* format, ...);

int serial_received(void);
char serial_read(void);
int serial_is_transmit_empty(void);
void serial_write(char c);
void serial_writestring(const char* str);
void serial_printf(const char* format, ...);

uint16_t serial_get_default_port(void);

void serial_set_default_port(uint16_t port);

#endif


================================================================================
 FILE: ./kernel/include/memory/paging.h
================================================================================


#ifndef PAGING_H
#define PAGING_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include "vmm.h"
#include "../include/interrupts/interrupts.h"

#define PAGING_PRESENT    VMM_PRESENT
#define PAGING_WRITE      VMM_WRITE
#define PAGING_USER       VMM_USER
#define PAGING_NOEXEC     VMM_NOEXEC

#define PAGING_KERNEL     (PAGING_PRESENT | PAGING_WRITE)
#define PAGING_USER_RW    (PAGING_PRESENT | PAGING_WRITE | PAGING_USER)
#define PAGING_USER_RO    (PAGING_PRESENT | PAGING_USER)
#define PAGING_USER_NOEXEC (PAGING_PRESENT | PAGING_USER | PAGING_NOEXEC)

#define PAGING_LARGE_PAGE_SIZE    0x200000
#define PAGING_HUGE_PAGE_SIZE     0x40000000

typedef struct {
    uintptr_t virtual_start;
    uintptr_t virtual_end;
    uintptr_t physical_start;
    uint64_t flags;
    size_t page_count;
    bool allocated;
} paging_region_t;

void paging_init(void);
bool paging_map_range(vmm_pagemap_t* pagemap, uintptr_t virt_start, uintptr_t phys_start, size_t page_count, uint64_t flags);
bool paging_unmap_range(vmm_pagemap_t* pagemap, uintptr_t virt_start, size_t page_count);
bool paging_change_flags(vmm_pagemap_t* pagemap, uintptr_t virt_start, size_t page_count, uint64_t new_flags);
paging_region_t* paging_create_region(vmm_pagemap_t* pagemap, uintptr_t virt_start, size_t size, uint64_t flags);
bool paging_destroy_region(vmm_pagemap_t* pagemap, paging_region_t* region);
void* paging_alloc_pages(vmm_pagemap_t* pagemap, size_t page_count, uint64_t flags, uintptr_t preferred_virt);
void paging_free_pages(vmm_pagemap_t* pagemap, void* virt_addr, size_t page_count);
bool paging_reserve_range(vmm_pagemap_t* pagemap, uintptr_t virt_start, uintptr_t virt_end);
bool paging_is_range_free(vmm_pagemap_t* pagemap, uintptr_t virt_start, uintptr_t virt_end);
void paging_print_stats(vmm_pagemap_t* pagemap);
void paging_dump_range(vmm_pagemap_t* pagemap, uintptr_t virt_start, uintptr_t virt_end);
#endif


================================================================================
 FILE: ./kernel/include/memory/pmm.h
================================================================================


#ifndef PMM_H
#define PMM_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <limine.h>

typedef struct {
    uintptr_t mem_start;
    uintptr_t mem_end;
    size_t total_pages;
    size_t usable_pages;
    size_t free_pages;
    size_t bitmap_size;
    uint8_t* bitmap;
    uint64_t hhdm_offset;
} pmm_state_t;

#define PAGE_SIZE 0x1000
#define PMM_PAGE_ALIGN(x) (((x) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

void pmm_init(struct limine_memmap_response*, struct limine_hhdm_response*);

void* pmm_alloc(size_t pages);
void* pmm_alloc_zero(size_t pages);
void* pmm_alloc_aligned(size_t pages, size_t alignment);
void pmm_free(void* addr, size_t pages);

uintptr_t pmm_virt_to_phys(void* addr);
void* pmm_phys_to_virt(uintptr_t addr);
uint64_t pmm_get_hhdm_offset(void);

size_t pmm_get_total_pages(void);
size_t pmm_get_free_pages(void);
size_t pmm_get_used_pages(void);

void pmm_print_stats(void);

#endif


================================================================================
 FILE: ./kernel/include/memory/vmm.h
================================================================================


#ifndef VMM_H
#define VMM_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#define VMM_PRESENT    (1ULL << 0)
#define VMM_WRITE      (1ULL << 1)
#define VMM_USER       (1ULL << 2)
#define VMM_PWT        (1ULL << 3)
#define VMM_PCD        (1ULL << 4)
#define VMM_ACCESSED   (1ULL << 5)
#define VMM_DIRTY      (1ULL << 6)
#define VMM_PSE        (1ULL << 7)
#define VMM_GLOBAL     (1ULL << 8)
#define VMM_NOEXEC     (1ULL << 63)

typedef uint64_t vmm_pte_t;

typedef struct {
    vmm_pte_t* pml4;
} vmm_pagemap_t;

extern uintptr_t kernel_pml4_phys;

void vmm_init(void);
vmm_pagemap_t* vmm_create_pagemap(void);
void vmm_switch_pagemap(vmm_pagemap_t* map);
bool vmm_map_page(vmm_pagemap_t* map, uintptr_t virt, uintptr_t phys, uint64_t flags);

void vmm_unmap_page(vmm_pagemap_t* map, uintptr_t virt);

void vmm_unmap_page_noflush(vmm_pagemap_t* map, uintptr_t virt);

bool vmm_virt_to_phys(vmm_pagemap_t* map, uintptr_t virt, uintptr_t* phys_out);
bool vmm_get_page_flags(vmm_pagemap_t* map, uintptr_t virt, uint64_t* flags_out);
vmm_pagemap_t* vmm_get_kernel_pagemap(void);
void vmm_test(void);

#endif


================================================================================
 FILE: ./kernel/include/sched/sched.h
================================================================================


#ifndef TASK_H
#define TASK_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#define MAX_PRIORITY     31
#define DEFAULT_PRIORITY 16
#define TASK_DEFAULT_TIMESLICE 10

typedef struct {
    uint8_t data[512] __attribute__((aligned(16)));
} fpu_state_t;

typedef enum {
    TASK_RUNNING = 0,
    TASK_READY,
    TASK_ZOMBIE,
    TASK_DEAD,
} task_state_t;

typedef struct task {
    uint64_t rsp;
    uint64_t rip;
    uint64_t rbp_save;
    uint64_t cr3;
    int      priority;
    bool     runnable;
    uint8_t  _pad0[3];
    uint32_t cpu_id;
    char     name[32];

    uint32_t time_slice;
    uint32_t time_slice_init;
    uint8_t  _pad1[4];
    uint64_t total_runtime;

    fpu_state_t* fpu_state;
    bool     fpu_used;
    uint8_t  _pad2[3];
    uint32_t last_cpu;
    uint64_t cpu_affinity;

    void (*entry)(void*);
    void *arg;

    uintptr_t stack_base;

    task_state_t state;

    struct task* next;
} task_t;

_Static_assert(offsetof(task_t, rsp)   ==   0, "task_t: rsp offset changed");
_Static_assert(offsetof(task_t, entry) == 120, "task_t: entry offset changed — update TASK_ENTRY_OFFSET in task_trampoline.asm");
_Static_assert(offsetof(task_t, arg)   == 128, "task_t: arg offset changed   — update TASK_ARG_OFFSET in task_trampoline.asm");

extern task_t* ready_queues[MAX_PRIORITY + 1];
extern task_t* current_task[8];

void sched_init(void);
task_t* task_create(const char* name, void (*entry)(void*), void* arg, int priority);
void task_yield(void);
void sched_reschedule(void);
void sched_print_stats(void);

__attribute__((noreturn)) void task_exit(void);

void task_kill(task_t* task);

void task_destroy(task_t* task);

extern void context_switch(task_t* old, task_t* next);
extern void first_task_start(task_t* task);
extern void task_trampoline(void);

extern void fpu_save(fpu_state_t* state);
extern void fpu_restore(fpu_state_t* state);

#endif


================================================================================
 FILE: ./kernel/include/smp/percpu.h
================================================================================


#ifndef PERCPU_H
#define PERCPU_H

#include <stdint.h>
#include "../include/smp/smp.h"

#define PERCPU_SECTION __attribute__((section(".percpu")))

extern uintptr_t __percpu_start;
extern uintptr_t __percpu_end;
typedef struct {
    uint32_t cpu_id;
    void* current_task;
    uint64_t some_counter;
    bool need_resched;
} __attribute__((aligned(64))) percpu_t;

extern percpu_t percpu;
extern percpu_t* percpu_regions[MAX_CPUS];

percpu_t* get_percpu(void);
percpu_t* get_percpu_mut(void);
void init_percpu_regions(void);
void set_percpu_base(percpu_t* base);
#define current_cpu_id() (get_percpu()->cpu_id)

#endif


================================================================================
 FILE: ./kernel/include/smp/smp.h
================================================================================


#ifndef SMP_H
#define SMP_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <limine.h>

#define AP_STACK_SIZE 16384
#define MAX_CPUS 256

#define MAX_TLB_ADDRESSES 32

typedef struct {
    volatile bool pending;
    uintptr_t addresses[MAX_TLB_ADDRESSES];
    size_t count;
} tlb_shootdown_t;

extern tlb_shootdown_t tlb_shootdown_queue[MAX_CPUS];
typedef enum {
    CPU_UNINITIALIZED = 0,
    CPU_BOOTED,
    CPU_ONLINE,
    CPU_OFFLINE,
    CPU_FAULTED
} cpu_state_t;

typedef struct {
    uint32_t lapic_id;
    uint32_t processor_id;
    uint32_t acpi_id;
    cpu_state_t state;
    bool is_bsp;
    uint64_t stack_top;
    uint32_t cpu_index;
    uint16_t tss_selector;
} cpu_info_t;

typedef struct {
    uint32_t cpu_count;
    uint32_t online_count;
    uint32_t bsp_lapic_id;
    uint64_t lapic_base;
    cpu_info_t cpus[256];
} smp_info_t;

void smp_init(struct limine_mp_response* mp_response);
void smp_boot_aps(struct limine_mp_response* mp_response);
smp_info_t* smp_get_info(void);
cpu_info_t* smp_get_current_cpu(void);
uint32_t smp_get_cpu_count(void);
uint32_t smp_get_online_count(void);
bool smp_is_bsp(void);
void smp_print_info(void);
void smp_print_info_fb(void);
void smp_wait_for_ready(void);
void ap_entry_point(struct limine_mp_info* cpu_info);
void sched_notify_ready(void);
#endif


================================================================================
 FILE: ./kernel/include/sse/fpu.h
================================================================================


#ifndef FPU_H
#define FPU_H

#include <stdint.h>
#include <stdbool.h>

void fpu_init(void);
bool fpu_detect(void);
void fpu_set_control_word(uint16_t cw);
uint16_t fpu_get_control_word(void);
void fpu_set_status_word(uint16_t sw);
uint16_t fpu_get_status_word(void);
void fpu_set_tag_word(uint16_t tw);
uint16_t fpu_get_tag_word(void);
void fpu_reset(void);

#endif // FPU_H


================================================================================
 FILE: ./kernel/include/sse/sse.h
================================================================================


#ifndef SSE_H
#define SSE_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#define MXCSR_DEFAULT 0x1F80
#define MXCSR_FLUSH_TO_ZERO   (1 << 15)
#define MXCSR_DENORMALS_ARE_ZERO (1 << 6)

bool sse_supported(void);
bool sse2_supported(void);
bool sse3_supported(void);
bool ssse3_supported(void);
bool sse4_1_supported(void);
bool sse4_2_supported(void);
bool avx_supported(void);
bool avx2_supported(void);
void sse_init(void);
void sse_set_mxcsr(uint32_t mxcsr);
uint32_t sse_get_mxcsr(void);
void sse_memcpy_fast(void* dest, const void* src, size_t n);
void sse_memset_fast(void* dest, int value, size_t n);
bool mmx_supported(void);
void mmx_enter(void);
void mmx_exit(void);
void print_simd_cpuid(void);
void enable_fsgsbase(void);

#endif // SSE_H


================================================================================
 FILE: ./kernel/src/acpi/acpi.c
================================================================================


#include "../../include/acpi/acpi.h"
#include "../../include/io/serial.h"
#include "../../include/io/ports.h"
#include "../../include/memory/pmm.h"
#include <string.h>

static acpi_rsdp2_t *rsdp;
static acpi_xsdt_t *xsdt;
static acpi_rsdt_t *rsdt;

static inline void *phys_to_virt(uintptr_t phys) {
    return (void *)(phys + pmm_get_hhdm_offset());
}

static bool checksum(void *base, size_t len) {
    uint8_t sum = 0;
    uint8_t *b = base;
    for (size_t i = 0; i < len; i++)
        sum += b[i];
    return sum == 0;
}

void acpi_init(void) {
    if (!rsdp_request.response) {
        serial_writestring("ACPI: no RSDP\n");
        return;
    }

    rsdp = (acpi_rsdp2_t *)rsdp_request.response->address;

    if (!checksum(&rsdp->rsdp_v1, sizeof(acpi_rsdp_t))) {
        serial_writestring("ACPI: bad RSDP checksum\n");
        return;
    }

    if (rsdp->rsdp_v1.revision >= 2 && rsdp->xsdt_address) {
        xsdt = phys_to_virt(rsdp->xsdt_address);
        if (!checksum(xsdt, xsdt->header.length))
            xsdt = NULL;
    }

    if (!xsdt && rsdp->rsdp_v1.rsdt_address) {
        rsdt = phys_to_virt(rsdp->rsdp_v1.rsdt_address);
        if (!checksum(rsdt, rsdt->header.length))
            rsdt = NULL;
    }

    if (!xsdt && !rsdt)
        return;
}

void *acpi_find_table(const char *sig, uint64_t index) {
    uint64_t count = 0;

    if (xsdt) {
        size_t n = (xsdt->header.length - sizeof(acpi_sdt_header_t)) / 8;
        for (size_t i = 0; i < n; i++) {
            acpi_sdt_header_t *h = phys_to_virt(xsdt->sdt_pointers[i]);
            if (!memcmp(h->signature, sig, 4)) {
                if (count++ == index)
                    return h;
            }
        }
    } else {
        size_t n = (rsdt->header.length - sizeof(acpi_sdt_header_t)) / 4;
        for (size_t i = 0; i < n; i++) {
            acpi_sdt_header_t *h = phys_to_virt(rsdt->sdt_pointers[i]);
            if (!memcmp(h->signature, sig, 4)) {
                if (count++ == index)
                    return h;
            }
        }
    }

    return NULL;
}

void acpi_print_tables(void) {
    serial_writestring("ACPI tables:\n");

    for (uint64_t i = 0;; i++) {
        acpi_sdt_header_t *h = acpi_find_table("APIC", i);
        if (!h) break;
        serial_writestring("  - APIC (MADT)\n");
    }

    for (uint64_t i = 0;; i++) {
        acpi_sdt_header_t *h = acpi_find_table("HPET", i);
        if (!h) break;
        serial_writestring("  - HPET\n");
    }

    for (uint64_t i = 0;; i++) {
        acpi_sdt_header_t *h = acpi_find_table("MCFG", i);
        if (!h) break;
        serial_writestring("  - MCFG (PCIe)\n");
    }
}

/*static void acpi_write_gas(const uint8_t *gas, uint8_t value) {
    uint8_t space_id = gas[0];
    uint64_t address = *(uint64_t*)(gas + 4);

    if (space_id == 0x01) {
        volatile uint8_t *mmio = phys_to_virt(address);
        *mmio = value;
    } else if (space_id == 0x00) {
        outb((uint16_t)address, value);
    }
}*/

static void acpi_send_pm1_command(acpi_fadt_t *fadt, uint8_t slp_typ, uint8_t slp_bit) {
    uint16_t cmd = (1 << 13) | (slp_typ << slp_bit);
    outw(fadt->pm1a_control_block, cmd);
    if (fadt->pm1b_control_block) {
        outw(fadt->pm1b_control_block, cmd);
    }
}

void acpi_shutdown(void) {
    acpi_fadt_t *fadt = (acpi_fadt_t *)acpi_find_table("FACP", 0);
    if (!fadt) {
        serial_writestring("ACPI shutdown: FADT not found\n");
        return;
    }

    const uint8_t candidates[] = {5, 0, 7, 1, 2, 3, 4, 6};
    size_t n = sizeof(candidates) / sizeof(candidates[0]);

    serial_writestring("ACPI shutdown: trying S5 candidates...\n");

    for (size_t i = 0; i < n; i++) {
        serial_printf("  Trying SLP_TYP=%d for S5...\n", candidates[i]);
        acpi_send_pm1_command(fadt, candidates[i], 10);
    }
}


================================================================================
 FILE: ./kernel/src/apic/apic.c
================================================================================


#include "../../include/apic/apic.h"
#include "../../include/io/serial.h"
#include "../../include/io/ports.h"
#include "../../include/acpi/acpi.h"
#include "../../include/memory/pmm.h"
#include "../../include/memory/vmm.h"
#include <string.h>
#include <stddef.h>

uintptr_t lapic_base = 0;
uintptr_t ioapic_base = 0;
uintptr_t hpet_base = 0;
uint32_t hpet_period = 0;
static acpi_madt_t* madt = NULL;
static acpi_hpet_t* hpet_table = NULL;

static inline uintptr_t phys_to_virt(uintptr_t phys) {
    return phys + pmm_get_hhdm_offset();
}

static bool map_mmio_region(uintptr_t phys_base, size_t size) {
    vmm_pagemap_t* kernel_pagemap = vmm_get_kernel_pagemap();
    if (!kernel_pagemap) return false;
    
    for (uintptr_t offset = 0; offset < size; offset += 0x1000) {
        uintptr_t phys_addr = phys_base + offset;
        uintptr_t virt_addr = phys_to_virt(phys_addr);
        
        uintptr_t mapped_phys;
        if (vmm_virt_to_phys(kernel_pagemap, virt_addr, &mapped_phys)) {
            if (mapped_phys != phys_addr) return false;
            continue;
        }
        
        if (!vmm_map_page(kernel_pagemap, virt_addr, phys_addr, 
                         VMM_PRESENT | VMM_WRITE | VMM_NOEXEC)) {
            return false;
        }
    }
    
    return true;
}

bool hpet_init(void) {
    hpet_table = (acpi_hpet_t*)acpi_find_table("HPET", 0);
    if (!hpet_table) return false;
    
    uintptr_t phys_base = hpet_table->address;
    if (!map_mmio_region(phys_base, 0x1000)) return false;
    
    hpet_base = phys_to_virt(phys_base);
    
    volatile uint32_t* hpet_regs = (volatile uint32_t*)hpet_base;
    hpet_period = hpet_regs[HPET_PERIOD / 4];
    if (hpet_period == 0) return false;
    
    uint64_t config = *(volatile uint64_t*)(hpet_base + HPET_CONFIG);
    config |= HPET_ENABLE_CNF;
    if (hpet_table->legacy_replacement) config |= HPET_LEGACY_CNF;
    *(volatile uint64_t*)(hpet_base + HPET_CONFIG) = config;
    
    return true;
}

bool hpet_is_available(void) {
    return hpet_base != 0 && hpet_period != 0;
}

uint64_t hpet_read_counter(void) {
    if (!hpet_base) return 0;
    
    if (hpet_table->counter_size) {
        return *(volatile uint64_t*)(hpet_base + HPET_MAIN_COUNTER);
    } else {
        return *(volatile uint32_t*)(hpet_base + HPET_MAIN_COUNTER);
    }
}

uint64_t hpet_get_frequency(void) {
    if (!hpet_period) return 0;
    return 1000000000000000ULL / hpet_period;
}

void hpet_sleep_ns(uint64_t nanoseconds) {
    if (!hpet_base || !hpet_period) return;
    
    uint64_t ticks_needed = (nanoseconds * 1000000ULL) / hpet_period;
    if (ticks_needed == 0) ticks_needed = 1;
    
    uint64_t start = hpet_read_counter();
    uint64_t target = start + ticks_needed;
    
    if (target > start) {
        while (hpet_read_counter() < target) asm volatile("pause");
    } else {
        while (hpet_read_counter() > start) asm volatile("pause");
        while (hpet_read_counter() < (target - 0xFFFFFFFFFFFFFFFFULL)) asm volatile("pause");
    }
}

void hpet_sleep_us(uint64_t microseconds) {
    hpet_sleep_ns(microseconds * 1000ULL);
}

void hpet_sleep_ms(uint64_t milliseconds) {
    hpet_sleep_ns(milliseconds * 1000000ULL);
}

static void parse_madt(void) {
    madt = (acpi_madt_t*)acpi_find_table("APIC", 0);
    if (!madt) return;
    
    if (!map_mmio_region(madt->local_apic_address, 0x1000)) return;
    lapic_base = phys_to_virt(madt->local_apic_address);
    
    uint8_t* entries = madt->entries;
    uint32_t length = madt->header.length;
    uint8_t* end = (uint8_t*)madt + length;
    
    while (entries < end) {
        madt_entry_header_t* header = (madt_entry_header_t*)entries;
        
        switch (header->type) {
            case MADT_ENTRY_LAPIC: {
                madt_lapic_entry_t* lapic_entry = (madt_lapic_entry_t*)entries;
                (void)lapic_entry;
                break;
            }
            
            case MADT_ENTRY_IOAPIC: {
                madt_ioapic_entry_t* ioapic_entry = (madt_ioapic_entry_t*)entries;
                if (!map_mmio_region(ioapic_entry->ioapic_address, 0x1000)) break;
                ioapic_base = phys_to_virt(ioapic_entry->ioapic_address);
                break;
            }
            
            default:
                break;
        }
        
        entries += header->length;
    }
}

bool apic_is_available(void) {
    return madt != NULL;
}

void apic_init(void) {
    parse_madt();
    if (!madt) return;
    if (!lapic_base) return;
    
    hpet_init();
    lapic_enable();
    
    if (ioapic_base) {
        uint32_t max_redirects = ioapic_get_max_redirects(ioapic_base);
        for (uint32_t i = 0; i < max_redirects; i++) {
            ioapic_mask_irq(i);
        }
    }
}

void apic_setup_irq(uint8_t irq, uint8_t vector, bool mask, uint32_t flags) {
    if (!ioapic_base) return;
    
    uint32_t redir_flags = IOAPIC_DELIVERY_FIXED | flags;
    if (mask) redir_flags |= IOAPIC_INT_MASKED;
    
    ioapic_redirect_irq(irq, vector, redir_flags);
}

void apic_timer_calibrate(void) {
    if (!hpet_is_available()) return;
    
    uint64_t measurement_time_ns = 10000000ULL;
    uint64_t hpet_ticks_needed = (measurement_time_ns * 1000000ULL) / hpet_period;
    
    lapic_write(LAPIC_TIMER_DCR, 0x3);
    lapic_write(LAPIC_TIMER_ICR, 0xFFFFFFFF);
    lapic_write(LAPIC_TIMER, LAPIC_TIMER_MASKED | 0xFF);
    lapic_write(LAPIC_TIMER, 0xFF);
    
    uint64_t hpet_start = hpet_read_counter();
    uint64_t hpet_target = hpet_start + hpet_ticks_needed;
    
    while (hpet_read_counter() < hpet_target) asm volatile("pause");
    
    lapic_write(LAPIC_TIMER, LAPIC_TIMER_MASKED | 0xFF);
    uint32_t remaining = lapic_read(LAPIC_TIMER_CCR);
    
    if (remaining == 0 || remaining == 0xFFFFFFFF) return;
    
    uint32_t ticks_elapsed = 0xFFFFFFFF - remaining;
    uint32_t ticks_per_10ms = (uint32_t)((ticks_elapsed * 10000000ULL) / measurement_time_ns);
    
    if (ticks_per_10ms == 0) return;
    
    lapic_timer_init(0x20, ticks_per_10ms, true, 0x3);
}


================================================================================
 FILE: ./kernel/src/apic/ioapic.c
================================================================================


#include "../../include/apic/apic.h"
#include "../../include/io/serial.h"
#include "../../include/memory/pmm.h"
#include <stddef.h>

static void ioapic_write_internal(uintptr_t base, uint32_t reg, uint32_t value) {
    if (!base) {
        serial_printf("IOAPIC: Attempt to write to unmapped IOAPIC (reg: 0x%x)\n", reg);
        return;
    }

    volatile uint32_t* ioregsel = (volatile uint32_t*)base;
    volatile uint32_t* iowin = (volatile uint32_t*)(base + 0x10);

    *ioregsel = reg;
    *iowin = value;
}

static uint32_t ioapic_read_internal(uintptr_t base, uint32_t reg) {
    if (!base) {
        serial_printf("IOAPIC: Attempt to read from unmapped IOAPIC (reg: 0x%x)\n", reg);
        return 0;
    }

    volatile uint32_t* ioregsel = (volatile uint32_t*)base;
    volatile uint32_t* iowin = (volatile uint32_t*)(base + 0x10);

    *ioregsel = reg;
    return *iowin;
}

void ioapic_write(uintptr_t base, uint32_t reg, uint32_t value) {
    ioapic_write_internal(base, reg, value);
}

uint32_t ioapic_read(uintptr_t base, uint32_t reg) {
    return ioapic_read_internal(base, reg);
}

uint32_t ioapic_get_max_redirects(uintptr_t base) {
    uint32_t version = ioapic_read(base, IOAPIC_VERSION);
    return ((version >> 16) & 0xFF) + 1;
}

void ioapic_redirect_irq(uint8_t irq, uint8_t vector, uint32_t flags) {
    if (!ioapic_base) return;

    uint32_t max_redirects = ioapic_get_max_redirects(ioapic_base);
    if (irq >= max_redirects) {
        serial_printf("IOAPIC: IRQ %u out of range (max %u)\n", irq, max_redirects);
        return;
    }

    uint32_t low = vector | flags;
    uint32_t high = 0;

    uint32_t redir_reg = IOAPIC_REDIR_START + irq * 2;

    ioapic_write(ioapic_base, redir_reg, low);
    ioapic_write(ioapic_base, redir_reg + 1, high);

    serial_printf("IOAPIC: IRQ %u redirected to vector 0x%x\n", irq, vector);
}

void ioapic_mask_irq(uint8_t irq) {
    if (!ioapic_base) return;

    uint32_t redir_reg = IOAPIC_REDIR_START + irq * 2;
    uint32_t current = ioapic_read(ioapic_base, redir_reg);
    ioapic_write(ioapic_base, redir_reg, current | IOAPIC_INT_MASKED);
}

void ioapic_unmask_irq(uint8_t irq) {
    if (!ioapic_base) return;

    uint32_t redir_reg = IOAPIC_REDIR_START + irq * 2;
    uint32_t current = ioapic_read(ioapic_base, redir_reg);
    ioapic_write(ioapic_base, redir_reg, current & ~IOAPIC_INT_MASKED);
}


================================================================================
 FILE: ./kernel/src/apic/lapic.c
================================================================================


#include "../../include/apic/apic.h"
#include "../../include/io/serial.h"
#include "../../include/io/ports.h"
#include "../../include/memory/pmm.h"
#include "../../include/smp/smp.h"
#include "../../include/interrupts/interrupts.h"
#include <stddef.h>

static inline uintptr_t phys_to_virt(uintptr_t phys) {
    return phys + pmm_get_hhdm_offset();
}

void lapic_write(uint32_t reg, uint32_t value) {
    if (!lapic_base) {
        serial_printf("LAPIC: Attempt to write to unmapped LAPIC (reg: 0x%x)\n", reg);
        return;
    }

    if (reg & 0x3) {
        serial_printf("LAPIC: Unaligned register access: 0x%x\n", reg);
        return;
    }

    volatile uint32_t* addr = (volatile uint32_t*)(lapic_base + reg);
    *addr = value;

    (void)*addr;
}

uint32_t lapic_read(uint32_t reg) {
    if (!lapic_base) {
        serial_printf("LAPIC: Attempt to read from unmapped LAPIC (reg: 0x%x)\n", reg);
        return 0;
    }

    if (reg & 0x3) {
        serial_printf("LAPIC: Unaligned register access: 0x%x\n", reg);
        return 0;
    }

    volatile uint32_t* addr = (volatile uint32_t*)(lapic_base + reg);
    return *addr;
}

void lapic_enable(void) {
    if (!lapic_base) return;

    lapic_write(LAPIC_SIVR, lapic_read(LAPIC_SIVR) | LAPIC_ENABLE | LAPIC_SPURIOUS_VECTOR);
    serial_printf("LAPIC enabled, ID: 0x%x\n", lapic_get_id());
}

uint32_t lapic_get_id(void) {
    return (lapic_read(LAPIC_ID) >> 24) & 0xFF;
}

void lapic_eoi(void) {
    lapic_write(LAPIC_EOI, 0);
}

void lapic_timer_init(uint32_t vector, uint32_t count, bool periodic, uint8_t divisor) {
    serial_printf("Initializing LAPIC timer: vector=0x%x, count=%u, periodic=%d, divisor=%u\n",
                  vector, count, periodic, divisor);

    if (count == 0) {
        serial_writestring("Warning: APIC timer count is 0, timer will not generate interrupts\n");
    }

    lapic_write(LAPIC_TIMER, LAPIC_TIMER_MASKED);

    lapic_write(LAPIC_TIMER_DCR, divisor & 0x7);

    lapic_write(LAPIC_TIMER_ICR, count);

    uint32_t timer_config = vector & 0xFF;
    if (periodic) {
        timer_config |= LAPIC_TIMER_PERIODIC;
    }

    lapic_write(LAPIC_TIMER, timer_config);

    uint32_t current = lapic_read(LAPIC_TIMER_CCR);
    serial_printf("LAPIC timer started: current count: %u\n", current);
}

void lapic_timer_stop(void) {
    lapic_write(LAPIC_TIMER, LAPIC_TIMER_MASKED);
}

uint32_t lapic_timer_get_current(void) {
    return lapic_read(LAPIC_TIMER_CCR);
}

void lapic_send_ipi(uint32_t target_lapic_id, uint8_t vector)
{
    uint32_t icr_low  = vector | (0 << 8) | (1 << 14);
    uint32_t icr_high = target_lapic_id << 24;

    lapic_write(0x310, icr_high);
    lapic_write(0x300, icr_low);

    while (lapic_read(0x300) & (1 << 12))
        asm volatile ("pause");

    serial_printf("Sent IPI vector 0x%02x to LAPIC %u\n", vector, target_lapic_id);
}

void lapic_send_ipi_to_all_but_self(uint8_t vector)
{
    uint32_t icr_low = vector | (0 << 8) | (1 << 14) | (3 << 18);

    lapic_write(0x310, 0);
    lapic_write(0x300, icr_low);

    while (lapic_read(0x300) & (1 << 12))
        asm volatile ("pause");

    serial_printf("Broadcast IPI (all but self) vector 0x%02x sent\n", vector);
}

void ipi_reschedule_all(void) {
    lapic_send_ipi_to_all_but_self(IPI_RESCHEDULE_VECTOR);
}

void ipi_reschedule_cpu(uint32_t lapic_id) {
    lapic_send_ipi(lapic_id, IPI_RESCHEDULE_VECTOR);
}

void ipi_reschedule_single(uint32_t target_lapic_id) {
    uint32_t icr_high = target_lapic_id << 24;
    uint32_t icr_low = IPI_RESCHEDULE_VECTOR | (0 << 8) | (1 << 14);

    lapic_write(0x310, icr_high);
    lapic_write(0x300, icr_low);

    while (lapic_read(0x300) & (1 << 12))
        asm volatile ("pause");

    serial_printf("Reschedule IPI sent to LAPIC %u\n", target_lapic_id);
}

void ipi_tlb_shootdown_broadcast(const uintptr_t* addrs, size_t count) {
    if (count > MAX_TLB_ADDRESSES) count = MAX_TLB_ADDRESSES;

    uint32_t   my_lapic = lapic_get_id();
    smp_info_t* info    = smp_get_info();

    for (uint32_t i = 0; i < info->cpu_count; i++) {
        uint32_t target_lapic = info->cpus[i].lapic_id;
        if (target_lapic == my_lapic) continue;

        tlb_shootdown_t* q = &tlb_shootdown_queue[target_lapic];
        q->count = count;
        for (size_t j = 0; j < count; j++)
            q->addresses[j] = addrs[j];
        __atomic_store_n(&q->pending, true, __ATOMIC_RELEASE);
    }

    asm volatile ("mfence" ::: "memory");

    uint32_t icr_low = IPI_TLB_SHOOTDOWN
                     | (0 << 8)
                     | (1 << 14)
                     | (3 << 18);

    lapic_write(0x310, 0);
    lapic_write(0x300, icr_low);

    while (lapic_read(0x300) & (1 << 12))
        asm volatile ("pause");

    serial_printf("TLB shootdown broadcast sent for %zu addresses\n", count);
}

void ipi_tlb_shootdown_single(uint32_t target_lapic_id, uintptr_t addr) {
    tlb_shootdown_t* q = &tlb_shootdown_queue[target_lapic_id];

    q->addresses[0] = addr;
    q->count = 1;
    __atomic_store_n(&q->pending, true, __ATOMIC_RELEASE);

    asm volatile ("mfence" ::: "memory");

    uint32_t icr_high = target_lapic_id << 24;
    uint32_t icr_low  = IPI_TLB_SHOOTDOWN | (0 << 8) | (1 << 14);

    lapic_write(0x310, icr_high);
    lapic_write(0x300, icr_low);

    while (lapic_read(0x300) & (1 << 12))
        asm volatile ("pause");

    serial_printf("TLB shootdown sent to LAPIC %u for virt 0x%llx\n",
                  target_lapic_id, addr);
}



================================================================================
 FILE: ./kernel/src/drivers/timer.c
================================================================================


#include "../include/drivers/timer.h"
#include "../include/apic/apic.h"
#include "../include/io/serial.h"
#include "../include/interrupts/interrupts.h"
#include "../include/io/ports.h"
#include "../include/sched/sched.h"
#include "../include/smp/percpu.h"

static volatile uint64_t ticks = 0;

DEFINE_IRQ(0x20, timer_handler)
{
    ticks++;
    lapic_eoi();

    uint32_t cpu = lapic_get_id();
    task_t* current = current_task[cpu];

    if (!current) return;

    if (current->time_slice > 0) {
        current->time_slice--;
    }

    bool force_resched = false;
    percpu_t* pc = get_percpu();
    if (pc && pc->need_resched) {
        pc->need_resched = false;
        force_resched = true;
    }

    if (current->time_slice == 0 || force_resched) {
        sched_reschedule();
    }

    (void)frame;
}

bool timer_init(void) {
    serial_writestring("Initializing timer subsystem...\n");

    if (!apic_is_available()) {
        serial_writestring("ERROR: APIC not available\n");
        return false;
    }

    apic_timer_calibrate();

    outb(0x21, 0xFF);
    outb(0xA1, 0xFF);

    serial_writestring("Timer subsystem initialized\n");

    if (hpet_is_available()) {
        serial_printf("HPET frequency: %llu Hz\n", hpet_get_frequency());
    } else {
        serial_writestring("HPET not available\n");
    }

    serial_writestring("Checking APIC Timer Status\n");

    uint32_t timer_config = lapic_read(LAPIC_TIMER);
    uint32_t initial_count = lapic_read(LAPIC_TIMER_ICR);
    uint32_t current_count = lapic_read(LAPIC_TIMER_CCR);

    serial_printf("APIC Timer Config: 0x%x\n", timer_config);
    serial_printf("  Vector: 0x%x\n", timer_config & 0xFF);
    serial_printf("  Masked: %s\n", (timer_config & LAPIC_TIMER_MASKED) ? "YES" : "NO");
    serial_printf("  Periodic: %s\n", (timer_config & LAPIC_TIMER_PERIODIC) ? "YES" : "NO");
    serial_printf("Initial Count: %u\n", initial_count);
    serial_printf("Current Count: %u\n", current_count);

    if (timer_config & LAPIC_TIMER_MASKED) {
        serial_writestring("WARNING: APIC timer is masked! Unmasking...\n");
        lapic_write(LAPIC_TIMER, (timer_config & ~LAPIC_TIMER_MASKED));
    }

    uint64_t rflags;
    asm volatile("pushfq; pop %0" : "=r"(rflags));
    serial_printf("RFLAGS: 0x%llx (IF=%s)\n", rflags, (rflags & 0x200) ? "ON" : "OFF");

    if (!(rflags & 0x200)) {
        serial_writestring("WARNING: Interrupts are DISABLED! Enabling...\n");
        asm volatile("sti");
    }

    return true;
}

uint64_t timer_get_ticks(void) {
    return ticks;
}

void timer_sleep_ms(uint64_t milliseconds) {
    if (hpet_is_available()) {
        hpet_sleep_ms(milliseconds);
    } else {
        volatile uint64_t i;
        for (i = 0; i < milliseconds * 1000; i++) {
            asm volatile("pause");
        }
    }
}

void timer_sleep_us(uint64_t microseconds) {
    if (hpet_is_available()) {
        hpet_sleep_us(microseconds);
    } else {
        volatile uint64_t i;
        for (i = 0; i < microseconds; i++) {
            asm volatile("pause");
        }
    }
}

void timer_sleep_ns(uint64_t nanoseconds) {
    if (hpet_is_available()) {
        hpet_sleep_ns(nanoseconds);
    } else {
        timer_sleep_us(nanoseconds / 1000);
    }
}


================================================================================
 FILE: ./kernel/src/elf/elf.c
================================================================================


#include "../../include/elf/elf.h"
#include "../../include/memory/vmm.h"
#include "../../include/memory/pmm.h"
#include "../../include/memory/paging.h"
#include "../../include/io/serial.h"
#include <string.h>
#include <stdlib.h>

#define ELF_PIE_BASE        0x0000000000400000ULL
#define ELF_USER_STACK_TOP  0x00007FFFFFFFE000ULL
#define ELF_DEFAULT_STACK   (64 * 1024)

#define PML4_KERNEL_START   256
#define PML4_ENTRIES        512

static inline uintptr_t page_align_down(uintptr_t addr) {
    return addr & ~(uintptr_t)(PAGE_SIZE - 1);
}
static inline uintptr_t page_align_up(uintptr_t addr) {
    return (addr + PAGE_SIZE - 1) & ~(uintptr_t)(PAGE_SIZE - 1);
}
static uint64_t phdr_flags_to_vmm(uint32_t pf) {
    uint64_t flags = VMM_PRESENT | VMM_USER;
    if (pf & PF_W)    flags |= VMM_WRITE;
    if (!(pf & PF_X)) flags |= VMM_NOEXEC;
    return flags;
}

static void inherit_kernel_pml4(vmm_pagemap_t* dst) {
    vmm_pagemap_t* kmap     = vmm_get_kernel_pagemap();
    vmm_pte_t*     src_pml4 = kmap->pml4;
    vmm_pte_t*     dst_pml4 = dst->pml4;

    for (int i = PML4_KERNEL_START; i < PML4_ENTRIES; i++) {
        dst_pml4[i] = src_pml4[i];
    }

    serial_printf("[ELF] Kernel PML4[%d..%d] inherited\n",
                  PML4_KERNEL_START, PML4_ENTRIES - 1);
}

static elf_error_t elf_validate(const elf64_ehdr_t* hdr, size_t size) {
    if (size < sizeof(elf64_ehdr_t))          return ELF_ERR_TOO_SMALL;

    uint32_t magic;
    memcpy(&magic, hdr->e_ident, 4);
    if (magic != ELF_MAGIC)                   return ELF_ERR_BAD_MAGIC;
    if (hdr->e_ident[EI_CLASS]   != ELFCLASS64)  return ELF_ERR_NOT_64;
    if (hdr->e_ident[EI_DATA]    != ELFDATA2LSB) return ELF_ERR_NOT_LE;
    if (hdr->e_ident[EI_VERSION] != EV_CURRENT ||
        hdr->e_version           != EV_CURRENT)  return ELF_ERR_BAD_VERSION;
    if (hdr->e_type != ET_EXEC && hdr->e_type != ET_DYN) return ELF_ERR_NOT_EXEC;
    if (hdr->e_machine != EM_X86_64)          return ELF_ERR_WRONG_ARCH;
    if (hdr->e_phnum == 0)                    return ELF_ERR_NO_LOAD;

    uint64_t pht_end = (uint64_t)hdr->e_phoff +
                       (uint64_t)hdr->e_phentsize * hdr->e_phnum;
    if (pht_end > size)                       return ELF_ERR_TOO_SMALL;
    return ELF_OK;
}

static elf_error_t load_segment(vmm_pagemap_t*      map,
                                const uint8_t*      data,
                                size_t              file_size,
                                const elf64_phdr_t* phdr,
                                uintptr_t           load_bias)
{
    if (phdr->p_memsz == 0) return ELF_OK;

    uintptr_t virt_start = phdr->p_vaddr + load_bias;
    uintptr_t virt_end   = virt_start + phdr->p_memsz;
    uintptr_t page_start = page_align_down(virt_start);
    uintptr_t page_end   = page_align_up(virt_end);
    size_t    page_count = (page_end - page_start) / PAGE_SIZE;

    void* phys_pages = pmm_alloc_zero(page_count);
    if (!phys_pages) {
        serial_printf("[ELF] pmm_alloc_zero(%zu) failed for vaddr 0x%llx\n",
                      page_count, virt_start);
        return ELF_ERR_NO_MEM;
    }

    uint8_t*  mapped_virt = (uint8_t*)pmm_phys_to_virt(pmm_virt_to_phys(phys_pages));
    size_t    page_offset = virt_start - page_start;

    if (phdr->p_filesz > 0) {
        if (phdr->p_offset + phdr->p_filesz > file_size) {
            serial_printf("[ELF] Segment data out of file bounds\n");
            pmm_free(phys_pages, page_count);
            return ELF_ERR_TOO_SMALL;
        }
        memcpy(mapped_virt + page_offset, data + phdr->p_offset, phdr->p_filesz);
    }

    uint64_t  vmm_flags = phdr_flags_to_vmm(phdr->p_flags);
    uintptr_t phys_base = pmm_virt_to_phys(phys_pages);

    for (size_t i = 0; i < page_count; i++) {
        uintptr_t virt = page_start + i * PAGE_SIZE;
        uintptr_t phys = phys_base  + i * PAGE_SIZE;
        if (!vmm_map_page(map, virt, phys, vmm_flags)) {
            serial_printf("[ELF] vmm_map_page failed: virt=0x%llx\n", virt);
            for (size_t j = 0; j < i; j++)
                vmm_unmap_page(map, page_start + j * PAGE_SIZE);
            pmm_free(phys_pages, page_count);
            return ELF_ERR_MAP_FAIL;
        }
    }

    serial_printf("[ELF] Segment loaded: virt=0x%llx-0x%llx flags=%s%s%s "
                 "phys=0x%llx pages=%zu\n",
                 virt_start, virt_end,
                 (phdr->p_flags & PF_R) ? "R" : "-",
                 (phdr->p_flags & PF_W) ? "W" : "-",
                 (phdr->p_flags & PF_X) ? "X" : "-",
                 phys_base, page_count);
    return ELF_OK;
}

static uintptr_t alloc_user_stack(vmm_pagemap_t* map, size_t stack_size) {
    size_t    page_count = page_align_up(stack_size) / PAGE_SIZE;
    void*     phys       = pmm_alloc_zero(page_count);
    if (!phys) {
        serial_printf("[ELF] Stack alloc failed (%zu pages)\n", page_count);
        return 0;
    }

    uintptr_t stack_bottom = ELF_USER_STACK_TOP - page_count * PAGE_SIZE;
    uintptr_t phys_base    = pmm_virt_to_phys(phys);
    uint64_t  flags        = VMM_PRESENT | VMM_WRITE | VMM_USER | VMM_NOEXEC;

    for (size_t i = 0; i < page_count; i++) {
        if (!vmm_map_page(map, stack_bottom + i * PAGE_SIZE,
                               phys_base    + i * PAGE_SIZE, flags)) {
            serial_printf("[ELF] Stack map failed at page %zu\n", i);
            for (size_t j = 0; j < i; j++)
                vmm_unmap_page(map, stack_bottom + j * PAGE_SIZE);
            pmm_free(phys, page_count);
            return 0;
        }
    }

    serial_printf("[ELF] Stack: virt=0x%llx-0x%llx (%zu KiB)\n",
                 stack_bottom, ELF_USER_STACK_TOP,
                 (page_count * PAGE_SIZE) / 1024);

    return ELF_USER_STACK_TOP & ~(uintptr_t)0xF;
}

elf_load_result_t elf_load(const void* data, size_t size, size_t stack_sz) {
    elf_load_result_t result = {0};

    if (!data) { result.error = ELF_ERR_NULL; return result; }

    const elf64_ehdr_t* ehdr = (const elf64_ehdr_t*)data;
    result.error = elf_validate(ehdr, size);
    if (result.error != ELF_OK) {
        serial_printf("[ELF] Validation failed: %s\n", elf_strerror(result.error));
        return result;
    }

    uintptr_t load_bias = (ehdr->e_type == ET_DYN) ? ELF_PIE_BASE : 0;
    if (load_bias) serial_printf("[ELF] PIE binary, bias=0x%llx\n", load_bias);

    vmm_pagemap_t* map = vmm_create_pagemap();
    if (!map) {
        serial_printf("[ELF] vmm_create_pagemap() failed\n");
        result.error = ELF_ERR_NO_MEM;
        return result;
    }
    result.pagemap = map;

    inherit_kernel_pml4(map);

    const uint8_t*      bytes = (const uint8_t*)data;
    const elf64_phdr_t* phdrs = (const elf64_phdr_t*)(bytes + ehdr->e_phoff);
    bool has_load = false;

    for (uint16_t i = 0; i < ehdr->e_phnum; i++) {
        const elf64_phdr_t* ph = &phdrs[i];
        if (ph->p_type != PT_LOAD) continue;
        has_load = true;

        serial_printf("[ELF] PT_LOAD[%u]: off=0x%llx vaddr=0x%llx "
                     "filesz=0x%llx memsz=0x%llx flags=0x%x\n",
                     i, ph->p_offset, ph->p_vaddr,
                     ph->p_filesz, ph->p_memsz, ph->p_flags);

        elf_error_t err = load_segment(map, bytes, size, ph, load_bias);
        if (err != ELF_OK) { result.error = err; return result; }
    }

    if (!has_load) { result.error = ELF_ERR_NO_LOAD; return result; }

    result.entry     = ehdr->e_entry + load_bias;
    result.load_base = load_bias;
    serial_printf("[ELF] Entry point: 0x%llx\n", result.entry);

    if (stack_sz == 0) stack_sz = ELF_DEFAULT_STACK;
    result.stack_size = stack_sz;
    result.stack_top  = alloc_user_stack(map, stack_sz);
    if (result.stack_top == 0) { result.error = ELF_ERR_NO_MEM; return result; }

    serial_printf("[ELF] Load complete. entry=0x%llx stack_top=0x%llx\n",
                 result.entry, result.stack_top);
    return result;
}

void elf_unload(elf_load_result_t* result) {
    if (!result) return;
    if (result->pagemap) {
        free(result->pagemap);
        result->pagemap = NULL;
    }
    serial_printf("[ELF] Process unloaded.\n");
}

const char* elf_strerror(elf_error_t err) {
    switch (err) {
        case ELF_OK:              return "OK";
        case ELF_ERR_NULL:        return "NULL pointer";
        case ELF_ERR_TOO_SMALL:   return "file too small / data out of bounds";
        case ELF_ERR_BAD_MAGIC:   return "not an ELF file (bad magic)";
        case ELF_ERR_NOT_64:      return "not ELF64";
        case ELF_ERR_NOT_LE:      return "not little-endian";
        case ELF_ERR_BAD_VERSION: return "unsupported ELF version";
        case ELF_ERR_NOT_EXEC:    return "not an executable or shared object";
        case ELF_ERR_WRONG_ARCH:  return "not x86_64";
        case ELF_ERR_NO_LOAD:     return "no PT_LOAD segments";
        case ELF_ERR_MAP_FAIL:    return "vmm_map_page failed";
        case ELF_ERR_NO_MEM:      return "out of memory";
        default:                  return "unknown error";
    }
}


================================================================================
 FILE: ./kernel/src/gdt/gdt.c
================================================================================


#include "../../include/gdt/gdt.h"
#include "../../include/smp/smp.h"
#include "../../include/io/serial.h"
#include <string.h>
#include <stddef.h>

gdt_pointer_t gdtr;
struct {
    gdt_entry_t gdt_entries[5 + (MAX_CPUS * 2)];
} __attribute__((packed)) gdt;

tss_t tss[MAX_CPUS] = {0};
__attribute__((aligned(16))) char kernel_stacks[MAX_CPUS][KERNEL_STACK_SIZE];
__attribute__((aligned(16))) char def_ist_stacks[MAX_CPUS][KERNEL_STACK_SIZE];
__attribute__((aligned(16))) char df_stacks[MAX_CPUS][KERNEL_STACK_SIZE];
__attribute__((aligned(16))) char nmi_stacks[MAX_CPUS][KERNEL_STACK_SIZE];
__attribute__((aligned(16))) char pf_stacks[MAX_CPUS][KERNEL_STACK_SIZE];

extern void _load_gdt(gdt_pointer_t *descriptor);
extern void _reload_segments(uint64_t cs, uint64_t ds);

void gdt_init() {
    memset(&gdt, 0, sizeof(gdt));
    gdt.gdt_entries[0] = (gdt_entry_t)GDT_ENTRY(0, 0, 0, 0);
    gdt.gdt_entries[1] = (gdt_entry_t)GDT_ENTRY(0, 0xFFFFF, 0x9A, 0xA);
    gdt.gdt_entries[2] = (gdt_entry_t)GDT_ENTRY(0, 0xFFFFF, 0x92, 0xC);
    gdt.gdt_entries[3] = (gdt_entry_t)GDT_ENTRY(0, 0xFFFFF, 0xFA, 0xA);
    gdt.gdt_entries[4] = (gdt_entry_t)GDT_ENTRY(0, 0xFFFFF, 0xF2, 0xC);

    gdtr.size = (5 * sizeof(gdt_entry_t)) - 1;
    gdtr.pointer = &gdt.gdt_entries[0];

    serial_printf("Installing temporary GDT for BSP...\n");
    gdt_load();
    serial_printf("Temporary GDT installed\n");
}

void gdt_load(void) {
    _load_gdt(&gdtr);
    _reload_segments(GDT_CODE_SEGMENT, GDT_DATA_SEGMENT);
}


================================================================================
 FILE: ./kernel/src/graphics/fb/fb.c
================================================================================


#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <limine.h>
#include "../../../include/graphics/fb/fb.h"

void fb_draw_pixel(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t color) {
    if (x >= fb->width || y >= fb->height) return;
    uint32_t *fb_ptr = (uint32_t *)fb->address;
    uint32_t pitch = fb->pitch / 4;
    fb_ptr[y * pitch + x] = color;
}

void fb_fill_rect(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color) {
    for (uint32_t py = y; py < y + h; py++) {
        for (uint32_t px = x; px < x + w; px++) {
            fb_draw_pixel(fb, px, py, color);
        }
    }
}

void fb_clear(struct limine_framebuffer *fb, uint32_t color) {
    uint32_t *fb_ptr = (uint32_t *)fb->address;
    size_t pixels = fb->width * fb->height;
    for (size_t i = 0; i < pixels; i++) {
        fb_ptr[i] = color;
    }
}

int psf_validate(void) {
    const uint8_t *raw = get_font_data();
    
    // Проверка для PSF v2
    if (raw[0] == 0x72 && raw[1] == 0xb5 && 
        raw[2] == 0x4a && raw[3] == 0x86) {
        return 2; // PSF v2
    }
    
    // Проверка для PSF v1
    if (raw[0] == 0x36 && raw[1] == 0x04) {
        return 1; // PSF v1
    }
    
    return 0; // Невалидный шрифт
}

void fb_draw_char(struct limine_framebuffer *fb, char c, uint32_t x, uint32_t y, uint32_t color) {
    const uint8_t *raw = get_font_data();
    uint32_t headersize = 32;
    uint32_t charsiz = *(uint32_t*)(raw + 20);
    
    uint8_t *glyphs = (uint8_t*)raw + headersize;
    uint32_t glyph_index;
    
    // Обработка разных диапазонов символов
    if ((uint8_t)c < 128) {
        glyph_index = (uint8_t)c;
    } else if ((uint8_t)c >= 128) {
        glyph_index = '?'; 
    } else {
        glyph_index = '?'; 
    }
    
    // Проверка границ
    if (glyph_index >= 512) {
        glyph_index = '?';
    }
    
    uint8_t *glyph = &glyphs[glyph_index * charsiz];

    // Отрисовка
    for (uint32_t row = 0; row < 16; row++) {
        uint8_t byte = glyph[row];
        for (uint32_t col = 0; col < 8; col++) {
            if (byte & (0x80 >> col)) {
                fb_draw_pixel(fb, x + col, y + row, color);
            }
        }
    }
}

void fb_draw_string(struct limine_framebuffer *fb, const char *str, uint32_t x, uint32_t y, uint32_t color) {
    uint32_t orig_x = x;

    if (!psf_validate()) return;

    while (*str) {
        if (*str == '\n') {
            x = orig_x;
            y += 16;
        } else {
            fb_draw_char(fb, *str, x, y, color);
            x += 8;
        }
        str++;
    }
}


================================================================================
 FILE: ./kernel/src/interrupts/idt.c
================================================================================


#include "../../include/interrupts/idt.h"
#include "../../include/interrupts/isr.h"
#include "../../include/interrupts/irq.h"
#include "../../include/io/serial.h"
#include <stddef.h>
#include <string.h>

extern void *interrupts_stub_table[];

__attribute__((
    aligned(0x10))) static idt_entry_t idt_entries[IDT_MAX_DESCRIPTORS];

idtr_t idtr;

void idt_set_gate(uint8_t index, void *base, uint16_t selector, uint8_t flags, uint8_t ist) {
    idt_entries[index].base_low   = (uint64_t)base & 0xFFFF;
    idt_entries[index].kernel_cs  = selector;
    idt_entries[index].ist        = ist;
    idt_entries[index].attributes = flags;
    idt_entries[index].base_mid   = ((uint64_t)base >> 16) & 0xFFFF;
    idt_entries[index].base_high  = ((uint64_t)base >> 32) & 0xFFFFFFFF;
    idt_entries[index].reserved   = 0;
}

void idt_gate_enable(int interrupt) {
    FLAG_SET(idt_entries[interrupt].attributes, IDT_FLAG_PRESENT);
}

void idt_gate_disable(int interrupt) {
    FLAG_UNSET(idt_entries[interrupt].attributes, IDT_FLAG_PRESENT);
}

bool setup_specific_vectors(uint64_t kernel_code_segment, uint64_t vector) {
    if(vector == EXCEPTION_DOUBLE_FAULT) {
        idt_set_gate(vector, interrupts_stub_table[vector], kernel_code_segment, 0x8E, 1);
        return true;
    }

    if(vector == EXCEPTION_NMI) {
        idt_set_gate(vector, interrupts_stub_table[vector], kernel_code_segment, 0x8E, 2);
        return true;
    }

    if(vector == EXCEPTION_PAGE_FAULT) {
        idt_set_gate(vector, interrupts_stub_table[vector], kernel_code_segment, 0x8E, 3);
        return true;
    }

    return false;
}

void idt_load(void) {
    __asm__ volatile("lidt %0" : : "m"(idtr));
}

void setup_interrupt_descriptor_table(uint64_t kernel_code_segment) {
    serial_printf("[IDT] Initializing IDT...\n");

    idtr.base  = (idt_entry_t *)&idt_entries[0];
    idtr.limit = (uint16_t)sizeof(idt_entry_t) * IDT_MAX_DESCRIPTORS - 1;

    for (uint16_t vector = 0; vector < IDT_MAX_DESCRIPTORS; vector++) {

        if(setup_specific_vectors(kernel_code_segment, vector)) {
            continue;
        }

        idt_set_gate(vector, interrupts_stub_table[vector], kernel_code_segment, 0x8E, 0);
    }

    idt_load();

    serial_printf("[IDT] IDT initialized successfully\n");
}



================================================================================
 FILE: ./kernel/src/interrupts/interrupts.c
================================================================================


#include "../../include/interrupts/interrupts.h"
#include "../../include/io/serial.h"
#include "../../include/interrupts/isr.h"
#include "../../include/interrupts/irq.h"
#include "../../include/interrupts/idt.h"
#include "../../include/gdt/gdt.h"
#include "../../include/io/ports.h"

extern const int_desc_t __start_int_handlers[];
extern const int_desc_t __stop_int_handlers[];

void init_interrupt_system(void) {
    asm volatile("cli");

    setup_interrupt_descriptor_table(GDT_CODE_SEGMENT);

    setup_defined_isr_handlers();

    setup_defined_irq_handlers();

    asm volatile("sti");
}

void base_trap(void *ctx) {
    struct int_frame_t *regs = (struct int_frame_t*)ctx;

    if(regs->interrupt < ISR_EXCEPTION_COUNT) {
        return isr_common_handler(regs);
    }

    return irq_common_handler(regs);
}


================================================================================
 FILE: ./kernel/src/interrupts/irq/irq.c
================================================================================


#include "../../../include/interrupts/interrupts.h"
#include "../../../include/io/serial.h"
#include "../../../include/interrupts/irq.h"
#include "../../../include/interrupts/idt.h"
#include "../../../include/io/ports.h"
#include "../../../include/smp/percpu.h"
#include "../../../include/apic/apic.h"

extern const int_desc_t __start_irq_handlers[];
extern const int_desc_t __stop_irq_handlers[];
static int_handler_f registered_irq_interrupts[IRQ_INTERRUPTS_COUNT]__attribute__((aligned(64)));

void irq_common_handler(struct int_frame_t* regs) {
    uint64_t vec = regs->interrupt;

    if (vec >= IRQ_INTERRUPTS_COUNT || vec < (IDT_MAX_DESCRIPTORS - IRQ_INTERRUPTS_COUNT)) {
        serial_printf("IRQ vector out of range: %d\n", vec);
        while (1)
        {
            asm volatile ("hlt");
        }
    }

    if(registered_irq_interrupts[vec]) {
        return registered_irq_interrupts[vec](regs);
    }

    serial_printf("IRQ interrupt handler\n");

    while (1)
    {
        asm volatile ("hlt");
    }
}

void setup_defined_irq_handlers(void) {
    const int_desc_t* desc;
    for (desc = __start_irq_handlers; desc < __stop_irq_handlers; desc++) {
        if(desc->vector >= IRQ_INTERRUPTS_COUNT) {
            serial_printf("Invalid IRQ vector number! Must be < %d\n", IRQ_INTERRUPTS_COUNT);
            continue;
        }
        registered_irq_interrupts[desc->vector] = desc->handler;
        serial_printf("Registered IRQ vector 0x%d\n", desc->vector);
    }
}

extern percpu_t* percpu_regions[MAX_CPUS];

DEFINE_IRQ(IPI_RESCHEDULE_VECTOR, ipi_reschedule_handler)
{
    (void)frame;

    uint32_t id = lapic_get_id();
    if (id < MAX_CPUS && percpu_regions[id] != NULL) {
        percpu_regions[id]->need_resched = true;
    }

    lapic_eoi();
}

DEFINE_IRQ(IPI_TLB_SHOOTDOWN, ipi_tlb_shootdown_handler)
{
    (void)frame;

    uint32_t id = lapic_get_id();
    tlb_shootdown_t* q = &tlb_shootdown_queue[id];

    if (q->pending) {
        for (size_t i = 0; i < q->count; i++) {
            uintptr_t addr = q->addresses[i];
            if (addr != 0) {
                asm volatile ("invlpg (%0)" :: "r"(addr) : "memory");
            }
        }

        q->pending = false;
        q->count = 0;
    }

    lapic_eoi();
}


================================================================================
 FILE: ./kernel/src/interrupts/isr/isr.c
================================================================================


#include "../../../include/interrupts/interrupts.h"
#include "../../../include/io/serial.h"
#include "../../../include/interrupts/isr.h"
#include <stdio.h>

extern const int_desc_t __start_isr_handlers[];
extern const int_desc_t __stop_isr_handlers[];
static int_handler_f registered_isr_interrupts[ISR_EXCEPTION_COUNT]__attribute__((aligned(64)));

void registers_dump(struct int_frame_t *regs) {
    serial_printf("\nRegisters Dump:\n");
    serial_printf("\tRAX:0x%x\n\tRBX:0x%x\n\tRCX:0x%x\n\tRDX:0x%x\n", regs->rax, regs->rbx, regs->rcx, regs->rdx);
    serial_printf("\tRSI:0x%x\n\tRDI:0x%x\n\tRBP:0x%x\n\tRSP:0x%x\n", regs->rsi, regs->rdi, regs->rbp, regs->rsp);
    serial_printf("\tRIP:0x%x\n\tRFL:0x%x\n\tCS:0x%x\n\tERR:0x%x\n", regs->rip, regs->rflags, regs->cs, regs->error);
    serial_printf("\nInt:%d (%s)\n", regs->interrupt, exception_names[regs->interrupt]);

    printf("\nRegisters Dump:\n");
    printf("\tRAX:0x%x\n\tRBX:0x%x\n\tRCX:0x%x\n\tRDX:0x%x\n", regs->rax, regs->rbx, regs->rcx, regs->rdx);
    printf("\tRSI:0x%x\n\tRDI:0x%x\n\tRBP:0x%x\n\tRSP:0x%x\n", regs->rsi, regs->rdi, regs->rbp, regs->rsp);
    printf("\tRIP:0x%x\n\tRFL:0x%x\n\tCS:0x%x\n\tERR:0x%x\n", regs->rip, regs->rflags, regs->cs, regs->error);
    printf("\nInt:%d (%s)\n", regs->interrupt, exception_names[regs->interrupt]);
}

void handle_intercpu_interrupt(struct int_frame_t* regs) {
    registers_dump(regs);

    switch(regs->interrupt) {
        case EXCEPTION_DIVIDE_ERROR:
        case EXCEPTION_OVERFLOW:
        case EXCEPTION_BOUND_RANGE:
        case EXCEPTION_INVALID_OPCODE:
        case EXCEPTION_DEVICE_NOT_AVAILABLE:
        case EXCEPTION_X87_FPU_ERROR:
            return;

        case EXCEPTION_DOUBLE_FAULT:
        case EXCEPTION_INVALID_TSS:
        case EXCEPTION_SEGMENT_NOT_PRESENT:
        case EXCEPTION_STACK_SEGMENT_FAULT:
        case EXCEPTION_GENERAL_PROTECTION_FAULT:
        case EXCEPTION_PAGE_FAULT:
        case EXCEPTION_MACHINE_CHECK:
            serial_printf("CRITICAL: System halted\n");
            printf("CRITICAL: System halted\n");
            while (1) asm volatile ("hlt");

        default:
            serial_printf("UNKNOWN EXCEPTION: System halted\n");
            printf("UNKNOWN EXCEPTION: System halted\n");
            while (1) asm volatile ("hlt");
    }
}

DEFINE_ISR(0x3, isr_breakpoint) {
    (void)frame;
    serial_printf("Breakpoint hit\n");
    printf("Breakpoint hit\n");
}

void isr_common_handler(struct int_frame_t* regs) {
    uint64_t vec = regs->interrupt;

    if (vec >= ISR_EXCEPTION_COUNT) {
        serial_printf("Invalid ISR vector %d\n", vec);
        while (1) asm volatile ("hlt");
    }

    if(registered_isr_interrupts[vec]) {
        registered_isr_interrupts[vec](regs);
        return;
    }

    serial_printf("ISR %d (%s) - No custom handler\n", vec, exception_names[vec]);
    printf("ISR %d (%s) - No custom handler\n", vec, exception_names[vec]);
    handle_intercpu_interrupt(regs);
}

void setup_defined_isr_handlers(void) {
    const int_desc_t* desc;
    for (desc = __start_isr_handlers; desc < __stop_isr_handlers; desc++) {
        if(desc->vector >= ISR_EXCEPTION_COUNT) {
            serial_printf("Invalid ISR vector %d\n", desc->vector);
            continue;
        }
        registered_isr_interrupts[desc->vector] = desc->handler;
        serial_printf("ISR: Registered vector %d\n", desc->vector);
    }
}


================================================================================
 FILE: ./kernel/src/io/serial.c
================================================================================


#include <stdarg.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include "../../include/io/ports.h"
#include "../../include/io/serial.h"

static volatile uint8_t serial_lock = 0;
static uint16_t default_serial_port = 0;

void serial_initialize(uint16_t port, uint32_t baud_rate) {
    outb(port + 1, 0x00);

    uint16_t divisor = 115200 / baud_rate;
    outb(port + 3, 0x80);
    outb(port + 0, divisor & 0xFF);
    outb(port + 1, (divisor >> 8) & 0xFF);

    outb(port + 3, 0x03);
    outb(port + 2, 0xC7);
    outb(port + 4, 0x0B);
    outb(port + 4, 0x1E);
    outb(port + 0, 0xAE);

    if (inb(port + 0) != 0xAE) {
        return;
    }

    outb(port + 4, 0x0F);

    default_serial_port = port;
}

uint16_t serial_get_default_port(void) {
    return default_serial_port;
}

void serial_set_default_port(uint16_t port) {
    default_serial_port = port;
}

int serial_received_port(uint16_t port) {
    return inb(port + 5) & 1;
}

int serial_received(void) {
    if (default_serial_port == 0) return 0;
    return serial_received_port(default_serial_port);
}

char serial_read_port(uint16_t port) {
    while (serial_received_port(port) == 0);
    return inb(port);
}

char serial_read(void) {
    if (default_serial_port == 0) return 0;
    return serial_read_port(default_serial_port);
}

int serial_is_transmit_empty_port(uint16_t port) {
    return inb(port + 5) & 0x20;
}

int serial_is_transmit_empty(void) {
    if (default_serial_port == 0) return 1;
    return serial_is_transmit_empty_port(default_serial_port);
}

void serial_write_port(uint16_t port, char c) {
    while (serial_is_transmit_empty_port(port) == 0);
    outb(port, c);
}

void serial_write(char c) {
    if (default_serial_port == 0) return;
    serial_write_port(default_serial_port, c);
}

void serial_writestring_port(uint16_t port, const char* str) {
    while (*str) {
        serial_write_port(port, *str++);
    }
}

void serial_writestring(const char* str) {
    if (default_serial_port == 0) return;
    serial_writestring_port(default_serial_port, str);
}

static void reverse_string(char* str, int length) {
    int start = 0;
    int end = length - 1;
    while (start < end) {
        char temp = str[start];
        str[start] = str[end];
        str[end] = temp;
        start++;
        end--;
    }
}

static void uint_to_str(uint64_t value, char* buffer, int base, bool uppercase) {
    char* ptr = buffer;

    if (base < 2 || base > 36) {
        *ptr = '\0';
        return;
    }

    const char* digits = uppercase ? "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" :
                                     "0123456789abcdefghijklmnopqrstuvwxyz";

    if (value == 0) {
        *ptr++ = '0';
        *ptr = '\0';
        return;
    }

    while (value > 0) {
        int digit = value % base;
        *ptr++ = digits[digit];
        value /= base;
    }

    *ptr = '\0';
    reverse_string(buffer, ptr - buffer);
}

static void int_to_str(int64_t value, char* buffer, int base, bool uppercase) {
    if (value < 0 && (base == 10 || base == 8)) {
        buffer[0] = '-';
        uint_to_str(-value, buffer + 1, base, uppercase);
    } else {
        uint_to_str(value, buffer, base, uppercase);
    }
}

static uint64_t pow10_u64(int n) {
    uint64_t r = 1;
    while (n-- > 0) r *= 10;
    return r;
}

static int double_to_string(double value, char* buffer, int precision) {
    if (isnan(value)) {
        strcpy(buffer, "nan");
        return 3;
    }

    if (isinf(value)) {
        if (value < 0) {
            strcpy(buffer, "-inf");
            return 4;
        } else {
            strcpy(buffer, "inf");
            return 3;
        }
    }

    if (precision < 0) precision = 6;
    if (precision > 16) precision = 16;

    bool negative = (value < 0);
    double abs_val = negative ? -value : value;

    uint64_t mult = pow10_u64(precision);
    double scaled = abs_val * mult + 0.5;
    uint64_t int_scaled = (uint64_t)scaled;

    uint64_t int_part = int_scaled / mult;
    uint64_t frac_part = int_scaled % mult;

    char* ptr = buffer;
    if (negative) *ptr++ = '-';

    char int_buf[32];
    char* p = int_buf + sizeof(int_buf) - 1;
    *p = '\0';

    if (int_part == 0) {
        *--p = '0';
    } else {
        uint64_t n = int_part;
        while (n > 0) {
            *--p = '0' + (n % 10);
            n /= 10;
        }
    }

    size_t int_len = (int_buf + sizeof(int_buf) - 1) - p;
    memcpy(ptr, p, int_len);
    ptr += int_len;

    if (precision > 0) {
        *ptr++ = '.';

        char frac_buf[32];
        char* f = frac_buf + sizeof(frac_buf) - 1;
        *f = '\0';

        if (frac_part == 0) {
            for (int i = 0; i < precision; i++) {
                *--f = '0';
            }
        } else {
            uint64_t n = frac_part;
            int count = 0;
            while (n > 0) {
                *--f = '0' + (n % 10);
                n /= 10;
                count++;
            }
            while (count < precision) {
                *--f = '0';
                count++;
            }
        }

        size_t frac_len = (frac_buf + sizeof(frac_buf) - 1) - f;
        memcpy(ptr, f, frac_len);
        ptr += frac_len;
    }

    *ptr = '\0';
    return ptr - buffer;
}

static int double_to_scientific(double value, char* buffer, int precision, bool uppercase) {
    if (isnan(value)) {
        strcpy(buffer, "nan");
        return 3;
    }

    if (isinf(value)) {
        if (value < 0) {
            strcpy(buffer, "-inf");
            return 4;
        } else {
            strcpy(buffer, "inf");
            return 3;
        }
    }

    if (value == 0.0) {
        if (precision < 0) precision = 6;
        buffer[0] = '0';
        buffer[1] = '.';
        for (int i = 0; i < precision; i++) {
            buffer[2 + i] = '0';
        }
        buffer[2 + precision] = uppercase ? 'E' : 'e';
        buffer[3 + precision] = '+';
        buffer[4 + precision] = '0';
        buffer[5 + precision] = '0';
        buffer[6 + precision] = '\0';
        return 6 + precision;
    }

    if (precision < 0) precision = 6;
    if (precision > 16) precision = 16;

    double abs_val = value < 0 ? -value : value;
    int exponent = 0;

    if (abs_val >= 10.0) {
        while (abs_val >= 10.0) {
            abs_val /= 10.0;
            exponent++;
        }
    } else if (abs_val < 1.0 && abs_val > 0.0) {
        while (abs_val < 1.0) {
            abs_val *= 10.0;
            exponent--;
        }
    }

    if (value < 0) abs_val = -abs_val;

    int len = double_to_string(abs_val, buffer, precision);

    char e_char = uppercase ? 'E' : 'e';
    buffer[len++] = e_char;

    if (exponent >= 0) {
        buffer[len++] = '+';
    } else {
        buffer[len++] = '-';
        exponent = -exponent;
    }

    if (exponent < 10) {
        buffer[len++] = '0';
        buffer[len++] = '0' + exponent;
    } else {
        buffer[len++] = '0' + (exponent / 10);
        buffer[len++] = '0' + (exponent % 10);
    }

    buffer[len] = '\0';
    return len;
}

static int double_to_general(double value, char* buffer, int precision, bool uppercase) {
    double abs_val = value < 0 ? -value : value;

    if (abs_val == 0.0) {
        strcpy(buffer, "0");
        return 1;
    }

    if (precision < 0) precision = 6;
    if (precision == 0) precision = 1;

    bool use_scientific = (abs_val >= 1e6 || (abs_val < 1e-4 && abs_val > 0));

    if (use_scientific) {
        return double_to_scientific(value, buffer, precision - 1, uppercase);
    }

    int digits_before = 0;
    double temp = abs_val;
    while (temp >= 1.0) {
        temp /= 10.0;
        digits_before++;
    }
    if (digits_before == 0) digits_before = 1;

    int decimal_places = precision - digits_before;
    if (decimal_places < 0) decimal_places = 0;

    return double_to_string(value, buffer, decimal_places);
}

void serial_printf_port(uint16_t port, const char* format, ...) {
    while (__sync_lock_test_and_set(&serial_lock, 1)) {
        __asm__ volatile("pause" ::: "memory");
    }

    va_list args;
    va_start(args, format);

    char buffer[256];
    const char* ptr = format;

    while (*ptr) {
        if (*ptr != '%') {
            serial_write_port(port, *ptr);
            ptr++;
            continue;
        }

        const char* percent_start = ptr++;

        while (*ptr == '0' || *ptr == '-' || *ptr == '+' || *ptr == ' ' || *ptr == '#') {
            ptr++;
        }

        int width = 0;
        while (*ptr >= '0' && *ptr <= '9') {
            width = width * 10 + (*ptr - '0');
            ptr++;
        }

        int precision = -1;
        if (*ptr == '.') {
            ptr++;
            precision = 0;
            while (*ptr >= '0' && *ptr <= '9') {
                precision = precision * 10 + (*ptr - '0');
                ptr++;
            }
        }

        bool has_ll = false;
        bool has_l = false;
        bool has_size_t = false;

        if (*ptr == 'z') {
            ptr++;
            has_size_t = true;
        } else if (*ptr == 'l') {
            ptr++;
            if (*ptr == 'l') {
                ptr++;
                has_ll = true;
            } else {
                has_l = true;
            }
        } else if (*ptr == 'h') {
            ptr++;
            if (*ptr == 'h') ptr++;
        } else if (*ptr == 'L' || *ptr == 'j' || *ptr == 't') {
            ptr++;
        }

        switch (*ptr) {
            case 'c': {
                char c = (char)va_arg(args, int);
                serial_write_port(port, c);
                break;
            }

            case 's': {
                const char* str = va_arg(args, const char*);
                if (!str) {
                    str = "(null)";
                }
                serial_writestring_port(port, str);
                break;
            }

            case 'd':
            case 'i': {
                int64_t num;
                if (has_size_t) {
                    num = (int64_t)va_arg(args, size_t);
                } else if (has_ll) {
                    num = va_arg(args, int64_t);
                } else if (has_l) {
                    num = (int64_t)va_arg(args, long);
                } else {
                    num = (int64_t)va_arg(args, int);
                }
                int_to_str(num, buffer, 10, false);
                serial_writestring_port(port, buffer);
                break;
            }

            case 'u': {
                uint64_t num;
                if (has_size_t) {
                    num = (uint64_t)va_arg(args, size_t);
                } else if (has_ll) {
                    num = va_arg(args, uint64_t);
                } else if (has_l) {
                    num = (uint64_t)va_arg(args, unsigned long);
                } else {
                    num = (uint64_t)va_arg(args, unsigned int);
                }
                uint_to_str(num, buffer, 10, false);
                serial_writestring_port(port, buffer);
                break;
            }

            case 'x': {
                uint64_t num;
                if (has_size_t) {
                    num = (uint64_t)va_arg(args, size_t);
                } else if (has_ll) {
                    num = va_arg(args, uint64_t);
                } else if (has_l) {
                    num = (uint64_t)va_arg(args, unsigned long);
                } else {
                    num = (uint64_t)va_arg(args, unsigned int);
                }
                uint_to_str(num, buffer, 16, false);
                serial_writestring_port(port, buffer);
                break;
            }

            case 'X': {
                uint64_t num;
                if (has_size_t) {
                    num = (uint64_t)va_arg(args, size_t);
                } else if (has_ll) {
                    num = va_arg(args, uint64_t);
                } else if (has_l) {
                    num = (uint64_t)va_arg(args, unsigned long);
                } else {
                    num = (uint64_t)va_arg(args, unsigned int);
                }
                uint_to_str(num, buffer, 16, true);
                serial_writestring_port(port, buffer);
                break;
            }

            case 'o': {
                uint64_t num;
                if (has_size_t) {
                    num = (uint64_t)va_arg(args, size_t);
                } else if (has_ll) {
                    num = va_arg(args, uint64_t);
                } else if (has_l) {
                    num = (uint64_t)va_arg(args, unsigned long);
                } else {
                    num = (uint64_t)va_arg(args, unsigned int);
                }
                uint_to_str(num, buffer, 8, false);
                serial_writestring_port(port, buffer);
                break;
            }

            case 'p': {
                void* ptr_val = va_arg(args, void*);
                serial_writestring_port(port, "0x");
                uint_to_str((uintptr_t)ptr_val, buffer, 16, false);
                serial_writestring_port(port, buffer);
                break;
            }

            case 'f':
            case 'F': {
                double num = va_arg(args, double);
                double_to_string(num, buffer, precision);
                serial_writestring_port(port, buffer);
                break;
            }

            case 'e':
            case 'E': {
                double num = va_arg(args, double);
                double_to_scientific(num, buffer, precision, (*ptr == 'E'));
                serial_writestring_port(port, buffer);
                break;
            }

            case 'g':
            case 'G': {
                double num = va_arg(args, double);
                double_to_general(num, buffer, precision, (*ptr == 'G'));
                serial_writestring_port(port, buffer);
                break;
            }

            case 'a':
            case 'A': {
                double num = va_arg(args, double);
                double_to_scientific(num, buffer, precision, (*ptr == 'A'));
                buffer[0] = '0';
                buffer[1] = 'x';
                serial_writestring_port(port, buffer);
                break;
            }

            case 'n': {
                int* count_ptr = va_arg(args, int*);
                *count_ptr = 0;
                break;
            }

            case '%': {
                serial_write_port(port, '%');
                break;
            }

            default: {
                for (const char* p = percent_start; p <= ptr; p++) {
                    serial_write_port(port, *p);
                }
                break;
            }
        }

        if (*ptr != '\0') {
            ptr++;
        }
    }

    va_end(args);
    __sync_lock_release(&serial_lock);
}

void serial_printf(const char* format, ...) {
    if (default_serial_port == 0) return;

    while (__sync_lock_test_and_set(&serial_lock, 1)) {
        __asm__ volatile("pause" ::: "memory");
    }

    va_list args;
    va_start(args, format);

    char buffer[256];
    const char* ptr = format;

    while (*ptr) {
        if (*ptr != '%') {
            serial_write_port(default_serial_port, *ptr);
            ptr++;
            continue;
        }

        const char* percent_start = ptr++;

        while (*ptr == '0' || *ptr == '-' || *ptr == '+' || *ptr == ' ' || *ptr == '#') {
            ptr++;
        }

        int width = 0;
        while (*ptr >= '0' && *ptr <= '9') {
            width = width * 10 + (*ptr - '0');
            ptr++;
        }

        int precision = -1;
        if (*ptr == '.') {
            ptr++;
            precision = 0;
            while (*ptr >= '0' && *ptr <= '9') {
                precision = precision * 10 + (*ptr - '0');
                ptr++;
            }
        }

        bool has_ll = false;
        bool has_l = false;
        bool has_size_t = false;

        if (*ptr == 'z') {
            ptr++;
            has_size_t = true;
        } else if (*ptr == 'l') {
            ptr++;
            if (*ptr == 'l') {
                ptr++;
                has_ll = true;
            } else {
                has_l = true;
            }
        } else if (*ptr == 'h') {
            ptr++;
            if (*ptr == 'h') ptr++;
        } else if (*ptr == 'L' || *ptr == 'j' || *ptr == 't') {
            ptr++;
        }

        switch (*ptr) {
            case 'c': {
                char c = (char)va_arg(args, int);
                serial_write_port(default_serial_port, c);
                break;
            }

            case 's': {
                const char* str = va_arg(args, const char*);
                if (!str) {
                    str = "(null)";
                }
                serial_writestring_port(default_serial_port, str);
                break;
            }

            case 'd':
            case 'i': {
                int64_t num;
                if (has_size_t) {
                    num = (int64_t)va_arg(args, size_t);
                } else if (has_ll) {
                    num = va_arg(args, int64_t);
                } else if (has_l) {
                    num = (int64_t)va_arg(args, long);
                } else {
                    num = (int64_t)va_arg(args, int);
                }
                int_to_str(num, buffer, 10, false);
                serial_writestring_port(default_serial_port, buffer);
                break;
            }

            case 'u': {
                uint64_t num;
                if (has_size_t) {
                    num = (uint64_t)va_arg(args, size_t);
                } else if (has_ll) {
                    num = va_arg(args, uint64_t);
                } else if (has_l) {
                    num = (uint64_t)va_arg(args, unsigned long);
                } else {
                    num = (uint64_t)va_arg(args, unsigned int);
                }
                uint_to_str(num, buffer, 10, false);
                serial_writestring_port(default_serial_port, buffer);
                break;
            }

            case 'x': {
                uint64_t num;
                if (has_size_t) {
                    num = (uint64_t)va_arg(args, size_t);
                } else if (has_ll) {
                    num = va_arg(args, uint64_t);
                } else if (has_l) {
                    num = (uint64_t)va_arg(args, unsigned long);
                } else {
                    num = (uint64_t)va_arg(args, unsigned int);
                }
                uint_to_str(num, buffer, 16, false);
                serial_writestring_port(default_serial_port, buffer);
                break;
            }

            case 'X': {
                uint64_t num;
                if (has_size_t) {
                    num = (uint64_t)va_arg(args, size_t);
                } else if (has_ll) {
                    num = va_arg(args, uint64_t);
                } else if (has_l) {
                    num = (uint64_t)va_arg(args, unsigned long);
                } else {
                    num = (uint64_t)va_arg(args, unsigned int);
                }
                uint_to_str(num, buffer, 16, true);
                serial_writestring_port(default_serial_port, buffer);
                break;
            }

            case 'o': {
                uint64_t num;
                if (has_size_t) {
                    num = (uint64_t)va_arg(args, size_t);
                } else if (has_ll) {
                    num = va_arg(args, uint64_t);
                } else if (has_l) {
                    num = (uint64_t)va_arg(args, unsigned long);
                } else {
                    num = (uint64_t)va_arg(args, unsigned int);
                }
                uint_to_str(num, buffer, 8, false);
                serial_writestring_port(default_serial_port, buffer);
                break;
            }

            case 'p': {
                void* ptr_val = va_arg(args, void*);
                serial_writestring_port(default_serial_port, "0x");
                uint_to_str((uintptr_t)ptr_val, buffer, 16, false);
                serial_writestring_port(default_serial_port, buffer);
                break;
            }

            case 'f':
            case 'F': {
                double num = va_arg(args, double);
                double_to_string(num, buffer, precision);
                serial_writestring_port(default_serial_port, buffer);
                break;
            }

            case 'e':
            case 'E': {
                double num = va_arg(args, double);
                double_to_scientific(num, buffer, precision, (*ptr == 'E'));
                serial_writestring_port(default_serial_port, buffer);
                break;
            }

            case 'g':
            case 'G': {
                double num = va_arg(args, double);
                double_to_general(num, buffer, precision, (*ptr == 'G'));
                serial_writestring_port(default_serial_port, buffer);
                break;
            }

            case 'a':
            case 'A': {
                double num = va_arg(args, double);
                double_to_scientific(num, buffer, precision, (*ptr == 'A'));
                buffer[0] = '0';
                buffer[1] = 'x';
                serial_writestring_port(default_serial_port, buffer);
                break;
            }

            case 'n': {
                int* count_ptr = va_arg(args, int*);
                *count_ptr = 0;
                break;
            }

            case '%': {
                serial_write_port(default_serial_port, '%');
                break;
            }

            default: {
                for (const char* p = percent_start; p <= ptr; p++) {
                    serial_write_port(default_serial_port, *p);
                }
                break;
            }
        }

        if (*ptr != '\0') {
            ptr++;
        }
    }

    va_end(args);
    __sync_lock_release(&serial_lock);
}


================================================================================
 FILE: ./kernel/src/kernel.c
================================================================================


#include <stdint.h>
#include <string.h>
#include <stddef.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <limine.h>
#include "../include/graphics/fb/fb.h"
#include "../include/io/serial.h"
#include "../include/gdt/gdt.h"
#include "../include/interrupts/interrupts.h"
#include "../include/interrupts/idt.h"
#include "../include/sse/fpu.h"
#include "../include/sse/sse.h"
#include "../include/memory/pmm.h"
#include "../include/memory/vmm.h"
#include "../include/memory/paging.h"
#include "../include/acpi/acpi.h"
#include "../include/apic/apic.h"
#include "../include/io/ports.h"
#include "../include/drivers/timer.h"
#include "../include/smp/smp.h"
#include "../include/smp/percpu.h"
#include "../include/sched/sched.h"
#include "../include/elf/elf.h"

__attribute__((used, section(".limine_requests")))
static volatile uint64_t limine_base_revision[] = LIMINE_BASE_REVISION(4);

__attribute__((used, section(".limine_requests")))
static volatile struct limine_framebuffer_request framebuffer_request = {
    .id = LIMINE_FRAMEBUFFER_REQUEST_ID,
    .revision = 0
};

__attribute__((used, section(".limine_requests")))
static volatile struct limine_memmap_request memmap_request = {
    .id = LIMINE_MEMMAP_REQUEST_ID,
    .revision = 0
};

__attribute__((used, section(".limine_requests")))
static volatile struct limine_mp_request mp_request = {
    .id = LIMINE_MP_REQUEST_ID,
    .revision = 0,
    .flags = 0
};

__attribute__((used, section(".limine_requests")))
static volatile struct limine_hhdm_request hhdm_request = {
    .id = LIMINE_HHDM_REQUEST_ID,
    .revision = 0
};

__attribute__((used, section(".limine_requests")))
volatile struct limine_rsdp_request rsdp_request = {
    .id = LIMINE_RSDP_REQUEST_ID,
    .revision = 0,
    .response = NULL
};

__attribute__((used, section(".limine_requests")))
static volatile struct limine_module_request module_request = {
    .id = LIMINE_MODULE_REQUEST_ID,
    .revision = 0
};

__attribute__((used, section(".limine_requests_start")))
static volatile uint64_t limine_requests_start_marker[] = LIMINE_REQUESTS_START_MARKER;

__attribute__((used, section(".limine_requests_end")))
static volatile uint64_t limine_requests_end_marker[] = LIMINE_REQUESTS_END_MARKER;

struct limine_framebuffer *global_framebuffer = NULL;

static void hcf(void) {
    for (;;) {
        asm ("hlt");
    }
}

static void load_elf_module(void) {
    if (!module_request.response) {
        serial_writestring("[ELF] No module response from Limine\n");
        return;
    }
    if (module_request.response->module_count == 0) {
        serial_writestring("[ELF] No modules provided\n");
        return;
    }

    struct limine_file* mod = module_request.response->modules[0];
    serial_printf("[ELF] Module: path='%s' size=%llu addr=%p\n",
                  mod->path, mod->size, mod->address);

    elf_load_result_t r = elf_load(mod->address, (size_t)mod->size, 0);

    if (r.error != ELF_OK) {
        serial_printf("[ELF] LOAD FAILED: %s\n", elf_strerror(r.error));
        printf("[ELF] Failed to load: %s\n", elf_strerror(r.error));
        return;
    }

    serial_printf("[ELF] Load OK! entry=0x%llx stack_top=0x%llx\n",
                  r.entry, r.stack_top);
    printf("[ELF] Loaded! entry=0x%llx\n", r.entry);

    task_t* t = task_create("hello.elf",
                            (void (*)(void*))r.entry,
                            NULL,
                            16);

    if (!t) {
        serial_writestring("[ELF] task_create failed\n");
        elf_unload(&r);
        return;
    }

    t->cr3 = (uint64_t)pmm_virt_to_phys(r.pagemap->pml4);

    serial_printf("[ELF] Task 'hello.elf' created: cr3=0x%llx rsp=0x%llx\n",
                  t->cr3, t->rsp);
    printf("[ELF] Task 'hello.elf' scheduled!\n");
}


void exit_test_task(void* arg) {
    (void)arg;
    asm volatile ("sti");

    serial_printf("[ExitTest] Started — will exit after 3 iterations\n");

    for (int i = 1; i <= 3; i++) {
        serial_printf("[ExitTest] Iteration %d/3\n", i);
        for (volatile uint64_t spin = 0; spin < 5000000; spin++)
            asm volatile ("pause");
    }

    serial_printf("[ExitTest] Done — calling task_exit() now\n");
    printf("[ExitTest] Exiting cleanly!\n");
}

static task_t* victim_task_ptr = NULL;

void victim_task(void* arg) {
    (void)arg;
    asm volatile ("sti");

    serial_printf("[Victim] Started — waiting to be killed\n");

    uint64_t counter = 0;
    while (1) {
        counter++;
        if (counter % 2000000 == 0) {
            serial_printf("[Victim] Still alive, counter=%llu\n", counter);
            printf("[Victim] alive %llu\n", counter / 1000000);
        }
    }
}

void killer_task(void* arg) {
    (void)arg;
    asm volatile ("sti");

    serial_printf("[Killer] Started — will kill Victim after delay\n");

    for (volatile uint64_t spin = 0; spin < 20000000; spin++)
        asm volatile ("pause");

    if (victim_task_ptr) {
        serial_printf("[Killer] Sending kill to Victim task @ %p\n",
                      (void*)victim_task_ptr);
        printf("[Killer] Killing Victim now!\n");
        task_kill(victim_task_ptr);

        for (volatile uint64_t spin = 0; spin < 5000000; spin++)
            asm volatile ("pause");

        serial_printf("[Killer] Victim should be dead now. Freeing resources.\n");
        task_destroy(victim_task_ptr);
        victim_task_ptr = NULL;

        serial_printf("[Killer] Done — returning from killer_task\n");
        printf("[Killer] Done!\n");
    } else {
        serial_printf("[Killer] ERROR: victim_task_ptr is NULL!\n");
    }
}

void tlb_test_task(void* arg) {
    (void)arg;
    asm volatile ("sti");

    serial_printf("[TLBTest] Starting map/unmap stress test\n");

    vmm_pagemap_t* kmap = vmm_get_kernel_pagemap();

    void* phys_page = pmm_alloc(1);
    if (!phys_page) {
        serial_printf("[TLBTest] ERROR: pmm_alloc failed\n");
        return;
    }

    uintptr_t test_virt = 0xFFFF900000000000ULL;

    for (int round = 1; round <= 5; round++) {
        vmm_map_page(kmap, test_virt,
                     (uintptr_t)pmm_virt_to_phys(phys_page),
                     VMM_PRESENT | VMM_WRITE | VMM_GLOBAL);

        volatile uint64_t* ptr = (volatile uint64_t*)test_virt;
        *ptr = (uint64_t)round * 0xDEADBEEF;

        uint64_t readback = *ptr;
        if (readback == (uint64_t)round * 0xDEADBEEF) {
            serial_printf("[TLBTest] Round %d: write/read OK (0x%llx)\n",
                          round, readback);
        } else {
            serial_printf("[TLBTest] Round %d: MISMATCH! wrote 0x%llx, got 0x%llx\n",
                          round, (uint64_t)round * 0xDEADBEEF, readback);
        }

        vmm_unmap_page(kmap, test_virt);
        serial_printf("[TLBTest] Round %d: unmap + TLB shootdown OK\n", round);

        for (volatile uint64_t spin = 0; spin < 1000000; spin++)
            asm volatile ("pause");
    }

    pmm_free(phys_page, 1);
    serial_printf("[TLBTest] All rounds passed — TLB flush working correctly\n");
    printf("[TLBTest] PASSED!\n");
}

void high_priority_task(void* arg) {
    (void)arg;
    asm volatile ("sti");
    serial_printf("[HighPri] Started with interrupts enabled!\n");
    uint64_t counter = 0;
    while (1) {
        counter++;
        if (counter % 5000000 == 0) {
            serial_printf("[HighPri] counter=%llu\n", counter);
            printf("[HighPri] %llu\n", counter / 1000000);
        }
    }
}

void low_priority_task(void* arg) {
    (void)arg;
    asm volatile ("sti");
    serial_printf("[LowPri] Started with interrupts enabled!\n");
    uint64_t counter = 0;
    while (1) {
        counter++;
        if (counter % 3000000 == 0) {
            serial_printf("[LowPri] counter=%llu\n", counter);
            printf("[LowPri] %llu\n", counter / 1000000);
        }
    }
}

void fpu_test_task(void* arg) {
    (void)arg;
    asm volatile ("and $-16, %%rsp" ::: "memory");
    asm volatile ("sti");
    serial_printf("[FPU] Testing FPU operations...\n");
    volatile double a = 1.0, b = 2.0, c;
    c = a + b; serial_printf("[FPU] 1.0 + 2.0 = %e\n", c);
    c = a * b; serial_printf("[FPU] 1.0 * 2.0 = %e\n", c);
    serial_printf("[FPU] Tests PASSED! Running continuous...\n");
    volatile double x = 1.0;
    uint64_t iter = 0;
    while (1) {
        x = x * 1.1;
        iter++;
        if (iter % 10000000 == 0)
            serial_printf("[FPU] %llu million operations\n", iter / 1000000);
    }
}

void kernel_main(void) {
    serial_initialize(COM1, 115200);
    serial_writestring("\n=== SERIAL PORT INITIALIZED ===\n");
    serial_writestring("Cervus OS v0.0.1 - Kernel initialized!\n");

    if (LIMINE_BASE_REVISION_SUPPORTED(limine_base_revision) == false) {
        serial_writestring("ERROR: Unsupported Limine base revision\n");
        hcf();
    }

    gdt_init();
    init_interrupt_system();
    serial_writestring("GDT&IDT [OK]\n");
    fpu_init();
    sse_init();
    enable_fsgsbase();
    serial_writestring("FSGSBASE [OK]\n");
    serial_writestring("FPU/SSE [OK]\n");

    if (!framebuffer_request.response ||
        framebuffer_request.response->framebuffer_count < 1) {
        serial_writestring("ERROR: No framebuffer available\n");
        hcf();
    }
    if (!memmap_request.response) {
        serial_writestring("ERROR: No memory map available\n");
        hcf();
    }
    if (!hhdm_request.response) {
        serial_writestring("ERROR: No HHDM available\n");
        hcf();
    }

    global_framebuffer = framebuffer_request.response->framebuffers[0];

    pmm_init(memmap_request.response, hhdm_request.response);
    serial_writestring("PMM [OK]\n");
    paging_init();
    serial_writestring("Paging [OK]\n");
    vmm_init();
    serial_writestring("VMM [OK]\n");
    malloc_init();
    acpi_init();
    acpi_print_tables();
    serial_writestring("ACPI [OK]\n");
    apic_init();
    serial_writestring("APIC [OK]\n");
    clear_screen();
    smp_init(mp_request.response);
    serial_writestring("SMP [OK]\n");

    serial_writestring("Waiting until all APs are fully ready...\n");
    while (smp_get_online_count() < (smp_get_cpu_count() - 1)) {
        timer_sleep_ms(100);
    }
    serial_writestring("All APs ready.\n");

    printf("\n\tCERVUS OS v0.0.1\n");
    printf("Kernel initialized successfully!\n\n");
    printf("Framebuffer: %dx%d, %d bpp\n",
           global_framebuffer->width,
           global_framebuffer->height,
           global_framebuffer->bpp);
    printf("\nMemory Information:\n");
    printf("HHDM offset: 0x%llx\n", hhdm_request.response->offset);
    printf("Memory map entries: %llu\n", memmap_request.response->entry_count);
    print_simd_cpuid();
    pmm_print_stats();

    printf("\nSystem ready. Entering idle loop...\n");
    serial_writestring("\nSystem ready. Entering idle loop...\n");

    smp_print_info_fb();
    printf("\nSystem: %u CPU cores detected\n", smp_get_cpu_count());

    sched_init();
    sched_notify_ready();

    load_elf_module();

    //task_create("ExitTest", exit_test_task, NULL, 20);

    //victim_task_ptr = task_create("Victim", victim_task, NULL, 15);
    //task_create("Killer", killer_task, NULL, 18);

    //task_create("TLBTest", tlb_test_task, NULL, 12);

    //task_create("HighPri",     high_priority_task, NULL, 25);
    //task_create("LowPri",      low_priority_task,  NULL, 10);
    //task_create("FPUTESTTASK", fpu_test_task,       NULL,  1);

    timer_init();

    printf("Tasks switching automatically every ~10ms\n\n");
    serial_writestring("Manually triggering first reschedule...\n");
    sched_reschedule();

    serial_writestring("\n=== All tasks completed ===\n");
    serial_writestring("System will continue running tasks...\n");
    printf("\nSystem will continue running tasks...\n");
    while (1) {
        hcf();
    }
}


================================================================================
 FILE: ./kernel/src/memory/paging.c
================================================================================


#include "../../include/memory/paging.h"
#include "../../include/memory/pmm.h"
#include "../../include/io/serial.h"
#include <string.h>
#include <stdio.h>

#define MAX_REGIONS 256
#define MAX_RESERVED 64
#define DEFAULT_ALLOC_BASE 0xFFFFFE0000000000ULL

static paging_region_t regions[MAX_REGIONS];
static size_t region_count = 0;

static struct {
    uintptr_t start;
    uintptr_t end;
} reserved_ranges[MAX_RESERVED];
static size_t reserved_count = 0;

static uintptr_t next_alloc_virt = DEFAULT_ALLOC_BASE;

static inline uintptr_t align_up(uintptr_t addr, size_t alignment) {
    return (addr + alignment - 1) & ~(alignment - 1);
}

static inline bool is_aligned(uintptr_t addr, size_t alignment) {
    return (addr & (alignment - 1)) == 0;
}

static inline bool ranges_overlap(uintptr_t s1, uintptr_t e1, uintptr_t s2, uintptr_t e2) {
    return s1 < e2 && s2 < e1;
}

void paging_init(void) {
    memset(regions, 0, sizeof(regions));
    memset(reserved_ranges, 0, sizeof(reserved_ranges));
    region_count = 0;
    reserved_count = 0;
    next_alloc_virt = DEFAULT_ALLOC_BASE;

    paging_reserve_range(vmm_get_kernel_pagemap(),
                         0xFFFFFFFF80000000ULL,
                         0xFFFFFFFFC0000000ULL);

    serial_printf("Paging: subsystem initialized\n");
}

bool paging_reserve_range(vmm_pagemap_t* pagemap, uintptr_t virt_start, uintptr_t virt_end) {
    (void)pagemap;

    if (reserved_count >= MAX_RESERVED) {
        serial_printf("PAGING ERROR: too many reserved ranges\n");
        return false;
    }

    if (virt_start >= virt_end) {
        serial_printf("PAGING ERROR: invalid reserved range\n");
        return false;
    }

    for (size_t i = 0; i < reserved_count; i++) {
        if (ranges_overlap(virt_start, virt_end,
                          reserved_ranges[i].start,
                          reserved_ranges[i].end)) {
            serial_printf("PAGING ERROR: reserved range overlaps\n");
            return false;
        }
    }

    reserved_ranges[reserved_count].start = virt_start;
    reserved_ranges[reserved_count].end   = virt_end;
    reserved_count++;

    serial_printf("Paging: reserved range 0x%llx-0x%llx\n", virt_start, virt_end);
    return true;
}

static bool is_range_reserved(uintptr_t start, uintptr_t end) {
    for (size_t i = 0; i < reserved_count; i++) {
        if (ranges_overlap(start, end, reserved_ranges[i].start, reserved_ranges[i].end))
            return true;
    }
    return false;
}

bool paging_is_range_free(vmm_pagemap_t* pagemap, uintptr_t virt_start, uintptr_t virt_end) {
    if (is_range_reserved(virt_start, virt_end))
        return false;

    for (uintptr_t virt = virt_start; virt < virt_end; virt += PAGE_SIZE) {
        uintptr_t phys;
        if (vmm_virt_to_phys(pagemap, virt, &phys))
            return false;
    }
    return true;
}

bool paging_map_range(vmm_pagemap_t* pagemap, uintptr_t virt_start,
                     uintptr_t phys_start, size_t page_count, uint64_t flags) {
    if (!pagemap || page_count == 0)
        return false;

    if (!is_aligned(virt_start, PAGE_SIZE) || !is_aligned(phys_start, PAGE_SIZE)) {
        serial_printf("PAGING ERROR: unaligned addresses\n");
        return false;
    }

    uintptr_t virt_end = virt_start + page_count * PAGE_SIZE;
    if (is_range_reserved(virt_start, virt_end)) {
        serial_printf("PAGING ERROR: range overlaps reserved area\n");
        return false;
    }

    for (size_t i = 0; i < page_count; i++) {
        uintptr_t virt = virt_start + i * PAGE_SIZE;
        uintptr_t phys = phys_start + i * PAGE_SIZE;

        uintptr_t existing_phys;
        if (vmm_virt_to_phys(pagemap, virt, &existing_phys)) {
            if (existing_phys != phys) {
                serial_printf("PAGING ERROR: page at 0x%llx already mapped to 0x%llx\n",
                              virt, existing_phys);
                return false;
            }
            uint64_t existing_flags;
            if (vmm_get_page_flags(pagemap, virt, &existing_flags)) {
                if (existing_flags != (flags & 0xFFF)) {
                    vmm_unmap_page(pagemap, virt);
                    vmm_map_page(pagemap, virt, phys, flags);
                }
            }
        } else {
            if (!vmm_map_page(pagemap, virt, phys, flags)) {
                serial_printf("PAGING ERROR: failed to map 0x%llx -> 0x%llx\n", virt, phys);
                for (size_t j = 0; j < i; j++)
                    vmm_unmap_page(pagemap, virt_start + j * PAGE_SIZE);
                return false;
            }
        }
    }
    return true;
}

bool paging_unmap_range(vmm_pagemap_t* pagemap, uintptr_t virt_start, size_t page_count) {
    if (!pagemap || page_count == 0)
        return false;

    for (size_t i = 0; i < page_count; i++)
        vmm_unmap_page(pagemap, virt_start + i * PAGE_SIZE);

    return true;
}

bool paging_change_flags(vmm_pagemap_t* pagemap, uintptr_t virt_start,
                        size_t page_count, uint64_t new_flags) {
    if (!pagemap || page_count == 0)
        return false;

    if (!is_aligned(virt_start, PAGE_SIZE)) {
        serial_printf("PAGING ERROR: unaligned address 0x%llx\n", virt_start);
        return false;
    }

    for (size_t i = 0; i < page_count; i++) {
        uintptr_t virt = virt_start + i * PAGE_SIZE;
        uintptr_t phys;

        if (!vmm_virt_to_phys(pagemap, virt, &phys)) {
            serial_printf("PAGING ERROR: page at 0x%llx not mapped\n", virt);
            return false;
        }

        vmm_unmap_page(pagemap, virt);
        if (!vmm_map_page(pagemap, virt, phys, new_flags)) {
            serial_printf("PAGING ERROR: failed to remap 0x%llx\n", virt);
            return false;
        }
    }
    return true;
}

paging_region_t* paging_create_region(vmm_pagemap_t* pagemap,
                                     uintptr_t virt_start, size_t size,
                                     uint64_t flags) {
    if (region_count >= MAX_REGIONS) {
        serial_printf("PAGING ERROR: too many regions\n");
        return NULL;
    }

    size_t page_count = align_up(size, PAGE_SIZE) / PAGE_SIZE;
    uintptr_t virt_end = virt_start + page_count * PAGE_SIZE;

    if (!paging_is_range_free(pagemap, virt_start, virt_end)) {
        serial_printf("PAGING ERROR: region overlaps existing mapping\n");
        return NULL;
    }

    void* phys_mem = pmm_alloc_zero(page_count);
    if (!phys_mem) {
        serial_printf("PAGING ERROR: out of physical memory\n");
        return NULL;
    }

    uintptr_t phys_start = pmm_virt_to_phys(phys_mem);
    if (!paging_map_range(pagemap, virt_start, phys_start, page_count, flags)) {
        pmm_free(phys_mem, page_count);
        serial_printf("PAGING ERROR: failed to map region\n");
        return NULL;
    }

    paging_region_t* region = &regions[region_count++];
    region->virtual_start = virt_start;
    region->virtual_end = virt_end;
    region->physical_start = phys_start;
    region->flags = flags;
    region->page_count = page_count;
    region->allocated = true;

    serial_printf("Paging: created region 0x%llx-0x%llx (%zu pages)\n",
                  virt_start, virt_end, page_count);
    return region;
}

bool paging_destroy_region(vmm_pagemap_t* pagemap, paging_region_t* region) {
    if (!pagemap || !region || !region->allocated)
        return false;

    paging_unmap_range(pagemap, region->virtual_start, region->page_count);
    void* phys_virt = pmm_phys_to_virt(region->physical_start);
    pmm_free(phys_virt, region->page_count);
    memset(region, 0, sizeof(paging_region_t));
    return true;
}

void* paging_alloc_pages(vmm_pagemap_t* pagemap, size_t page_count,
                        uint64_t flags, uintptr_t preferred_virt) {
    if (!pagemap || page_count == 0)
        return NULL;

    uintptr_t virt_start;
    if (preferred_virt != 0) {
        virt_start = align_up(preferred_virt, PAGE_SIZE);
        if (!paging_is_range_free(pagemap, virt_start, virt_start + page_count * PAGE_SIZE))
            return NULL;
    } else {
        virt_start = next_alloc_virt;
        while (!paging_is_range_free(pagemap, virt_start, virt_start + page_count * PAGE_SIZE))
            virt_start += PAGE_SIZE;
        next_alloc_virt = virt_start + page_count * PAGE_SIZE;
    }

    void* phys_mem = pmm_alloc_zero(page_count);
    if (!phys_mem)
        return NULL;

    uintptr_t phys_start = pmm_virt_to_phys(phys_mem);
    if (!paging_map_range(pagemap, virt_start, phys_start, page_count, flags)) {
        pmm_free(phys_mem, page_count);
        return NULL;
    }

    serial_printf("Paging: allocated %zu pages at virt 0x%llx\n", page_count, virt_start);
    return (void*)virt_start;
}

void paging_free_pages(vmm_pagemap_t* pagemap, void* virt_addr, size_t page_count) {
    if (!pagemap || !virt_addr || page_count == 0)
        return;

    uintptr_t virt_start = (uintptr_t)virt_addr;
    paging_unmap_range(pagemap, virt_start, page_count);
    serial_printf("Paging: freed %zu pages at virt 0x%llx\n", page_count, virt_start);
}

void paging_print_stats(vmm_pagemap_t* pagemap) {
    (void)pagemap;

    serial_printf("\n=== Paging Statistics ===\n");
    serial_printf("Regions: %zu, Reserved: %zu\n", region_count, reserved_count);

    size_t active = 0, total_pages = 0, total_bytes = 0;
    for (size_t i = 0; i < region_count; i++) {
        if (regions[i].allocated) {
            active++;
            total_pages += regions[i].page_count;
            total_bytes += regions[i].page_count * PAGE_SIZE;
        }
    }

    serial_printf("Active regions: %zu\n", active);
    serial_printf("Total pages: %zu (%.2f MB)\n", total_pages, total_bytes / (1024.0 * 1024.0));
    serial_printf("Next alloc: 0x%llx\n", next_alloc_virt);

    serial_printf("\nReserved ranges:\n");
    for (size_t i = 0; i < reserved_count; i++) {
        serial_printf("  0x%llx - 0x%llx\n",
                      reserved_ranges[i].start, reserved_ranges[i].end);
    }
}

void paging_dump_range(vmm_pagemap_t* pagemap, uintptr_t virt_start, uintptr_t virt_end) {
    serial_printf("\n=== Page Table Dump (0x%llx - 0x%llx) ===\n", virt_start, virt_end);

    size_t mapped = 0, total = 0;
    for (uintptr_t virt = virt_start; virt < virt_end; virt += PAGE_SIZE) {
        total++;
        uintptr_t phys;
        uint64_t flags;
        if (vmm_virt_to_phys(pagemap, virt, &phys) && vmm_get_page_flags(pagemap, virt, &flags)) {
            mapped++;
            serial_printf("0x%llx -> 0x%llx [", virt, phys);
            if (flags & PAGING_PRESENT) serial_printf("P");
            if (flags & PAGING_WRITE)  serial_printf("W");
            if (flags & PAGING_USER)   serial_printf("U");
            if (flags & PAGING_NOEXEC) serial_printf("NX");
            serial_printf("]\n");
        }
    }
    serial_printf("Mapped: %zu/%zu pages (%.1f%%)\n", mapped, total, (float)mapped / total * 100);
}


================================================================================
 FILE: ./kernel/src/memory/pmm.c
================================================================================


#include "../../include/memory/pmm.h"
#include "../../include/io/serial.h"
#include <string.h>
#include <stdio.h>

static pmm_state_t pmm;

static inline bool bitmap_test(size_t bit) {
    return (pmm.bitmap[bit >> 3] >> (bit & 7)) & 1;
}

static inline void bitmap_set(size_t bit) {
    pmm.bitmap[bit >> 3] |= (1 << (bit & 7));
}

static inline void bitmap_clear(size_t bit) {
    pmm.bitmap[bit >> 3] &= ~(1 << (bit & 7));
}

static size_t find_free_pages(size_t pages) {
    if (pages == 0) return (size_t)-1;
    size_t run = 0;
    for (size_t i = 1; i < pmm.total_pages; i++) {
        if (!bitmap_test(i)) {
            if (++run == pages)
                return i - pages + 1;
        } else {
            run = 0;
        }
    }
    return (size_t)-1;
}

void pmm_init(struct limine_memmap_response* memmap,
              struct limine_hhdm_response* hhdm) {
    pmm.hhdm_offset = hhdm->offset;

    uintptr_t max_phys = 0;
    pmm.usable_pages = 0;

    for (size_t i = 0; i < memmap->entry_count; i++) {
        struct limine_memmap_entry* e = memmap->entries[i];
        if (e->type == LIMINE_MEMMAP_USABLE) {
            uintptr_t end = e->base + e->length;
            if (end > max_phys) max_phys = end;
            pmm.usable_pages += e->length / PAGE_SIZE;
        }
    }

    pmm.mem_start = 0;
    pmm.mem_end   = max_phys;
    pmm.total_pages = max_phys / PAGE_SIZE;
    pmm.free_pages  = 0;
    pmm.bitmap_size = (pmm.total_pages + 7) / 8;

    size_t bitmap_pages = PMM_PAGE_ALIGN(pmm.bitmap_size) / PAGE_SIZE;
    uintptr_t bitmap_phys = 0;

    for (size_t i = 0; i < memmap->entry_count; i++) {
        struct limine_memmap_entry* e = memmap->entries[i];
        if (e->type == LIMINE_MEMMAP_USABLE && e->length >= bitmap_pages * PAGE_SIZE) {
            bitmap_phys = PMM_PAGE_ALIGN(e->base);
            break;
        }
    }

    if (!bitmap_phys) {
        printf("PMM ERROR: cannot find space for bitmap\n");
        for (;;) asm volatile ("hlt");
    }

    pmm.bitmap = (uint8_t*)(bitmap_phys + pmm.hhdm_offset);
    memset(pmm.bitmap, 0xFF, pmm.bitmap_size);

    for (size_t i = 0; i < memmap->entry_count; i++) {
        struct limine_memmap_entry* e = memmap->entries[i];
        if (e->type == LIMINE_MEMMAP_USABLE) {
            size_t first = e->base / PAGE_SIZE;
            size_t count = e->length / PAGE_SIZE;
            for (size_t j = 0; j < count; j++) {
                bitmap_clear(first + j);
                pmm.free_pages++;
            }
        }
    }

    size_t bitmap_page = bitmap_phys / PAGE_SIZE;
    for (size_t i = 0; i < bitmap_pages; i++) {
        if (!bitmap_test(bitmap_page + i)) {
            bitmap_set(bitmap_page + i);
            pmm.free_pages--;
        }
    }

    if (!bitmap_test(0)) {
        bitmap_set(0);
        pmm.free_pages--;
    }
}

void* pmm_alloc(size_t pages) {
    if (pages == 0) return NULL;
    size_t start = find_free_pages(pages);
    if (start == (size_t)-1) return NULL;

    for (size_t i = 0; i < pages; i++)
        bitmap_set(start + i);
    pmm.free_pages -= pages;

    return pmm_phys_to_virt(start * PAGE_SIZE);
}

void* pmm_alloc_zero(size_t pages) {
    void* p = pmm_alloc(pages);
    if (p) memset(p, 0, pages * PAGE_SIZE);
    return p;
}

void* pmm_alloc_aligned(size_t pages, size_t alignment) {
    if (pages == 0) return NULL;
    if (alignment < PAGE_SIZE) alignment = PAGE_SIZE;

    if ((alignment & (alignment - 1)) != 0) {
        alignment--;
        alignment |= alignment >> 1;
        alignment |= alignment >> 2;
        alignment |= alignment >> 4;
        alignment |= alignment >> 8;
        alignment |= alignment >> 16;
        alignment |= alignment >> 32;
        alignment++;
    }

    size_t extra_pages = (alignment / PAGE_SIZE) - 1;
    if (extra_pages > SIZE_MAX - pages) return NULL;
    size_t total_alloc = pages + extra_pages;

    void* block = pmm_alloc(total_alloc);
    if (!block) return NULL;

    uintptr_t phys_addr = pmm_virt_to_phys(block);
    uintptr_t aligned_phys = (phys_addr + alignment - 1) & ~(alignment - 1);
    size_t offset_pages = (aligned_phys - phys_addr) / PAGE_SIZE;

    if (offset_pages > 0) {
        pmm_free(block, offset_pages);
    }

    void* aligned_virt = pmm_phys_to_virt(aligned_phys);
    size_t suffix_pages = total_alloc - offset_pages - pages;
    if (suffix_pages > 0) {
        void* suffix_virt = (char*)aligned_virt + pages * PAGE_SIZE;
        pmm_free(suffix_virt, suffix_pages);
    }

    return aligned_virt;
}

void pmm_free(void* addr, size_t pages) {
    if (!addr || pages == 0) return;

    uintptr_t phys = pmm_virt_to_phys(addr);
    size_t start_page = phys / PAGE_SIZE;

    for (size_t i = 0; i < pages; i++) {
        size_t p = start_page + i;
        if (p < pmm.total_pages && bitmap_test(p)) {
            bitmap_clear(p);
            pmm.free_pages++;
        }
    }
}

uintptr_t pmm_virt_to_phys(void* addr) {
    return (uintptr_t)addr - pmm.hhdm_offset;
}

void* pmm_phys_to_virt(uintptr_t addr) {
    return (void*)(addr + pmm.hhdm_offset);
}

uint64_t pmm_get_hhdm_offset(void) {
    return pmm.hhdm_offset;
}

size_t pmm_get_total_pages(void) { return pmm.total_pages; }
size_t pmm_get_free_pages(void)  { return pmm.free_pages; }
size_t pmm_get_used_pages(void)  { return pmm.usable_pages - pmm.free_pages; }

static void print_size(size_t bytes, const char* label) {
    double value = (double)bytes;
    const char* unit = "B";

    if (bytes >= 1024ULL * 1024 * 1024) {
        value = value / (1024 * 1024 * 1024);
        unit = "GB";
    } else if (bytes >= 1024 * 1024) {
        value = value / (1024 * 1024);
        unit = "MB";
    } else if (bytes >= 1024) {
        value = value / 1024;
        unit = "KB";
    }

    printf("%s: %.2f %s\n", label, value, unit);
    serial_printf("%s: %.2f %s\n", label, value, unit);
}

void pmm_print_stats(void) {
    size_t usable_bytes = pmm.usable_pages * PAGE_SIZE;
    size_t free_bytes   = pmm.free_pages   * PAGE_SIZE;
    size_t used_bytes   = usable_bytes - free_bytes;
    size_t total_bytes  = pmm.total_pages * PAGE_SIZE;
    size_t reserved     = total_bytes - usable_bytes;

    printf("\n=== Physical Memory ===\n");
    serial_printf("\n=== Physical Memory ===\n");

    print_size(usable_bytes, "Usable RAM");
    print_size(free_bytes,   "Free RAM");
    print_size(used_bytes,   "Used (kernel)");
    print_size(reserved,     "Reserved/MMIO");

    printf("Page size    : %u bytes\n", PAGE_SIZE);
    serial_printf("Page size    : %u bytes\n", PAGE_SIZE);

    printf("=======================\n");
    serial_printf("=======================\n");
}




================================================================================
 FILE: ./kernel/src/memory/vmm.c
================================================================================


#include "../../include/memory/vmm.h"
#include "../../include/memory/pmm.h"
#include "../../include/io/serial.h"
#include "../../include/apic/apic.h"
#include "../../include/smp/smp.h"
#include <string.h>
#include <stdio.h>

#define KERNEL_TEST_BASE 0xFFFF800000100000ULL
#define MASK 0x1FF

static vmm_pagemap_t kernel_pagemap;

static inline void invlpg(void* addr) {
    asm volatile ("invlpg (%0)" :: "r"(addr) : "memory");
}

static vmm_pte_t* alloc_table(void) {
    void* page = pmm_alloc_zero(1);
    if (!page) {
        printf("VMM ERROR: out of memory\n");
        for (;;) asm volatile ("hlt");
    }
    return (vmm_pte_t*)page;
}

static vmm_pte_t* get_table(vmm_pte_t* parent, size_t index) {
    if (!(parent[index] & VMM_PRESENT)) {
        vmm_pte_t* table = alloc_table();
        parent[index] = pmm_virt_to_phys(table) | VMM_PRESENT | VMM_WRITE;
    }
    return (vmm_pte_t*)pmm_phys_to_virt(parent[index] & ~0xFFF);
}

bool vmm_map_page(vmm_pagemap_t* map, uintptr_t virt, uintptr_t phys, uint64_t flags) {
    size_t pml4_i = (virt >> 39) & MASK;
    size_t pdpt_i = (virt >> 30) & MASK;
    size_t pd_i   = (virt >> 21) & MASK;
    size_t pt_i   = (virt >> 12) & MASK;

    vmm_pte_t* pdpt = get_table(map->pml4, pml4_i);
    vmm_pte_t* pd   = get_table(pdpt, pdpt_i);
    vmm_pte_t* pt   = get_table(pd, pd_i);

    pt[pt_i] = (phys & ~0xFFF) | flags | VMM_PRESENT | VMM_WRITE;

    asm volatile ("mfence" ::: "memory");
    invlpg((void*)virt);
    asm volatile ("mfence" ::: "memory");

    return true;
}

void vmm_unmap_page_noflush(vmm_pagemap_t* map, uintptr_t virt) {
    size_t pml4_i = (virt >> 39) & MASK;
    size_t pdpt_i = (virt >> 30) & MASK;
    size_t pd_i   = (virt >> 21) & MASK;
    size_t pt_i   = (virt >> 12) & MASK;

    if (!(map->pml4[pml4_i] & VMM_PRESENT)) return;
    vmm_pte_t* pdpt = (vmm_pte_t*)pmm_phys_to_virt(map->pml4[pml4_i] & ~0xFFF);
    if (!(pdpt[pdpt_i] & VMM_PRESENT)) return;
    vmm_pte_t* pd = (vmm_pte_t*)pmm_phys_to_virt(pdpt[pdpt_i] & ~0xFFF);
    if (!(pd[pd_i] & VMM_PRESENT)) return;
    vmm_pte_t* pt = (vmm_pte_t*)pmm_phys_to_virt(pd[pd_i] & ~0xFFF);
    pt[pt_i] = 0;
}

void vmm_unmap_page(vmm_pagemap_t* map, uintptr_t virt) {
    size_t pml4_i = (virt >> 39) & MASK;
    size_t pdpt_i = (virt >> 30) & MASK;
    size_t pd_i   = (virt >> 21) & MASK;
    size_t pt_i   = (virt >> 12) & MASK;

    if (!(map->pml4[pml4_i] & VMM_PRESENT)) return;
    vmm_pte_t* pdpt = (vmm_pte_t*)pmm_phys_to_virt(map->pml4[pml4_i] & ~0xFFF);
    if (!(pdpt[pdpt_i] & VMM_PRESENT)) return;
    vmm_pte_t* pd = (vmm_pte_t*)pmm_phys_to_virt(pdpt[pdpt_i] & ~0xFFF);
    if (!(pd[pd_i] & VMM_PRESENT)) return;
    vmm_pte_t* pt = (vmm_pte_t*)pmm_phys_to_virt(pd[pd_i] & ~0xFFF);

    pt[pt_i] = 0;
    asm volatile ("mfence" ::: "memory");

    invlpg((void*)virt);

    if (smp_get_cpu_count() > 1) {
        ipi_tlb_shootdown_broadcast(&virt, 1);
    }
}


vmm_pagemap_t* vmm_create_pagemap(void) {
    vmm_pagemap_t* map = pmm_alloc_zero(1);
    if (!map) {
        printf("VMM ERROR: cannot allocate pagemap\n");
        for (;;) asm volatile ("hlt");
    }

    map->pml4 = alloc_table();

    for (size_t i = 256; i < 512; i++) {
        map->pml4[i] = kernel_pagemap.pml4[i];
    }

    return map;
}


void vmm_switch_pagemap(vmm_pagemap_t* map) {
    uintptr_t phys = pmm_virt_to_phys(map->pml4);
    asm volatile ("mov %0, %%cr3" :: "r"(phys) : "memory");
}

bool vmm_virt_to_phys(vmm_pagemap_t* map, uintptr_t virt, uintptr_t* phys_out) {
    if (!map || !phys_out) {
        serial_printf("VMM_VIRT_TO_PHYS ERROR: null parameters\n");
        return false;
    }

    size_t pml4_i = (virt >> 39) & MASK;
    size_t pdpt_i = (virt >> 30) & MASK;
    size_t pd_i   = (virt >> 21) & MASK;
    size_t pt_i   = (virt >> 12) & MASK;

    if (!(map->pml4[pml4_i] & VMM_PRESENT)) return false;
    vmm_pte_t* pdpt = (vmm_pte_t*)pmm_phys_to_virt(map->pml4[pml4_i] & ~0xFFF);
    if (!(pdpt[pdpt_i] & VMM_PRESENT)) return false;
    vmm_pte_t* pd = (vmm_pte_t*)pmm_phys_to_virt(pdpt[pdpt_i] & ~0xFFF);
    if (!(pd[pd_i] & VMM_PRESENT)) return false;
    vmm_pte_t* pt = (vmm_pte_t*)pmm_phys_to_virt(pd[pd_i] & ~0xFFF);
    if (!(pt[pt_i] & VMM_PRESENT)) return false;

    *phys_out = (pt[pt_i] & ~0xFFF) | (virt & 0xFFF);
    return true;
}

bool vmm_get_page_flags(vmm_pagemap_t* map, uintptr_t virt, uint64_t* flags_out) {
    if (!map || !flags_out) return false;

    size_t pml4_i = (virt >> 39) & MASK;
    size_t pdpt_i = (virt >> 30) & MASK;
    size_t pd_i   = (virt >> 21) & MASK;
    size_t pt_i   = (virt >> 12) & MASK;

    if (!(map->pml4[pml4_i] & VMM_PRESENT)) return false;
    vmm_pte_t* pdpt = (vmm_pte_t*)pmm_phys_to_virt(map->pml4[pml4_i] & ~0xFFF);
    if (!(pdpt[pdpt_i] & VMM_PRESENT)) return false;
    vmm_pte_t* pd = (vmm_pte_t*)pmm_phys_to_virt(pdpt[pdpt_i] & ~0xFFF);
    if (!(pd[pd_i] & VMM_PRESENT)) return false;
    vmm_pte_t* pt = (vmm_pte_t*)pmm_phys_to_virt(pd[pd_i] & ~0xFFF);
    if (!(pt[pt_i] & VMM_PRESENT)) return false;

    *flags_out = pt[pt_i] & (0xFFF | (1ULL << 63));
    return true;
}
uintptr_t kernel_pml4_phys;
void vmm_init(void) {
    uintptr_t cr3;
    asm volatile ("mov %%cr3, %0" : "=r"(cr3));
    kernel_pagemap.pml4 = (vmm_pte_t*)pmm_phys_to_virt(cr3);
    kernel_pml4_phys = cr3;
    serial_printf("VMM: kernel pagemap initialized\n");
    serial_printf("VMM: kernel PML4 phys = 0x%llx\n", kernel_pml4_phys);
}

vmm_pagemap_t* vmm_get_kernel_pagemap(void) {
    return &kernel_pagemap;
}

void vmm_test(void) {
    serial_printf("\n--- VMM EXTENDED 64-BIT TEST ---\n");

    void* phys1 = pmm_alloc_zero(1);
    void* phys2 = pmm_alloc_zero(1);

    uintptr_t paddr1 = pmm_virt_to_phys(phys1);
    uintptr_t paddr2 = pmm_virt_to_phys(phys2);

    uintptr_t vaddr1 = KERNEL_TEST_BASE;
    uintptr_t vaddr2 = KERNEL_TEST_BASE + 0x1000;

    vmm_map_page(&kernel_pagemap, vaddr1, paddr1, VMM_WRITE);
    vmm_map_page(&kernel_pagemap, vaddr2, paddr2, VMM_WRITE);

    uint64_t* ptr1 = (uint64_t*)vaddr1;
    uint64_t* ptr2 = (uint64_t*)vaddr2;

    *ptr1 = 0xDEADBEEFCAFEBABE;
    *ptr2 = 0xFEEDFACE12345678;

    vmm_pagemap_t* new_map = vmm_create_pagemap();

    void* phys3 = pmm_alloc_zero(1);
    uintptr_t paddr3 = pmm_virt_to_phys(phys3);
    uintptr_t vaddr3 = KERNEL_TEST_BASE + 0x2000;

    vmm_map_page(new_map, vaddr3, paddr3, VMM_WRITE);

    uint64_t* ptr3 = (uint64_t*)vaddr3;
    *ptr3 = 0xBAADF00DBAADF00D;

    vmm_switch_pagemap(new_map);
    serial_printf("Value (new): 0x%llx\n", *ptr3);

    vmm_switch_pagemap(&kernel_pagemap);
    serial_printf("Value (kernel): 0x%llx\n", *ptr1);

    serial_printf("--- VMM TEST DONE ---\n");

    serial_printf("\n--- VMM TRANSLATION TEST ---\n");

    void* phys_page = pmm_alloc_zero(1);
    uintptr_t paddr = pmm_virt_to_phys(phys_page);
    uintptr_t vaddr = KERNEL_TEST_BASE + 0x3000;

    vmm_map_page(&kernel_pagemap, vaddr, paddr, VMM_WRITE);

    uintptr_t translated_phys;
    if (vmm_virt_to_phys(&kernel_pagemap, vaddr, &translated_phys)) {
        serial_printf("Virt 0x%llx -> Phys 0x%llx\n", vaddr, translated_phys);
        serial_printf("Original phys: 0x%llx\n", paddr);
        serial_printf("Match: %s\n", translated_phys == paddr ? "YES" : "NO");
    } else {
        serial_printf("Translation failed!\n");
    }

    uint64_t flags;
    if (vmm_get_page_flags(&kernel_pagemap, vaddr, &flags)) {
        serial_printf("Page flags: 0x%llx\n", flags);
        serial_printf("Present: %s\n", (flags & VMM_PRESENT) ? "YES" : "NO");
        serial_printf("Writable: %s\n", (flags & VMM_WRITE) ? "YES" : "NO");
    }

    uint64_t hhdm = pmm_get_hhdm_offset();
    serial_printf("HHDM offset: 0x%llx\n", hhdm);

    serial_printf("\n--- Memory statistics after tests ---\n");
    size_t free_before = pmm_get_free_pages();

    serial_printf("\n--- Memory free test ---\n");
    void* test_alloc = pmm_alloc_aligned(2, 4096);
    if (test_alloc) {
        size_t free_after_alloc = pmm_get_free_pages();
        serial_printf("Allocated 2 pages. Free pages: %zu -> %zu\n",
                     free_before, free_after_alloc);

        pmm_free(test_alloc, 2);
        size_t free_after_free = pmm_get_free_pages();
        serial_printf("Freed 2 pages. Free pages: %zu -> %zu\n",
                     free_after_alloc, free_after_free);

        if (free_after_free == free_before) {
            serial_printf("Memory free test PASSED\n");
        } else {
            serial_printf("Memory free test FAILED (possible leak)\n");
        }
    }

    serial_printf("--- VMM TRANSLATION TEST DONE ---\n");
}



================================================================================
 FILE: ./kernel/src/sched/sched.c
================================================================================


#include "../include/sched/sched.h"
#include "../include/smp/smp.h"
#include "../include/apic/apic.h"
#include "../include/io/serial.h"
#include "../include/memory/pmm.h"
#include "../include/memory/vmm.h"
#include "../include/drivers/timer.h"
#include "../include/sse/fpu.h"
#include <string.h>
#include <stdlib.h>

task_t* ready_queues[MAX_PRIORITY + 1] = {0};
task_t* current_task[8] = {0};

static task_t* percpu_ready_queues[8][MAX_PRIORITY + 1] = {0};
static task_t  idle_tasks[8];
static volatile uint64_t reschedule_calls = 0;
static volatile uint32_t global_queue_lock = 0;

void idle_loop(void* arg) {
    (void)arg;
    while (1) {
        asm volatile ("hlt");
    }
}

static inline void spin_lock(volatile uint32_t* lock) {
    while (__sync_lock_test_and_set(lock, 1))
        asm volatile ("pause");
}

static inline void spin_unlock(volatile uint32_t* lock) {
    __sync_lock_release(lock);
}

static uint64_t alloc_and_init_stack(task_t* t) {
    uintptr_t stack_virt = (uintptr_t)pmm_alloc(4);
    if (!stack_virt) return 0;

    t->stack_base = stack_virt;

    uintptr_t stack_phys = pmm_virt_to_phys((void*)stack_virt);
    for (size_t i = 0; i < 4; i++) {
        vmm_map_page(vmm_get_kernel_pagemap(),
                     stack_virt + i * 0x1000,
                     stack_phys + i * 0x1000,
                     VMM_PRESENT | VMM_WRITE | VMM_GLOBAL);
    }
    asm volatile ("mov %%cr3, %%rax; mov %%rax, %%cr3" ::: "rax", "memory");

    uintptr_t stack_top = (stack_virt + 0x4000) & ~0xFULL;
    uint64_t* sp = (uint64_t*)stack_top;

    extern void task_trampoline(void);

    *--sp = (uint64_t)task_trampoline;
    *--sp = (uint64_t)t;
    *--sp = 0;
    *--sp = 0;
    *--sp = 0;
    *--sp = 0;
    *--sp = 0;

    return (uint64_t)sp;
}

void sched_init(void) {
    for (uint32_t i = 0; i < smp_get_cpu_count(); i++) {
        task_t* idle = &idle_tasks[i];
        memset(idle, 0, sizeof(task_t));
        idle->priority       = 0;
        idle->runnable       = true;
        idle->state          = TASK_READY;
        idle->cpu_id         = i;
        idle->last_cpu       = i;
        idle->rip            = (uint64_t)idle_loop;
        idle->time_slice     = 1;
        idle->time_slice_init= 1;
        idle->fpu_used       = false;
        idle->fpu_state      = NULL;
        idle->entry          = idle_loop;
        idle->arg            = NULL;
        idle->name[0]='i'; idle->name[1]='d'; idle->name[2]='l'; idle->name[3]='e';

        idle->rsp = alloc_and_init_stack(idle);
        if (!idle->rsp) {
            serial_printf("[SCHED] FATAL: cannot alloc idle stack for CPU %u\n", i);
            while (1) asm volatile("cli; hlt");
        }

        current_task[i] = NULL;
        for (int p = 0; p <= MAX_PRIORITY; p++)
            percpu_ready_queues[i][p] = NULL;
    }
    serial_writestring("Scheduler initialized (PREEMPTIVE SMP MODE)\n");
}

task_t* task_create(const char* name, void (*entry)(void*), void* arg, int priority) {
    task_t* t = calloc(1, sizeof(task_t));
    if (!t) return NULL;

    t->entry          = entry;
    t->arg            = arg;
    t->priority       = priority > MAX_PRIORITY ? MAX_PRIORITY : priority;
    t->runnable       = true;
    t->state          = TASK_READY;
    t->cpu_id         = (uint32_t)-1;
    t->last_cpu       = 0;
    t->cpu_affinity   = 0;
    t->time_slice     = TASK_DEFAULT_TIMESLICE;
    t->time_slice_init= TASK_DEFAULT_TIMESLICE;
    t->total_runtime  = 0;
    t->rip            = (uint64_t)entry;

    t->rsp = alloc_and_init_stack(t);
    if (!t->rsp) {
        free(t);
        return NULL;
    }

    t->fpu_state = (fpu_state_t*)aligned_alloc(16, sizeof(fpu_state_t));
    if (!t->fpu_state) {
        serial_printf("WARNING: Failed to allocate FPU state for task %s\n", name);
        t->fpu_used = false;
    } else {
        memset(t->fpu_state, 0, sizeof(fpu_state_t));
        *(uint16_t*)(t->fpu_state->data)      = 0x037F;
        *(uint32_t*)(t->fpu_state->data + 24) = 0x1F80;
        t->fpu_used = false;
        serial_printf("Task %s: FPU state initialized (FCW=0x%x, MXCSR=0x%x)\n",
                      name,
                      *(uint16_t*)(t->fpu_state->data),
                      *(uint32_t*)(t->fpu_state->data + 24));
    }

    strncpy(t->name, name, 31);

    spin_lock(&global_queue_lock);
    t->next = ready_queues[t->priority];
    ready_queues[t->priority] = t;
    spin_unlock(&global_queue_lock);

    serial_printf("Task created: %s (prio %d, timeslice %u, rsp=0x%llx, FPU=%s)\n",
                  name, t->priority, t->time_slice, t->rsp,
                  t->fpu_state ? "yes" : "no");
    return t;
}

void task_destroy(task_t* task) {
    if (!task) return;

    serial_printf("[SCHED] Destroying task '%s'\n", task->name);

    if (task->stack_base) {
        for (size_t i = 0; i < 4; i++) {
            vmm_unmap_page(vmm_get_kernel_pagemap(),
                           task->stack_base + i * 0x1000);
        }
        pmm_free((void*)task->stack_base, 4);
        task->stack_base = 0;
    }

    if (task->fpu_state) {
        aligned_free(task->fpu_state);
        task->fpu_state = NULL;
    }

    task->state = TASK_DEAD;
    free(task);
}

__attribute__((noreturn)) void task_exit(void) {
    asm volatile ("cli");

    uint32_t cpu = lapic_get_id();
    task_t*  me  = current_task[cpu];

    if (me) {
        serial_printf("[SCHED] task_exit: '%s' on CPU %u\n", me->name, cpu);
        me->runnable = false;
        me->state    = TASK_ZOMBIE;
        current_task[cpu] = NULL;
    }

    task_t* next = NULL;

    for (int p = MAX_PRIORITY; p >= 0; p--) {
        if (percpu_ready_queues[cpu][p]) {
            next = percpu_ready_queues[cpu][p];
            percpu_ready_queues[cpu][p] = next->next;
            next->next = NULL;
            break;
        }
    }
    if (!next) {
        spin_lock(&global_queue_lock);
        for (int p = MAX_PRIORITY; p >= 0; p--) {
            if (ready_queues[p]) {
                next = ready_queues[p];
                ready_queues[p] = next->next;
                next->next = NULL;
                break;
            }
        }
        spin_unlock(&global_queue_lock);
    }
    if (!next) next = &idle_tasks[cpu];

    if (next->cr3 != 0)
        asm volatile ("mov %0, %%cr3" :: "r"(next->cr3) : "memory");

    next->cpu_id      = cpu;
    next->state       = TASK_RUNNING;
    current_task[cpu] = next;

    if (next->fpu_state)
        fpu_restore(next->fpu_state);

    asm volatile ("" ::: "memory");
    first_task_start(next);

    while (1) asm volatile ("cli; hlt");
}

void task_kill(task_t* target) {
    if (!target || target->state == TASK_ZOMBIE || target->state == TASK_DEAD)
        return;

    serial_printf("[SCHED] task_kill: killing '%s'\n", target->name);

    __sync_bool_compare_and_swap(&target->runnable, true, false);
    target->state = TASK_ZOMBIE;

    spin_lock(&global_queue_lock);
    task_t* prev = NULL;
    task_t* cur  = ready_queues[target->priority];
    while (cur) {
        if (cur == target) {
            if (prev) prev->next = cur->next;
            else      ready_queues[target->priority] = cur->next;
            cur->next = NULL;
            break;
        }
        prev = cur;
        cur  = cur->next;
    }
    spin_unlock(&global_queue_lock);

    for (uint32_t cpu = 0; cpu < smp_get_cpu_count(); cpu++) {
        prev = NULL;
        cur  = percpu_ready_queues[cpu][target->priority];
        while (cur) {
            if (cur == target) {
                if (prev) prev->next = cur->next;
                else      percpu_ready_queues[cpu][target->priority] = cur->next;
                cur->next = NULL;
                break;
            }
            prev = cur;
            cur  = cur->next;
        }
    }

    for (uint32_t cpu = 0; cpu < smp_get_cpu_count(); cpu++) {
        if (current_task[cpu] == target) {
            serial_printf("[SCHED] task_kill: target running on CPU %u, sending reschedule IPI\n", cpu);
            extern uint32_t smp_get_lapic_id_for_cpu(uint32_t cpu);
            ipi_reschedule_cpu(smp_get_lapic_id_for_cpu(cpu));
            break;
        }
    }
}

static task_t* sched_pick_next(uint32_t cpu) {
    for (int p = MAX_PRIORITY; p >= 0; p--) {
        if (percpu_ready_queues[cpu][p]) {
            task_t* t = percpu_ready_queues[cpu][p];
            percpu_ready_queues[cpu][p] = t->next;
            t->next = NULL;
            return t;
        }
    }
    spin_lock(&global_queue_lock);
    for (int p = MAX_PRIORITY; p >= 0; p--) {
        if (ready_queues[p]) {
            task_t* t = ready_queues[p];
            ready_queues[p] = t->next;
            t->next = NULL;
            spin_unlock(&global_queue_lock);
            return t;
        }
    }
    spin_unlock(&global_queue_lock);
    return &idle_tasks[cpu];
}

void sched_reschedule(void) {
    reschedule_calls++;

    uint32_t cpu  = lapic_get_id();
    task_t*  old  = current_task[cpu];
    task_t*  next = sched_pick_next(cpu);

    if (old == next) {
        if (old) old->time_slice = old->time_slice_init;
        return;
    }

    if (old && old->fpu_state) {
        fpu_save(old->fpu_state);
        old->fpu_used = true;
    }

    if (old && old != &idle_tasks[cpu] && old->runnable) {
        old->time_slice = old->time_slice_init;
        old->last_cpu   = cpu;
        old->state      = TASK_READY;
        old->next = percpu_ready_queues[cpu][old->priority];
        percpu_ready_queues[cpu][old->priority] = old;
    }

    if (next->cr3 != 0 && (!old || old->cr3 != next->cr3))
        asm volatile ("mov %0, %%cr3" :: "r"(next->cr3) : "memory");

    next->cpu_id    = cpu;
    next->state     = TASK_RUNNING;
    current_task[cpu] = next;

    if (next->fpu_state)
        fpu_restore(next->fpu_state);

    if (!old) {
        asm volatile ("" ::: "memory");
        first_task_start(next);
        serial_writestring("[SCHED] FATAL: first_task_start returned!\n");
        while (1) asm volatile ("cli; hlt");
    }

    context_switch(old, next);
}

void task_yield(void) {
    sched_reschedule();
}

void sched_print_stats(void) {
    serial_printf("\nScheduler Statistics (SMP)\n");
    serial_writestring("Global queue:\n");
    for (int p = MAX_PRIORITY; p >= 0; p--) {
        int count = 0;
        for (task_t* t = ready_queues[p]; t; t = t->next) count++;
        if (count) serial_printf("  Priority %d: %d tasks\n", p, count);
    }
    for (uint32_t cpu = 0; cpu < smp_get_cpu_count(); cpu++) {
        serial_printf("\nCPU %u:\n", cpu);
        if (current_task[cpu])
            serial_printf("  Running: %s (FPU: %s, state: %d)\n",
                          current_task[cpu]->name,
                          current_task[cpu]->fpu_used ? "yes" : "no",
                          current_task[cpu]->state);
        for (int p = MAX_PRIORITY; p >= 0; p--) {
            int count = 0;
            for (task_t* t = percpu_ready_queues[cpu][p]; t; t = t->next) count++;
            if (count) serial_printf("  Priority %d: %d tasks\n", p, count);
        }
    }
    serial_printf("============================\n\n");
}


================================================================================
 FILE: ./kernel/src/smp/percpu.c
================================================================================


#include "../../include/smp/percpu.h"
#include "../../include/smp/smp.h"
#include "../../include/memory/pmm.h"
#include "../../include/io/serial.h"
#include <string.h>
#include <stdlib.h>

extern uintptr_t __percpu_start;
extern uintptr_t __percpu_end;

PERCPU_SECTION percpu_t percpu = {0};
PERCPU_SECTION int dummy_percpu = 0xDEADBEEF;

percpu_t* percpu_regions[MAX_CPUS] = {0};

void init_percpu_regions(void) {
    size_t percpu_size = &__percpu_end - &__percpu_start;
    serial_printf("PerCPU size: %zu bytes\n", percpu_size);

    smp_info_t* info = smp_get_info();
    for (uint32_t i = 0; i < info->cpu_count; i++) {
        void* region = malloc(percpu_size);
        if (!region) {
            serial_printf("PerCPU: Alloc failed for CPU %u\n", i);
            continue;
        }
        memset(region, 0, percpu_size);
        memcpy(region, &__percpu_start, percpu_size);

        percpu_regions[i] = (percpu_t*)region;
        percpu_regions[i]->cpu_id = info->cpus[i].lapic_id;

        serial_printf("PerCPU region for CPU %u at 0x%llx\n", i, (uint64_t)region);
    }
}

percpu_t* get_percpu(void) {
    uint64_t gs_base;
    asm volatile ("rdgsbase %0" : "=r"(gs_base));
    if (gs_base == 0) {
        return NULL;
    }
    return (percpu_t*)gs_base;
}

percpu_t* get_percpu_mut(void) {
    return get_percpu();
}

void set_percpu_base(percpu_t* base) {
    __asm__ volatile (
        "wrgsbase %0"
        :
        : "r"(base)
        : "memory"
    );
}


================================================================================
 FILE: ./kernel/src/smp/smp.c
================================================================================


#include "../../include/smp/smp.h"
#include "../../include/smp/percpu.h"
#include "../../include/acpi/acpi.h"
#include "../../include/apic/apic.h"
#include "../../include/io/serial.h"
#include "../../include/memory/pmm.h"
#include "../../include/memory/vmm.h"
#include "../../include/gdt/gdt.h"
#include "../../include/interrupts/idt.h"
#include "../../include/sse/fpu.h"
#include "../../include/sse/sse.h"
#include "../../include/sched/sched.h"
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

extern tss_t *tss[MAX_CPUS];
extern struct {
    gdt_entry_t gdt_entries[5 + (MAX_CPUS * 2)];
} __attribute__((packed)) gdt;

static smp_info_t smp_info = {0};
static volatile uint32_t ap_online_count = 0;
tlb_shootdown_t tlb_shootdown_queue[MAX_CPUS] = {0};

volatile uint32_t sched_ready_flag = 0;

void sched_notify_ready(void) {
    __sync_synchronize();
    sched_ready_flag = 1;
    __sync_synchronize();
    serial_writestring("[SCHED] Scheduler ready, notifying all APs\n");
}

__attribute__((used))
void ap_entry_init(struct limine_mp_info* cpu_info) {
    (void)cpu_info;
    asm volatile ("cli");

    lapic_write(0xF0, 0);

    gdt_load();
    idt_load();

    uint32_t lapic_id = lapic_get_id();
    smp_info_t* info = smp_get_info();
    uint32_t my_index = 0;
    for (uint32_t i = 0; i < info->cpu_count; i++) {
        if (info->cpus[i].lapic_id == lapic_id && !info->cpus[i].is_bsp) {
            my_index = i;
            info->cpus[i].state = CPU_ONLINE;
            break;
        }
    }
    load_tss(info->cpus[my_index].tss_selector);
    serial_printf("TSS Loaded (selector 0x%x)\n", info->cpus[my_index].tss_selector);

    fpu_init();
    sse_init();
    enable_fsgsbase();
    lapic_enable();

    apic_timer_calibrate();
    serial_printf("[SMP] AP %u LAPIC timer started\n", lapic_id);

    cpu_info_t* cpu = smp_get_current_cpu();
    percpu_t* region = percpu_regions[cpu->cpu_index];
    set_percpu_base(region);
    serial_printf("PerCPU base set for AP %u: 0x%llx\n",
                  lapic_id, (uint64_t)region);

    __sync_fetch_and_add(&ap_online_count, 1);
    lapic_eoi();

    serial_printf("[SMP] AP (LAPIC ID %u) initialized and online!\n", lapic_id);

    while (!sched_ready_flag)
        asm volatile ("pause");

    serial_printf("[SMP] AP %u entering scheduler loop\n", lapic_id);

    asm volatile ("sti");

    sched_reschedule();

    while (1)
        asm volatile ("hlt");
}

void ap_entry_point(struct limine_mp_info* cpu_info) {
    uint64_t stack_top;
    asm volatile (
        "mov 24(%%rdi), %0"
        : "=r"(stack_top)
        : "D"(cpu_info)
    );
    asm volatile (
        "mov %0, %%rsp\n"
        "cli\n"
        "jmp ap_entry_init\n"
        :
        : "r"(stack_top), "D"(cpu_info)
        : "memory"
    );
}

static uint64_t smp_allocate_stack(uint32_t cpu_index, size_t stack_size) {
    size_t pages = (stack_size + PAGE_SIZE - 1) / PAGE_SIZE;
    void* stack_pages = pmm_alloc(pages);
    if (!stack_pages) {
        serial_printf("[SMP WARNING] Failed to allocate stack for CPU %u\n", cpu_index);
        return 0;
    }
    uint64_t stack_virt = (uint64_t)stack_pages + stack_size;
    serial_printf("[SMP] Allocated stack for CPU %u at 0x%llx (size %zu)\n",
                  cpu_index, stack_virt, stack_size);
    return stack_virt;
}

void smp_boot_aps(struct limine_mp_response* mp_response) {
    if (!mp_response) {
        serial_writestring("[SMP ERROR] MP response is NULL\n");
        return;
    }

    serial_writestring("\n[SMP] Booting Application Processors \n");

    smp_info_t* info = smp_get_info();
    uint32_t bsp_lapic_id = info->bsp_lapic_id;
    uint32_t ap_count = 0;

    for (uint64_t i = 0; i < mp_response->cpu_count; i++) {
        struct limine_mp_info* cpu = mp_response->cpus[i];
        if (cpu->lapic_id == bsp_lapic_id) continue;

        uint64_t stack_top = smp_allocate_stack(i, AP_STACK_SIZE);
        if (stack_top == 0) {
            serial_printf("[SMP] Skipping CPU %u (stack alloc failed)\n", i);
            info->cpus[i].state = CPU_FAULTED;
            continue;
        }

        info->cpus[i].stack_top = stack_top;
        info->cpus[i].state     = CPU_BOOTED;
        cpu->extra_argument     = stack_top;
        cpu->goto_address       = (void*)ap_entry_point;

        serial_printf("[SMP] Configured AP %lu (LAPIC ID %u) to boot at 0x%llx\n",
                      i, cpu->lapic_id, (uint64_t)ap_entry_point);
        ap_count++;
    }

    __sync_synchronize();

    if (ap_count > 0) {
        serial_printf("[SMP] Waiting for %u AP(s) to initialize...\n", ap_count);
        uint64_t timeout = 10000000;
        while (ap_online_count < ap_count && timeout--)
            asm volatile ("pause");

        uint32_t online = ap_online_count;
        if (online == ap_count)
            serial_printf("[SMP SUCCESS] All %u AP(s) online!\n", ap_count);
        else
            serial_printf("[SMP WARNING] Only %u/%u AP(s) online (timeout)\n",
                          online, ap_count);
        info->online_count = 1 + online;
    } else {
        serial_writestring("[SMP] No APs to boot\n");
    }

    serial_writestring("[SMP] AP Boot Sequence Complete \n\n");
}

static void smp_init_limine(struct limine_mp_response* response) {
    if (!response) { serial_writestring("[SMP] Limine MP response is NULL\n"); return; }

    serial_printf("[SMP] Initializing via Limine MP (CPU count: %u)\n",
                  response->cpu_count);
    smp_info.cpu_count    = response->cpu_count;
    smp_info.online_count = 1;

    acpi_madt_t* madt = (acpi_madt_t*)acpi_find_table("APIC", 0);
    if (madt) {
        smp_info.lapic_base = madt->local_apic_address;
        serial_printf("[SMP] LAPIC base from ACPI: 0x%x\n", smp_info.lapic_base);
    } else {
        smp_info.lapic_base = 0xFEE00000;
    }

    for (uint64_t i = 0; i < response->cpu_count; i++) {
        struct limine_mp_info* cpu = response->cpus[i];
        smp_info.cpus[i].lapic_id     = cpu->lapic_id;
        smp_info.cpus[i].processor_id = cpu->lapic_id;
        smp_info.cpus[i].acpi_id      = 0;
        smp_info.cpus[i].state        = CPU_UNINITIALIZED;
        smp_info.cpus[i].is_bsp       = (cpu->lapic_id == response->bsp_lapic_id);
        smp_info.cpus[i].cpu_index    = i;

        if (smp_info.cpus[i].is_bsp) {
            smp_info.bsp_lapic_id  = cpu->lapic_id;
            smp_info.cpus[i].state = CPU_ONLINE;
            serial_printf("[SMP] BSP detected - APIC ID: %u\n", cpu->lapic_id);
        }
        serial_printf("[SMP] CPU[%lu] - APIC ID: %u, Processor ID: %u, BSP: %s\n",
                      i, cpu->lapic_id, cpu->lapic_id,
                      smp_info.cpus[i].is_bsp ? "YES" : "NO");
    }
}

void smp_init(struct limine_mp_response* mp_response) {
    serial_writestring("\n[SMP] Initialization\n");
    smp_init_limine(mp_response);

    uint32_t bsp_index = 0;
    for (uint32_t i = 0; i < smp_info.cpu_count; i++)
        if (smp_info.cpus[i].is_bsp) { bsp_index = i; break; }

    for (uint32_t i = 0; i < smp_info.cpu_count; i++) {
        tss[i] = (tss_t *)calloc(1, sizeof(tss_t));
        if (!tss[i]) { serial_printf("[SMP ERROR] FAILED to allocate TSS for CPU %u\n", i); continue; }

        tss[i]->rsp0   = smp_allocate_stack(i, KERNEL_STACK_SIZE);
        tss[i]->ist[0] = smp_allocate_stack(i, KERNEL_STACK_SIZE);
        tss[i]->ist[1] = smp_allocate_stack(i, KERNEL_STACK_SIZE);
        tss[i]->ist[2] = smp_allocate_stack(i, KERNEL_STACK_SIZE);
        tss[i]->ist[3] = smp_allocate_stack(i, KERNEL_STACK_SIZE);
        tss[i]->iobase = sizeof(tss_t);

        serial_printf("TSS[%u] base: 0x%llx\n", i, (uint64_t)tss[i]);

        tss_entry_t *entry = (tss_entry_t *)&gdt.gdt_entries[5 + (i * 2)];
        entry->limit_low            = sizeof(tss_t) - 1;
        uint64_t addr               = (uint64_t)tss[i];
        entry->base_low             = addr & 0xffff;
        entry->base_middle          = (addr >> 16) & 0xff;
        entry->access               = 0x89;
        entry->limit_high_and_flags = 0;
        entry->base_high            = (addr >> 24) & 0xff;
        entry->base_higher          = addr >> 32;
        entry->zero                 = 0;

        smp_info.cpus[i].tss_selector = TSS_SELECTOR_BASE + (i * 0x10);
    }

    gdtr.size = (5 + (smp_info.cpu_count * 2)) * sizeof(gdt_entry_t) - 1;
    serial_printf("Reloading extended GDT on BSP...\n");
    gdt_load();

    load_tss(smp_info.cpus[bsp_index].tss_selector);
    serial_printf("BSP TSS loaded (selector 0x%x)\n",
                  smp_info.cpus[bsp_index].tss_selector);

    uint32_t current_lapic_id = lapic_get_id();
    serial_printf("[SMP] Current LAPIC ID: %u\n", current_lapic_id);
    for (uint32_t i = 0; i < smp_info.cpu_count; i++) {
        if (smp_info.cpus[i].lapic_id == current_lapic_id) {
            smp_info.cpus[i].is_bsp  = true;
            smp_info.cpus[i].state   = CPU_ONLINE;
            smp_info.bsp_lapic_id    = current_lapic_id;
            break;
        }
    }

    smp_print_info();
    init_percpu_regions();
    smp_boot_aps(mp_response);
    set_percpu_base(percpu_regions[bsp_index]);
    serial_printf("PerCPU base set for BSP %u: 0x%llx\n",
                  smp_info.bsp_lapic_id, (uint64_t)percpu_regions[bsp_index]);
    serial_writestring("[SMP] Initialization Complete \n\n");
}

smp_info_t* smp_get_info(void)       { return &smp_info; }
uint32_t    smp_get_cpu_count(void)  { return smp_info.cpu_count; }
uint32_t    smp_get_online_count(void){ return smp_info.online_count; }
bool        smp_is_bsp(void)         { return lapic_get_id() == smp_info.bsp_lapic_id; }

cpu_info_t* smp_get_current_cpu(void) {
    uint32_t id = lapic_get_id();
    for (uint32_t i = 0; i < smp_info.cpu_count; i++)
        if (smp_info.cpus[i].lapic_id == id) return &smp_info.cpus[i];
    for (uint32_t i = 0; i < smp_info.cpu_count; i++)
        if (smp_info.cpus[i].is_bsp) return &smp_info.cpus[i];
    return NULL;
}

void smp_wait_for_ready(void) {
    serial_writestring("Waiting until all APs are fully ready...\n");
    while (smp_get_online_count() < smp_get_cpu_count())
        asm volatile ("pause");
    serial_writestring("All APs ready.\n");
}

uint32_t smp_get_lapic_id_for_cpu(uint32_t cpu_index) {
    smp_info_t* info = smp_get_info();
    if (cpu_index >= info->cpu_count) return 0xFFFFFFFF;
    return info->cpus[cpu_index].lapic_id;
}

void smp_print_info(void) {
    serial_printf("\n[SMP] CPU Information \n");
    serial_printf("Total CPUs: %u\n",    smp_info.cpu_count);
    serial_printf("Online CPUs: %u\n",   smp_info.online_count);
    serial_printf("BSP APIC ID: %u\n",   smp_info.bsp_lapic_id);
    serial_printf("LAPIC Base: 0x%llx\n",smp_info.lapic_base);
    const char* states[] = {"UNINITIALIZED","BOOTED","ONLINE","OFFLINE","FAULTED"};
    for (uint32_t i = 0; i < smp_info.cpu_count; i++)
        serial_printf("CPU[%u]: APIC ID: %u, Processor ID: %u, ACPI ID: %u, State: %s, BSP: %s\n",
                      i, smp_info.cpus[i].lapic_id, smp_info.cpus[i].processor_id,
                      smp_info.cpus[i].acpi_id, states[smp_info.cpus[i].state],
                      smp_info.cpus[i].is_bsp ? "YES" : "NO");
    serial_printf("[SMP] End CPU Information \n");
}

void smp_print_info_fb(void) {
    printf("[SMP] CPU Information \n");
    printf("Total CPUs: %u\n",  smp_info.cpu_count);
    printf("Online CPUs: %u\n", smp_info.online_count);
    printf("BSP APIC ID: %u\n", smp_info.bsp_lapic_id);
    const char* states[] = {"UNINITIALIZED","BOOTED","ONLINE","OFFLINE","FAULTED"};
    for (uint32_t i = 0; i < smp_info.cpu_count; i++)
        printf("CPU[%u]: APIC ID: %u, State: %s, BSP: %s\n",
               i, smp_info.cpus[i].lapic_id, states[smp_info.cpus[i].state],
               smp_info.cpus[i].is_bsp ? "YES" : "NO");
}


================================================================================
 FILE: ./kernel/src/sse/fpu.c
================================================================================


#include "../../include/sse/fpu.h"
#include "../../include/io/serial.h"

#define COM1 0x3F8

void fpu_init(void) {
    serial_writestring("[FPU] Initializing x87 FPU...\n");

    if (!fpu_detect()) {
        serial_writestring("[FPU] No FPU detected!\n");
        return;
    }

    uint64_t cr0;
    asm volatile("mov %%cr0, %0" : "=r"(cr0));

    cr0 &= ~(1 << 2);  // Clear EM
    cr0 |= (1 << 1);   // Set MP

    cr0 &= ~(1 << 3);  // Clear TS
    cr0 &= ~(1 << 5);  // Clear NE

    asm volatile("mov %0, %%cr0" : : "r"(cr0));

    asm volatile("finit");

    fpu_set_control_word(0x037F);

    serial_writestring("[FPU] FPU initialized successfully\n");
}

bool fpu_detect(void) {
    uint32_t edx;

    asm volatile(
        "mov $1, %%eax\n"
        "cpuid\n"
        "mov %%edx, %0\n"
        : "=r"(edx)
        :
        : "eax", "ebx", "ecx", "edx"
    );

    return (edx & (1 << 0)) != 0;
}

void fpu_reset(void) {
    asm volatile("finit");
}

void fpu_set_control_word(uint16_t cw) {
    asm volatile("fldcw %0" : : "m"(cw));
}

uint16_t fpu_get_control_word(void) {
    uint16_t cw;
    asm volatile("fnstcw %0" : "=m"(cw));
    return cw;
}

void fpu_set_status_word(uint16_t sw) {
    (void)sw;
    // asm volatile("fnclex");
}

uint16_t fpu_get_status_word(void) {
    uint16_t sw;
    asm volatile("fnstsw %0" : "=m"(sw));
    return sw;
}

void fpu_set_tag_word(uint16_t tw) {
    (void)tw;
}

uint16_t fpu_get_tag_word(void) {
    struct {
        uint16_t control_word;
        uint16_t status_word;
        uint16_t tag_word;
        uint16_t fpu_ip;
        uint16_t fpu_cs;
        uint16_t fpu_opcode;
        uint16_t fpu_dp;
        uint16_t fpu_ds;
        uint8_t st_registers[80];
    } __attribute__((packed)) fpu_state;

    asm volatile("fxsave %0" : "=m"(fpu_state));
    return fpu_state.tag_word;
}


================================================================================
 FILE: ./kernel/src/sse/sse.c
================================================================================


#include "../../include/sse/sse.h"
#include "../../include/io/serial.h"
#include "../../include/apic/apic.h"
#include <string.h>
#include <stdio.h>
#include <math.h>

#define COM1 0x3F8

static uint32_t cpuid_edx = 0;
static uint32_t cpuid_ecx = 0;
static uint32_t cpuid_ebx_ext = 0;
static bool features_cached = false;

static void cpuid_cache_features(void) {
    if (features_cached) return;

    uint32_t eax, ebx, ecx, edx;

    asm volatile(
        "mov $1, %%eax\n"
        "cpuid\n"
        "mov %%eax, %0\n"
        "mov %%ebx, %1\n"
        "mov %%ecx, %2\n"
        "mov %%edx, %3\n"
        : "=r"(eax), "=r"(ebx), "=r"(ecx), "=r"(edx)
        :
        : "eax", "ebx", "ecx", "edx"
    );

    cpuid_edx = edx;
    cpuid_ecx = ecx;

    asm volatile(
        "mov $0, %%eax\n"
        "cpuid\n"
        : "=a"(eax)
        :
        : "ebx", "ecx", "edx"
    );

    if (eax >= 7) {
        asm volatile(
            "mov $7, %%eax\n"
            "xor %%ecx, %%ecx\n"
            "cpuid\n"
            "mov %%ebx, %0\n"
            : "=r"(cpuid_ebx_ext)
            :
            : "eax", "ecx", "edx"
        );
    }

    features_cached = true;
}

bool sse_supported(void) {
    cpuid_cache_features();
    return (cpuid_edx & (1 << 25)) != 0;  // SSE
}

bool sse2_supported(void) {
    cpuid_cache_features();
    return (cpuid_edx & (1 << 26)) != 0;  // SSE2
}

bool sse3_supported(void) {
    cpuid_cache_features();
    return (cpuid_ecx & (1 << 0)) != 0;   // SSE3
}

bool ssse3_supported(void) {
    cpuid_cache_features();
    return (cpuid_ecx & (1 << 9)) != 0;   // SSSE3
}

bool sse4_1_supported(void) {
    cpuid_cache_features();
    return (cpuid_ecx & (1 << 19)) != 0;  // SSE4.1
}

bool sse4_2_supported(void) {
    cpuid_cache_features();
    return (cpuid_ecx & (1 << 20)) != 0;  // SSE4.2
}

bool avx_supported(void) {
    cpuid_cache_features();
    return (cpuid_ecx & (1 << 28)) != 0;  // AVX
}

bool avx2_supported(void) {
    cpuid_cache_features();
    return (cpuid_ebx_ext & (1 << 5)) != 0;  // AVX2
}

bool mmx_supported(void) {
    cpuid_cache_features();
    return (cpuid_edx & (1 << 23)) != 0;  // MMX
}

void sse_init(void) {
    serial_writestring("[SSE] Initializing SSE/AVX...\n");

    cpuid_cache_features();

    if (!sse_supported()) {
        serial_writestring("[SSE] SSE not supported!\n");
        return;
    }

    uint64_t cr4;
    asm volatile("mov %%cr4, %0" : "=r"(cr4));

    cr4 |= (1 << 9);
    cr4 |= (1 << 10);

    if (avx_supported()) {
        uint32_t ecx;
        asm volatile(
            "mov $1, %%eax\n"
            "cpuid\n"
            "mov %%ecx, %0\n"
            : "=r"(ecx)
            :
            : "eax", "ebx", "edx"
        );

        if (ecx & (1 << 27)) { // OSXSAVE bit
            serial_writestring("[SSE] AVX supported, enabling...\n");

            cr4 |= (1 << 18);

            uint64_t xcr0;
            asm volatile("xgetbv" : "=a"(xcr0) : "c"(0) : "edx");
            xcr0 |= (1 << 1) | (1 << 2);
            asm volatile("xsetbv" : : "c"(0), "a"(xcr0), "d"(xcr0 >> 32));
        }
    }

    asm volatile("mov %0, %%cr4" : : "r"(cr4));

    sse_set_mxcsr(MXCSR_DEFAULT);

    serial_writestring("[SSE] SSE initialized successfully\n");

    if (sse_supported()) serial_writestring("[SSE] SSE: YES\n");
    if (sse2_supported()) serial_writestring("[SSE] SSE2: YES\n");
    if (sse3_supported()) serial_writestring("[SSE] SSE3: YES\n");
    if (sse4_1_supported()) serial_writestring("[SSE] SSE4.1: YES\n");
    if (sse4_2_supported()) serial_writestring("[SSE] SSE4.2: YES\n");
    if (avx_supported()) serial_writestring("[SSE] AVX: YES\n");
    if (mmx_supported()) serial_writestring("[SSE] MMX: YES\n");
}

void sse_set_mxcsr(uint32_t mxcsr) {
    asm volatile("ldmxcsr %0" : : "m"(mxcsr));
}

uint32_t sse_get_mxcsr(void) {
    uint32_t mxcsr;
    asm volatile("stmxcsr %0" : "=m"(mxcsr));
    return mxcsr;
}

void mmx_enter(void) {
    if (!mmx_supported()) return;
}

void mmx_exit(void) {
    if (!mmx_supported()) return;
    asm volatile("emms");
}

void sse_memcpy_fast(void* dest, const void* src, size_t n) {
    if (!sse_supported() || n < 64) {
        memcpy(dest, src, n);
        return;
    }

    uint8_t* d = (uint8_t*)dest;
    const uint8_t* s = (const uint8_t*)src;

    size_t align_offset = (16 - ((uintptr_t)d & 0xF)) & 0xF;
    if (align_offset > n) align_offset = n;

    for (size_t i = 0; i < align_offset; i++) {
        d[i] = s[i];
    }

    d += align_offset;
    s += align_offset;
    n -= align_offset;

    size_t i;
    for (i = 0; i + 64 <= n; i += 64) {
        asm volatile(
            "movdqu (%0), %%xmm0\n"
            "movdqu 16(%0), %%xmm1\n"
            "movdqu 32(%0), %%xmm2\n"
            "movdqu 48(%0), %%xmm3\n"
            "movdqu %%xmm0, (%1)\n"
            "movdqu %%xmm1, 16(%1)\n"
            "movdqu %%xmm2, 32(%1)\n"
            "movdqu %%xmm3, 48(%1)\n"
            :
            : "r"(s + i), "r"(d + i)
            : "xmm0", "xmm1", "xmm2", "xmm3", "memory"
        );
    }

    for (; i < n; i++) {
        d[i] = s[i];
    }
}

void sse_memset_fast(void* dest, int value, size_t n) {
    if (!sse_supported() || n < 64) {
        memset(dest, value, n);
        return;
    }

    uint8_t* d = (uint8_t*)dest;
    uint8_t v = (uint8_t)value;

    uint64_t pattern64 = (uint64_t)v << 56 | (uint64_t)v << 48 |
                        (uint64_t)v << 40 | (uint64_t)v << 32 |
                        (uint64_t)v << 24 | (uint64_t)v << 16 |
                        (uint64_t)v << 8 | (uint64_t)v;

    size_t align_offset = (16 - ((uintptr_t)d & 0xF)) & 0xF;
    if (align_offset > n) align_offset = n;

    for (size_t i = 0; i < align_offset; i++) {
        d[i] = v;
    }

    d += align_offset;
    n -= align_offset;

    asm volatile(
        "movq %0, %%xmm0\n"
        "punpcklqdq %%xmm0, %%xmm0\n"
        : : "r"(pattern64) : "xmm0"
    );

    size_t i;
    for (i = 0; i + 64 <= n; i += 64) {
        asm volatile(
            "movdqu %%xmm0, (%0)\n"
            "movdqu %%xmm0, 16(%0)\n"
            "movdqu %%xmm0, 32(%0)\n"
            "movdqu %%xmm0, 48(%0)\n"
            :
            : "r"(d + i)
            : "memory"
        );
    }

    for (; i < n; i++) {
        d[i] = v;
    }
}

void print_simd_cpuid(void) {
    printf("\n=== CPUID/SIMD INFORMATION ===\n");

    uint32_t eax, ebx, ecx, edx;
    char vendor[13] = {0};

    asm volatile(
        "cpuid"
        : "=a"(eax), "=b"(ebx), "=c"(ecx), "=d"(edx)
        : "a"(0)
    );

    *(uint32_t*)vendor = ebx;
    *(uint32_t*)(vendor + 4) = edx;
    *(uint32_t*)(vendor + 8) = ecx;
    vendor[12] = '\0';

    printf("CPU Vendor: %s\n", vendor);

    asm volatile(
        "cpuid"
        : "=a"(eax), "=b"(ebx), "=c"(ecx), "=d"(edx)
        : "a"(1)
    );

    printf("Processor Signature: 0x%08x\n", eax);
    printf("Stepping: %d\n", eax & 0xF);
    printf("Model: %d\n", (eax >> 4) & 0xF);
    printf("Family: %d\n", (eax >> 8) & 0xF);

    printf("\nSIMD Extensions:\n");
    printf("MMX:       %s\n", (edx & (1 << 23)) ? "YES" : "NO");
    printf("SSE:       %s\n", (edx & (1 << 25)) ? "YES" : "NO");
    printf("SSE2:      %s\n", (edx & (1 << 26)) ? "YES" : "NO");
    printf("SSE3:      %s\n", (ecx & (1 << 0)) ? "YES" : "NO");
    printf("SSSE3:     %s\n", (ecx & (1 << 9)) ? "YES" : "NO");
    printf("SSE4.1:    %s\n", (ecx & (1 << 19)) ? "YES" : "NO");
    printf("SSE4.2:    %s\n", (ecx & (1 << 20)) ? "YES" : "NO");
    printf("AVX:       %s\n", (ecx & (1 << 28)) ? "YES" : "NO");
    printf("FMA:       %s\n", (ecx & (1 << 12)) ? "YES" : "NO");

    printf("\nFPU Test:\n");
    float PI = 3.14159f;
    float E = 2.71828f;
    float result_fpu = PI + E;
    printf("PI + e = %f\n", result_fpu);

    if (edx & (1 << 25)) {
        printf("\nSSE Vector Test:\n");
        float vec1[4] = {1.5f, 2.5f, 3.5f, 4.5f};
        float vec2[4] = {0.5f, 1.5f, 2.5f, 3.5f};
        float vec_result[4] = {0};

        asm volatile(
            "movups %1, %%xmm0\n"
            "movups %2, %%xmm1\n"
            "addps %%xmm1, %%xmm0\n"
            "movups %%xmm0, %0\n"
            : "=m"(vec_result)
            : "m"(vec1), "m"(vec2)
            : "xmm0", "xmm1", "memory"
        );

        printf("[%.2f, %.2f, %.2f, %.2f] + [%.2f, %.2f, %.2f, %.2f] =\n",
               vec1[0], vec1[1], vec1[2], vec1[3],
               vec2[0], vec2[1], vec2[2], vec2[3]);
        printf("[%.2f, %.2f, %.2f, %.2f]\n",
               vec_result[0], vec_result[1],
               vec_result[2], vec_result[3]);

        double pi = 3.141592653589793;
        double large = 123456.789;
        double small = 0.0000123456;

        printf("pi = %f\n", pi);           // 3.141593
        printf("pi = %.10f\n", pi);        // 3.1415926536
        printf("large = %e\n", large);     // 1.234568e+05
        printf("small = %e\n", small);     // 1.234560e-05
        printf("auto = %g\n", pi);         // 3.14159
        printf("auto = %g\n", small);      // 1.23456e-05

        printf("inf = %f\n", INFINITY);    // inf
        printf("nan = %f\n", NAN);         // nan

    }

    printf("=== END OF CPUID/SIMD INFO ===\n\n");
}

void enable_fsgsbase(void) {
    uint32_t eax = 7;
    uint32_t ebx, ecx, edx;
    asm volatile ("cpuid"
                  : "=a"(eax), "=b"(ebx), "=c"(ecx), "=d"(edx)
                  : "0"(eax), "2"(0));

    if (ebx & (1 << 0)) {
        uint64_t cr4;
        asm volatile ("mov %%cr4, %0" : "=r"(cr4));
        cr4 |= (1ULL << 16);
        asm volatile ("mov %0, %%cr4" :: "r"(cr4));
        serial_printf("[FSGSBASE] Enabled on CPU %u\n", lapic_get_id());
    } else {
        serial_writestring("ERROR: FSGSBASE not supported by CPU!\n");
    }
}


================================================================================
 FILE: ./libc/include/ctype.h
================================================================================


#ifndef _CTYPE_H
#define _CTYPE_H

int isalnum(int c);
int isalpha(int c);
int isblank(int c);
int iscntrl(int c);
int isdigit(int c);
int isgraph(int c);
int islower(int c);
int isupper(int c);
int isprint(int c);
int ispunct(int c);
int isspace(int c);
int isxdigit(int c);
int tolower(int c);
int toupper(int c);

#endif


================================================================================
 FILE: ./libc/include/math.h
================================================================================


#ifndef _MATH_H
#define _MATH_H

#include <stdint.h>

int abs(int x);
double fabs(double x);
double pow(double base, double exp);
double pow10(int n);
int isinf(double x);
int isnan(double x);

static inline double floor(double x) {
    int64_t i = (int64_t)x;
    return (double)(i - (x < (double)i));
}

static inline double ceil(double x) {
    int64_t i = (int64_t)x;
    return (double)(i + (x > (double)i));
}

static inline double round(double x) {
    return (x >= 0.0) ? floor(x + 0.5) : ceil(x - 0.5);
}

static inline double sqrt(double x) {
    double result;
    asm volatile ("sqrtsd %1, %0" : "=x"(result) : "x"(x));
    return result;
}

static inline float sqrtf(float x) {
    float result;
    asm volatile ("sqrtss %1, %0" : "=x"(result) : "x"(x));
    return result;
}

static inline double log2(double x) {
    double result;
    asm volatile (
        "fld1\n\t"
        "fld  %1\n\t"
        "fyl2x\n\t"
        "fstp %0\n\t"
        : "=m"(result) : "m"(x)
    );
    return result;
}

#define MIN(a, b) ({ __typeof__(a) _a = (a); __typeof__(b) _b = (b); _a < _b ? _a : _b; })
#define MAX(a, b) ({ __typeof__(a) _a = (a); __typeof__(b) _b = (b); _a > _b ? _a : _b; })

#define ALIGN_UP(x, align)   (((x) + (align) - 1) & ~((align) - 1))
#define ALIGN_DOWN(x, align) ((x) & ~((align) - 1))

#define IS_POWER_OF_TWO(x) ((x) != 0 && (((x) & ((x) - 1)) == 0))

#define INFINITY (1.0/0.0)
#define NAN (0.0/0.0)

#endif


================================================================================
 FILE: ./libc/include/stdio.h
================================================================================


#ifndef _STDIO_H
#define _STDIO_H

#include <stdarg.h>
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

#define EOF (-1)
#define MAX_SCROLL_LINES 1000

int putchar(int c);
int puts(const char *str);
int printf(const char *format, ...);

int sprintf (char* restrict buf, const char* restrict fmt, ...);
int snprintf(char* restrict buf, size_t size, const char* restrict fmt, ...);
int vsprintf (char* restrict buf, const char* restrict fmt, va_list ap);
int vsnprintf(char* restrict buf, size_t size, const char* restrict fmt, va_list ap);

int vprintf(const char* restrict fmt, va_list ap);

extern uint32_t cursor_x;
extern uint32_t cursor_y;

extern uint32_t text_color;
extern uint32_t bg_color;

void scroll_screen(int lines);
uint32_t get_screen_width(void);
uint32_t get_screen_height(void);

void set_cursor_position(uint32_t x, uint32_t y);
void set_text_color(uint32_t color);
void clear_screen(void);
void scroll_up(int lines);

#endif


================================================================================
 FILE: ./libc/include/stdlib.h
================================================================================


#ifndef _STDLIB_H
#define _STDLIB_H

#include <stddef.h>
#include <math.h>

char* itoa(int val, char* restrict str, int base);

long          strtol (const char* restrict s, char** restrict end, int base);
unsigned long strtoul(const char* restrict s, char** restrict end, int base);

static inline int  atoi(const char* s) { return (int)strtol(s, (char**)0, 10); }
static inline long atol(const char* s) {      return strtol(s, (char**)0, 10); }

void  malloc_init(void);
void* malloc (size_t size);
void* calloc (size_t nmemb, size_t size);
void* realloc(void* ptr, size_t size);
void  free (void* ptr);
void* aligned_alloc(size_t alignment, size_t size);
void  aligned_free (void* ptr);

static inline void abort(void) {
    __asm__ volatile ("cli; hlt");
    __builtin_unreachable();
}

#endif


================================================================================
 FILE: ./libc/include/string.h
================================================================================


#ifndef _STRING_H
#define _STRING_H

#include <stddef.h>
#include <stdint.h>

void* memcpy (void* restrict dst, const void* restrict src, size_t n);
void* memmove(void* dst, const void* src, size_t n);
void* memset (void* dst, int c, size_t n);
int   memcmp (const void* a, const void* b, size_t n);
void *memchr(void *p, int val, size_t n);
void *rawmemchr(void *p, int c);

void* memset_explicit(void* dst, int c, size_t n);

size_t strlen (const char* s);
size_t strnlen(const char* s, size_t maxlen);

char *strcpy(char *dest, const char *src);
char *strncpy(char *dest, const char *src, size_t n);

char *strcat(char *dest, const char *src);
char* strncat(char* restrict dst, const char* restrict src, size_t n);

int strcmp (const char* a, const char* b);
int strncmp(const char* a, const char* b, size_t n);

char* strchr (const char* s, int c);
char* strrchr(const char* s, int c);
char* strstr (const char* haystack, const char* needle);
char* strpbrk(const char* s, const char* accept);
size_t strspn (const char* s, const char* accept);
size_t strcspn(const char* s, const char* reject);
char *strtok(char *str, const char *delim);

long strtol (const char* restrict s, char** restrict end, int base);
unsigned long strtoul(const char* restrict s, char** restrict end, int base);

char* strdup(const char* s);

static inline void bzero(void* s, size_t n) {
    memset(s, 0, n);
}

#endif


================================================================================
 FILE: ./libc/src/ctype/isalnum.c
================================================================================


#include <ctype.h>

int isalnum(int c) {
    return (c >= '0' && c <= '9') ||
        (c >= 'A' && c <= 'Z') ||
        (c >= 'a' && c <= 'z');
}



================================================================================
 FILE: ./libc/src/ctype/isalpha.c
================================================================================


#include <ctype.h>

int isalpha(int c) {
    return (c >= 'A' && c <= 'Z') ||
        (c >= 'a' && c <= 'z');
}



================================================================================
 FILE: ./libc/src/ctype/isblank.c
================================================================================


#include <ctype.h>

int isblank(int c) {
    return c == ' ' || c == '\t';
}



================================================================================
 FILE: ./libc/src/ctype/iscntrl.c
================================================================================


#include <ctype.h>

int iscntrl(int c) {
    return c == '\n' || c == '\t' ||
        c == '\r' || c == '\b' ||
        c == '\f' || c == '\a' || 
        c == '\0';
}



================================================================================
 FILE: ./libc/src/ctype/isdigit.c
================================================================================


#include <ctype.h>

int isdigit(int c) {
    return c >= '0' && c <= '9';
}


================================================================================
 FILE: ./libc/src/ctype/isgraph.c
================================================================================


#include <ctype.h>

int isgraph(int c) {
    return c >= 33 && c <= 126;
}



================================================================================
 FILE: ./libc/src/ctype/islower.c
================================================================================


#include <ctype.h>

int islower(int c) {
    return c >= 'a' && c <= 'z';
}


================================================================================
 FILE: ./libc/src/ctype/isprint.c
================================================================================


#include <ctype.h>

int isprint(int c) {
    return c >= 32 && c <= 126;
}


================================================================================
 FILE: ./libc/src/ctype/ispunct.c
================================================================================


#include <ctype.h>

int ispunct(int c) {
    return (c >= 33 && c <= 47) ||
        (c >= 58 && c <= 64) ||
        (c >= 91 && c <= 96) ||
        (c >= 123 && c <= 126);
}



================================================================================
 FILE: ./libc/src/ctype/isspace.c
================================================================================


#include <ctype.h>

int isspace(int c) {
    return c == ' ' || c == '\t' || c == '\n' ||
        c == '\v' || c == '\f' || c == '\r';
}



================================================================================
 FILE: ./libc/src/ctype/isupper.c
================================================================================


#include <ctype.h>

int isupper(int c) {
    return c >= 'A' && c <= 'Z';
}



================================================================================
 FILE: ./libc/src/ctype/isxdigit.c
================================================================================


#include <ctype.h>

int isxdigit(int c) {
    return (c >= '0' && c <= '9') ||
       (c >= 'A' && c <= 'F') ||
       (c >= 'a' && c <= 'f');
}



================================================================================
 FILE: ./libc/src/ctype/tolower.c
================================================================================


#include <ctype.h>

int tolower(int c) {
    if (!isalpha(c))
        return c;

    return c + ('a' - 'A');
}



================================================================================
 FILE: ./libc/src/ctype/toupper.c
================================================================================


#include <ctype.h>

int toupper(int c) {
    if (!isalpha(c))
        return c;

    return c - ('a' - 'A');
}



================================================================================
 FILE: ./libc/src/math/abs.c
================================================================================


#include <math.h>

int abs(int n) {
    return n >= 0 ? n : -n;
}



================================================================================
 FILE: ./libc/src/math/fabs.c
================================================================================


#include <math.h>
#include <stdint.h>

double fabs(double x) {
    union {
        double d;
        uint64_t i;
    } u = { .d = x };
    
    u.i &= 0x7FFFFFFFFFFFFFFFULL;
    return u.d;
}


================================================================================
 FILE: ./libc/src/math/isinf.c
================================================================================


#include <math.h>
#include <stdint.h>

int isinf(double x) {
    union {
        double f;
        uint64_t i;
    } u = { .f = x };

    uint64_t exp = (u.i >> 52) & 0x7FF;
    uint64_t mantissa = u.i & 0xFFFFFFFFFFFFFULL;

    return (exp == 0x7FF) && (mantissa == 0);
}


================================================================================
 FILE: ./libc/src/math/isnan.c
================================================================================


#include <math.h>
#include <stdint.h>

int isnan(double x) {
    union {
        double f;
        uint64_t i;
    } u = { .f = x };

    uint64_t exp = (u.i >> 52) & 0x7FF;
    uint64_t mantissa = u.i & 0xFFFFFFFFFFFFFULL;

    return (exp == 0x7FF) && (mantissa != 0);
}


================================================================================
 FILE: ./libc/src/math/pow.c
================================================================================


#include <math.h>

double pow(double x, double y) {
    if (y == 0.0) return 1.0;
    
    if (y == (int)y) {
        int n = (int)y;
        double result = 1.0;
        
        if (n > 0) {
            for (int i = 0; i < n; i++) {
                result *= x;
            }
        } else {
            for (int i = 0; i < -n; i++) {
                result /= x;
            }
        }
        
        return result;
    }
    
    if (x > 0.0) {
        int int_part = (int)y;
        double frac_part = y - int_part;
        
        double int_pow = pow(x, int_part);
        
        if (frac_part > 0.0) {
            return int_pow * (1.0 + frac_part * (x - 1.0));
        } else {
            return int_pow / (1.0 - frac_part * (x - 1.0));
        }
    }
    
    return NAN;
}


================================================================================
 FILE: ./libc/src/math/pow10.c
================================================================================


#include <math.h>

double pow10(int n) {
    double result = 1.0;
    
    if (n >= 0) {
        for (int i = 0; i < n; i++) {
            result *= 10.0;
        }
    } else {
        for (int i = 0; i < -n; i++) {
            result /= 10.0;
        }
    }
    
    return result;
}


================================================================================
 FILE: ./libc/src/stdio/printf.c
================================================================================


#include <stdio.h>
#include <stdarg.h>

int printf(const char *format, ...) {
    va_list args;
    va_start(args, format);
    int n = vprintf(format, args);
    return n;
}


================================================================================
 FILE: ./libc/src/stdio/putchar.c
================================================================================


#include <stdio.h>
#include <string.h>
#include "../../../kernel/include/graphics/fb/fb.h"

uint32_t cursor_x = 0;
uint32_t cursor_y = 0;
uint32_t text_color = COLOR_WHITE;
uint32_t bg_color = COLOR_BLACK;

extern struct limine_framebuffer *global_framebuffer;

static int scroll_buffer_index = 0;
static int total_scroll_lines = 0;

uint32_t get_screen_width(void) {
    if (!global_framebuffer) return 1024;
    return global_framebuffer->width;
}

uint32_t get_screen_height(void) {
    if (!global_framebuffer) return 768;
    return global_framebuffer->height;
}

void scroll_screen(int lines) {
    if (!global_framebuffer || lines <= 0) return;
    
    uint32_t screen_width = get_screen_width();
    uint32_t screen_height = get_screen_height();
    uint32_t scroll_pixels = (uint32_t)(lines * 16);
    
    uint32_t *fb_ptr = (uint32_t *)global_framebuffer->address;
    uint32_t pitch = global_framebuffer->pitch / 4;
    
    for (uint32_t y = scroll_pixels; y < screen_height; y++) {
        uint32_t *src_row = fb_ptr + y * pitch;
        uint32_t *dst_row = fb_ptr + (y - scroll_pixels) * pitch;
        memcpy(dst_row, src_row, screen_width * sizeof(uint32_t));
    }
    
    for (uint32_t y = screen_height - scroll_pixels; y < screen_height; y++) {
        for (uint32_t x = 0; x < screen_width; x++) {
            fb_draw_pixel(global_framebuffer, x, y, bg_color);
        }
    }
}

int putchar(int c) {
    if (!global_framebuffer) {
        return EOF;
    }
    
    uint32_t screen_width = get_screen_width();
    uint32_t screen_height = get_screen_height();
    uint32_t char_width = 8;
    uint32_t char_height = 16;
    
    switch (c) {
        case '\n': 
            cursor_x = 0;
            cursor_y += char_height; 
            break;
            
        case '\r': 
            cursor_x = 0;
            break;
            
        case '\t': 
            cursor_x = (cursor_x + 32) & ~31; 
            break;
            
        case '\b': 
            if (cursor_x >= char_width) {
                cursor_x -= char_width;
                fb_draw_char(global_framebuffer, ' ', cursor_x, cursor_y, text_color);
            }
            break;
            
        default: 
            if ((uint8_t)c >= 32 && (uint8_t)c <= 126) { 
                fb_draw_char(global_framebuffer, (char)c, cursor_x, cursor_y, text_color);
                cursor_x += char_width; 
            }
            break;
    }
    
    if (cursor_x + char_width > screen_width) {
        cursor_x = 0;
        cursor_y += char_height;
    }
    
    if (cursor_y + char_height > screen_height) {
        int overflow_pixels = (int)((cursor_y + char_height) - screen_height);
        int lines_to_scroll = (overflow_pixels + (int)char_height - 1) / (int)char_height;
        
        scroll_screen(lines_to_scroll);
        cursor_y = screen_height - char_height;
        
        for (uint32_t x = 0; x < screen_width; x += char_width) {
            fb_draw_char(global_framebuffer, ' ', x, cursor_y, text_color);
        }
    }
    
    return (unsigned char)c;
}

void clear_screen_with_scroll(void) {
    if (global_framebuffer) {
        fb_clear(global_framebuffer, bg_color);
        cursor_x = 0;
        cursor_y = 0;
        scroll_buffer_index = 0;
        total_scroll_lines = 0;
    }
}

void get_cursor_position(uint32_t *x, uint32_t *y) {
    if (x) *x = cursor_x;
    if (y) *y = cursor_y;
}


================================================================================
 FILE: ./libc/src/stdio/puts.c
================================================================================


#include <stdio.h>
#include <string.h>

int puts(const char *str) {
    int count = 0;
    
    if (!str) {
        const char *null_str = "(null)";
        while (*null_str) {
            putchar(*null_str++);
            count++;
        }
        putchar('\n');
        count++;
        return count;
    }
    
    while (*str) {
        putchar(*str++);
        count++;
    }
    
    putchar('\n');
    count++;
    
    return count;
}


================================================================================
 FILE: ./libc/src/stdio/screen.c
================================================================================


#include <stdio.h>
#include "../../../kernel/include/graphics/fb/fb.h"

extern struct limine_framebuffer *global_framebuffer;

void set_cursor_position(uint32_t x, uint32_t y) {
    cursor_x = x;
    cursor_y = y;
}

void set_text_color(uint32_t color) {
    text_color = color;
}

void set_background_color(uint32_t color) {
    bg_color = color;
}

void clear_screen(void) {
    if (global_framebuffer) {
        fb_clear(global_framebuffer, bg_color);
        cursor_x = 0;
        cursor_y = 0;
    }
}

void scroll_up(int lines) {
    if (lines <= 0) return;
    
    scroll_screen(lines);
    
    uint32_t scroll_pixels = (uint32_t)(lines * 16);
    if (cursor_y >= scroll_pixels) {
        cursor_y -= scroll_pixels;
    } else {
        cursor_y = 0;
    }
}


================================================================================
 FILE: ./libc/src/stdio/snprintf.c
================================================================================


#include <stdio.h>
#include <stdarg.h>
#include <stddef.h>
#include <string.h>

typedef struct {
    char*  buf;
    size_t pos;
    size_t size;
} snprintf_ctx_t;

static void ctx_putc(snprintf_ctx_t* ctx, char c) {
    if (ctx->pos + 1 < ctx->size)
        ctx->buf[ctx->pos] = c;
    ctx->pos++;
}

static void ctx_puts(snprintf_ctx_t* ctx, const char* s, int len) {
    for (int i = 0; i < len; i++) ctx_putc(ctx, s[i]);
}

static void write_uint_full(snprintf_ctx_t* ctx,
                             unsigned long long val, int base, int upper,
                             int width, int zero_pad, int left,
                             int alt, int show_sign, int space_sign,
                             char forced_sign) {
    const char* digs = upper ? "0123456789ABCDEF" : "0123456789abcdef";
    char tmp[72]; int len = 0;
    if (val == 0) { tmp[len++] = '0'; }
    else { while (val) { tmp[len++] = digs[val % (unsigned)base]; val /= (unsigned)base; } }

    char prefix[4]; int pfx = 0;
    if      (forced_sign)  prefix[pfx++] = forced_sign;
    else if (show_sign)    prefix[pfx++] = '+';
    else if (space_sign)   prefix[pfx++] = ' ';
    if (alt && base == 16) { prefix[pfx++] = '0'; prefix[pfx++] = upper ? 'X':'x'; }
    else if (alt && base == 8 && !(len==1 && tmp[0]=='0')) { prefix[pfx++] = '0'; }
    else if (alt && base == 2) { prefix[pfx++] = '0'; prefix[pfx++] = upper ? 'B':'b'; }

    int total = len + pfx;
    int pad   = (width > total) ? width - total : 0;

    if (!left && !zero_pad) { for (int i=0;i<pad;i++) ctx_putc(ctx,' '); }
    ctx_puts(ctx, prefix, pfx);
    if (!left &&  zero_pad) { for (int i=0;i<pad;i++) ctx_putc(ctx,'0'); }
    for (int i = len-1; i >= 0; i--) ctx_putc(ctx, tmp[i]);
    if ( left)              { for (int i=0;i<pad;i++) ctx_putc(ctx,' '); }
}

static void write_sint(snprintf_ctx_t* ctx, long long val,
                        int width, int zero_pad, int left,
                        int show_sign, int space_sign) {
    char sign = 0;
    unsigned long long uval;
    if (val < 0) { sign = '-'; uval = (unsigned long long)(-val); }
    else         { uval = (unsigned long long)val; }
    write_uint_full(ctx, uval, 10, 0, width, zero_pad, left,
                    0, show_sign, space_sign, sign);
}

static const unsigned long long pow10_tbl[18] = {
    1ULL, 10ULL, 100ULL, 1000ULL, 10000ULL, 100000ULL,
    1000000ULL, 10000000ULL, 100000000ULL, 1000000000ULL,
    10000000000ULL, 100000000000ULL, 1000000000000ULL,
    10000000000000ULL, 100000000000000ULL, 1000000000000000ULL,
    10000000000000000ULL, 100000000000000000ULL
};

static int ilog10(double val) {
    int e = 0;
    if (val >= 1.0) {
        if (val >= 1e16) { val /= 1e16; e += 16; }
        if (val >= 1e8)  { val /= 1e8;  e += 8;  }
        if (val >= 1e4)  { val /= 1e4;  e += 4;  }
        if (val >= 1e2)  { val /= 1e2;  e += 2;  }
        if (val >= 1e1)  { val /= 1e1;  e += 1;  }
    } else {
        if (val < 1e-15) { val *= 1e16; e -= 16; }
        if (val < 1e-7)  { val *= 1e8;  e -= 8;  }
        if (val < 1e-3)  { val *= 1e4;  e -= 4;  }
        if (val < 1e-1)  { val *= 1e2;  e -= 2;  }
        if (val < 1e0)   { val *= 1e1;  e -= 1;  }
    }
    (void)val;
    return e;
}

static int double_to_str(char* buf, double val, char fmt_char, int precision,
                          int show_sign, int space_sign, int alt, int is_neg) {
    if (precision < 0)  precision = 6;
    if (precision > 17) precision = 17;

    int upper = (fmt_char == 'F' || fmt_char == 'E' || fmt_char == 'G');
    int i = 0;

    if      (is_neg)     buf[i++] = '-';
    else if (show_sign)  buf[i++] = '+';
    else if (space_sign) buf[i++] = ' ';

    int exp10 = (val != 0.0) ? ilog10(val) : 0;

    int use_exp;
    if (fmt_char == 'e' || fmt_char == 'E') {
        use_exp = 1;
    } else if (fmt_char == 'g' || fmt_char == 'G') {
        int eff = (precision == 0) ? 1 : precision;
        use_exp = (exp10 < -4 || exp10 >= eff);
        precision = use_exp ? (eff - 1) : (eff - 1 - exp10);
        if (precision < 0)  precision = 0;
        if (precision > 17) precision = 17;
    } else {
        use_exp = (exp10 > 15 || (val != 0.0 && exp10 < -17));
        if (use_exp) { fmt_char = upper ? 'E' : 'e'; upper = (fmt_char == 'E'); }
    }

    double src = val;
    if (use_exp && val != 0.0) {
        int e = exp10;
        if (e > 0 && e <= 17)       src /= (double)pow10_tbl[e];
        else if (e > 17)            { src /= (double)pow10_tbl[17]; src /= (double)pow10_tbl[e - 17 < 17 ? e-17 : 17]; }
        else if (e < 0 && -e <= 17) src *= (double)pow10_tbl[-e];
        else if (e < -17)           { src *= (double)pow10_tbl[17]; src *= (double)pow10_tbl[-e-17 < 17 ? -e-17 : 17]; }
        if (src >= 10.0) { src /= 10.0; exp10++; }
        if (src <  1.0 && src != 0.0) { src *= 10.0; exp10--; }
    }

    unsigned long long scale    = pow10_tbl[precision];
    double             scaled_d = src * (double)scale + 0.5;
    if (scaled_d >= 1.8e19) scaled_d = 1.8e19 - 1.0;
    unsigned long long iscaled   = (unsigned long long)scaled_d;
    unsigned long long int_part  = iscaled / scale;
    unsigned long long frac_part = iscaled % scale;

    if (use_exp && int_part >= 10) { int_part = 1; frac_part = 0; exp10++; }

    {
        char itmp[24]; int ilen = 0;
        unsigned long long ip = int_part;
        if (ip == 0) itmp[ilen++] = '0';
        else while (ip) { itmp[ilen++] = '0' + (int)(ip % 10); ip /= 10; }
        for (int j = ilen-1; j >= 0; j--) buf[i++] = itmp[j];
    }

    if (precision > 0 || alt) {
        char ftmp[20];
        unsigned long long fp2 = frac_part;
        for (int k = precision - 1; k >= 0; k--) {
            ftmp[k] = '0' + (int)(fp2 % 10);
            fp2 /= 10;
        }
        int fend = precision;
        if ((fmt_char == 'g' || fmt_char == 'G') && !alt) {
            while (fend > 0 && ftmp[fend-1] == '0') fend--;
        }
        if (fend > 0 || alt) {
            buf[i++] = '.';
            for (int k = 0; k < fend; k++) buf[i++] = ftmp[k];
        }
    }

    if (use_exp) {
        buf[i++] = upper ? 'E' : 'e';
        int ae = exp10 < 0 ? -exp10 : exp10;
        buf[i++] = exp10 < 0 ? '-' : '+';
        if (ae >= 100) buf[i++] = '0' + ae / 100;
        buf[i++] = '0' + (ae / 10) % 10;
        buf[i++] = '0' + ae % 10;
    }

    return i;
}

static void write_float(snprintf_ctx_t* ctx, double val, char fmt_char,
                         int precision, int width, int zero_pad, int left,
                         int show_sign, int space_sign, int alt) {
    char tmp[64]; int len;
    int upper = (fmt_char == 'F' || fmt_char == 'E' || fmt_char == 'G');

    if (val != val) {
        const char* s = upper ? "NAN" : "nan";
        len = 3; tmp[0]=s[0]; tmp[1]=s[1]; tmp[2]=s[2];
    } else {
        int is_neg = 0;
        if (val < 0.0) { is_neg = 1; val = -val; }
        if (val > 1.7976931348623157e+308) {
            len = 0;
            if      (is_neg)     tmp[len++] = '-';
            else if (show_sign)  tmp[len++] = '+';
            else if (space_sign) tmp[len++] = ' ';
            const char* s = upper ? "INF" : "inf";
            tmp[len++]=s[0]; tmp[len++]=s[1]; tmp[len++]=s[2];
        } else {
            len = double_to_str(tmp, val, fmt_char, precision,
                                show_sign, space_sign, alt, is_neg);
        }
    }

    int has_sign = (tmp[0]=='-' || tmp[0]=='+' || tmp[0]==' ');
    int pad = (width > len) ? width - len : 0;
    if (!left && !zero_pad) { for (int j=0;j<pad;j++) ctx_putc(ctx,' '); }
    if (!left &&  zero_pad) {
        if (has_sign) ctx_putc(ctx, tmp[0]);
        for (int j=0;j<pad;j++) ctx_putc(ctx,'0');
        ctx_puts(ctx, tmp + has_sign, len - has_sign);
    } else {
        ctx_puts(ctx, tmp, len);
    }
    if (left) { for (int j=0;j<pad;j++) ctx_putc(ctx,' '); }
}

int vsnprintf(char* restrict buf, size_t size, const char* restrict fmt,
              va_list ap) {
    snprintf_ctx_t ctx = { buf, 0, size ? size : 1 };

    for (; *fmt; fmt++) {
        if (*fmt != '%') { ctx_putc(&ctx, *fmt); continue; }
        fmt++;
        if (!*fmt) break;

        int left=0, zero_pad=0, alt=0, show_sign=0, space_sign=0;
        for (;;) {
            if      (*fmt=='-') { left=1;       fmt++; }
            else if (*fmt=='0') { zero_pad=1;   fmt++; }
            else if (*fmt=='#') { alt=1;        fmt++; }
            else if (*fmt=='+') { show_sign=1;  fmt++; }
            else if (*fmt==' ') { space_sign=1; fmt++; }
            else break;
        }

        int width = 0;
        if (*fmt == '*') {
            width = va_arg(ap, int);
            if (width < 0) { left = 1; width = -width; }
            fmt++;
        } else {
            while (*fmt >= '0' && *fmt <= '9') width = width*10 + (*fmt++ - '0');
        }

        int precision=-1, has_prec=0;
        if (*fmt == '.') {
            has_prec=1; precision=0; fmt++;
            if (*fmt == '*') {
                precision = va_arg(ap, int);
                if (precision < 0) { has_prec=0; precision=-1; }
                fmt++;
            } else {
                while (*fmt >= '0' && *fmt <= '9')
                    precision = precision*10 + (*fmt++ - '0');
            }
        }

        int is_hh=0,is_h=0,is_l=0,is_ll=0,is_z=0;
        if (*fmt=='h') {
            fmt++;
            if (*fmt=='h') { is_hh=1; fmt++; } else is_h=1;
        } else if (*fmt=='l') {
            is_l=1; fmt++;
            if (*fmt=='l') { is_ll=1; fmt++; }
        } else if (*fmt=='z') { is_z=1; fmt++; }
          else if (*fmt=='t') { is_l=1; fmt++; }
          else if (*fmt=='L') { fmt++; }

        if (!*fmt) break;

        switch (*fmt) {
        case 'd': case 'i': {
            long long v;
            if      (is_ll) v = va_arg(ap, long long);
            else if (is_l)  v = va_arg(ap, long);
            else if (is_hh) v = (signed char) va_arg(ap, int);
            else if (is_h)  v = (short)       va_arg(ap, int);
            else if (is_z)  v = (long long)   va_arg(ap, size_t);
            else            v = va_arg(ap, int);
            write_sint(&ctx, v, width, zero_pad, left, show_sign, space_sign);
            break;
        }
        case 'u': {
            unsigned long long v;
            if      (is_ll) v = va_arg(ap, unsigned long long);
            else if (is_l)  v = va_arg(ap, unsigned long);
            else if (is_hh) v = (unsigned char) va_arg(ap, unsigned int);
            else if (is_h)  v = (unsigned short)va_arg(ap, unsigned int);
            else if (is_z)  v = va_arg(ap, size_t);
            else            v = va_arg(ap, unsigned int);
            write_uint_full(&ctx,v,10,0,width,zero_pad,left,0,show_sign,space_sign,0);
            break;
        }
        case 'o': {
            unsigned long long v;
            if      (is_ll) v = va_arg(ap, unsigned long long);
            else if (is_l)  v = va_arg(ap, unsigned long);
            else            v = va_arg(ap, unsigned int);
            write_uint_full(&ctx,v,8,0,width,zero_pad,left,alt,0,0,0);
            break;
        }
        case 'x': case 'X': {
            unsigned long long v;
            if      (is_ll) v = va_arg(ap, unsigned long long);
            else if (is_l)  v = va_arg(ap, unsigned long);
            else            v = va_arg(ap, unsigned int);
            write_uint_full(&ctx,v,16,(*fmt=='X'),width,zero_pad,left,alt,0,0,0);
            break;
        }
        case 'b': case 'B': {
            unsigned long long v;
            if      (is_ll) v = va_arg(ap, unsigned long long);
            else if (is_l)  v = va_arg(ap, unsigned long);
            else            v = va_arg(ap, unsigned int);
            write_uint_full(&ctx,v,2,(*fmt=='B'),width,zero_pad,left,alt,0,0,0);
            break;
        }
        case 'p': {
            uintptr_t v = (uintptr_t)va_arg(ap, void*);
            ctx_putc(&ctx,'0'); ctx_putc(&ctx,'x');
            write_uint_full(&ctx,(unsigned long long)v,16,0,width,1,left,0,0,0,0);
            break;
        }
        case 'f': case 'F':
        case 'e': case 'E':
        case 'g': case 'G': {
            double v = va_arg(ap, double);
            write_float(&ctx, v, *fmt,
                        has_prec ? precision : 6,
                        width, zero_pad, left, show_sign, space_sign, alt);
            break;
        }
        case 's': {
            const char* s = va_arg(ap, const char*);
            if (!s) s = "(null)";
            int slen = (int)strlen(s);
            if (has_prec && precision < slen) slen = precision;
            int pad = (width > slen) ? width - slen : 0;
            if (!left) { for (int j=0;j<pad;j++) ctx_putc(&ctx,' '); }
            ctx_puts(&ctx, s, slen);
            if ( left) { for (int j=0;j<pad;j++) ctx_putc(&ctx,' '); }
            break;
        }
        case 'c': {
            char c = (char)va_arg(ap, int);
            int pad = (width > 1) ? width - 1 : 0;
            if (!left) { for (int j=0;j<pad;j++) ctx_putc(&ctx,' '); }
            ctx_putc(&ctx, c);
            if ( left) { for (int j=0;j<pad;j++) ctx_putc(&ctx,' '); }
            break;
        }
        case 'n': {
            int* p = va_arg(ap, int*);
            if (p) *p = (int)ctx.pos;
            break;
        }
        case '%': ctx_putc(&ctx,'%'); break;
        default:  ctx_putc(&ctx,'%'); ctx_putc(&ctx,*fmt); break;
        }
    }

    if (size > 0) buf[ctx.pos < size ? ctx.pos : size-1] = '\0';
    return (int)ctx.pos;
}

int vprintf(const char* restrict fmt, va_list ap) {
    char buf[1024];
    int n = vsnprintf(buf, sizeof(buf), fmt, ap);
    for (int i = 0; i < n && buf[i]; i++) putchar(buf[i]);
    return n;
}

int vsprintf(char* restrict buf, const char* restrict fmt, va_list ap) {
    return vsnprintf(buf, (size_t)-1, fmt, ap);
}

int snprintf(char* restrict buf, size_t size, const char* restrict fmt, ...) {
    va_list ap; va_start(ap, fmt);
    int n = vsnprintf(buf, size, fmt, ap);
    va_end(ap); return n;
}

int sprintf(char* restrict buf, const char* restrict fmt, ...) {
    va_list ap; va_start(ap, fmt);
    int n = vsnprintf(buf, (size_t)-1, fmt, ap);
    va_end(ap); return n;
}


================================================================================
 FILE: ./libc/src/stdlib/aligned_alloc.c
================================================================================


#include <stdlib.h>
#include <stdint.h>

void *aligned_alloc(size_t alignment, size_t size) {
    if (size == 0) return NULL;
    if (alignment == 0 || (alignment & (alignment - 1))) return NULL;
    if (alignment < 16) alignment = 16;

    void *raw = malloc(size + alignment + sizeof(void *));
    if (!raw) return NULL;

    uintptr_t addr    = (uintptr_t)raw + sizeof(void *);
    uintptr_t aligned = (addr + alignment - 1) & ~(alignment - 1);

    ((void **)aligned)[-1] = raw;

    return (void *)aligned;
}


================================================================================
 FILE: ./libc/src/stdlib/aligned_free.c
================================================================================


#include <stdlib.h>

void aligned_free(void* ptr) {
    if (!ptr) return;
    void* raw = ((void**)ptr)[-1];
    free(raw);
}


================================================================================
 FILE: ./libc/src/stdlib/calloc.c
================================================================================


#include <stdlib.h>
#include <string.h>

void *calloc(size_t nmemb, size_t size) {
    if (nmemb == 0 || size == 0) return NULL;
    if (nmemb > (size_t)-1 / size) return NULL;

    void *ptr = malloc(nmemb * size);
    if (ptr) memset(ptr, 0, nmemb * size);
    return ptr;
}


================================================================================
 FILE: ./libc/src/stdlib/free.c
================================================================================


#include <stdlib.h>
#include "heap.h"
#include "../../../kernel/include/io/serial.h"

void free(void *ptr) {
    if (!ptr) return;

    heap_block_t *b = (heap_block_t *)ptr - 1;

    if (b->magic != HEAP_MAGIC) {
        serial_printf("[MALLOC ERROR] free() corrupt block at %p\n", ptr);
        return;
    }
    if (b->free) {
        serial_printf("[MALLOC WARNING] double-free at %p\n", ptr);
        return;
    }

    if (b->large) {
        size_t pages = _heap_align_up(sizeof(heap_block_t) + b->size, PAGE_SIZE) / PAGE_SIZE;
        pmm_free(b, pages);
        return;
    }

    b->free = true;
    size_t idx = _heap_bin_of(b->size);
    b->next_free    = _heap_bins[idx];
    _heap_bins[idx] = b;
}


================================================================================
 FILE: ./libc/src/stdlib/heap.h
================================================================================


#ifndef _HEAP_H
#define _HEAP_H

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include "../../../kernel/include/memory/pmm.h"

#define HEAP_MAGIC            0xDEADBEEFCAFEBABEULL
#define HEAP_ALIGNMENT        16
#define HEAP_BIN_COUNT        32
#define HEAP_LARGE_THRESHOLD  (PAGE_SIZE * 4)

typedef struct heap_block {
    size_t             size;
    size_t             magic;
    struct heap_block *next_free;
    bool               free;
    bool               large;
    uint8_t            _pad[6];
} heap_block_t;

_Static_assert(sizeof(heap_block_t) == 32, "heap_block_t must be 32 bytes");

extern heap_block_t *_heap_bins[HEAP_BIN_COUNT];
extern bool          _heap_ready;

static inline size_t _heap_align_up(size_t v, size_t a) {
    return (v + a - 1) & ~(a - 1);
}

static inline size_t _heap_bin_of(size_t size) {
    size_t i = 0;
    while (size > 1 && i < HEAP_BIN_COUNT -1) {
        size >>= 1;
        i++;
    }
    return i;
}

#endif


================================================================================
 FILE: ./libc/src/stdlib/itoa.c
================================================================================


#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

char *itoa(int val, char *restrict str, int base) {
    int i = 0;
    bool negative = false;

    if (val == 0) {
        str[i++] = '0';
        str[i] = '\0';
        return str;
    }

    if (val < 0 && base == 10) {
        negative = true;
        val = -val;
    }

    while (val != 0) {
        int rem = val % base;
        str[i++] = (rem > 9) ? (rem - 10) + 'a' : rem + '0';
        val = val / base;
    }

    if (negative)
        str[i++] = '-';

    str[i] = '\0';

    int start = 0, end = strlen(str) - 1;
    while (start < end) {
        char temp = str[start];
        str[start] = str[end];
        str[end] = temp;
        end--;
        start++;
    }

    return str;
}



================================================================================
 FILE: ./libc/src/stdlib/malloc.c
================================================================================


#include <stdlib.h>
#include "heap.h"
#include "../../../kernel/include/io/serial.h"

static heap_block_t *find_free(size_t size) {
    for (size_t i = _heap_bin_of(size); i < HEAP_BIN_COUNT; i++) {
        heap_block_t **p = &_heap_bins[i];
        heap_block_t  *b =  _heap_bins[i];
        while (b) {
            if (b->size >= size) {
                *p = b->next_free;
                b->next_free = NULL;
                b->free = false;
                return b;
            }
            p = &b->next_free;
            b =  b->next_free;
        }
    }
    return NULL;
}

void *malloc(size_t size) {
    if (!_heap_ready) malloc_init();
    if (size == 0) return NULL;

    size = _heap_align_up(size, HEAP_ALIGNMENT);

    if (size > HEAP_LARGE_THRESHOLD) {
        size_t pages = _heap_align_up(sizeof(heap_block_t) + size, PAGE_SIZE) / PAGE_SIZE;
        heap_block_t *b = (heap_block_t *)pmm_alloc_zero(pages);
        if (!b) return NULL;
        b->size      = pages * PAGE_SIZE - sizeof(heap_block_t);
        b->magic     = HEAP_MAGIC;
        b->next_free = NULL;
        b->free      = false;
        b->large     = true;
        return (void *)(b + 1);
    }

    heap_block_t *b = find_free(size);
    if (b) return (void *)(b + 1);

    size_t pages = _heap_align_up(sizeof(heap_block_t) + size, PAGE_SIZE) / PAGE_SIZE;
    b = (heap_block_t *)pmm_alloc_zero(pages);
    if (!b) {
        serial_printf("[MALLOC] out of memory (size=%zu)\n", size);
        return NULL;
    }
    b->size      = pages * PAGE_SIZE - sizeof(heap_block_t);
    b->magic     = HEAP_MAGIC;
    b->next_free = NULL;
    b->free      = false;
    b->large     = false;
    return (void *)(b + 1);
}


================================================================================
 FILE: ./libc/src/stdlib/malloc_init.c
================================================================================


#include <stdlib.h>
#include "heap.h"
#include "../../../kernel/include/io/serial.h"

heap_block_t *_heap_bins[HEAP_BIN_COUNT];
bool          _heap_ready = false;

void malloc_init(void) {
    for (int i = 0; i < HEAP_BIN_COUNT; i++)
        _heap_bins[i] = NULL;
    _heap_ready = true;
    serial_printf("[MALLOC] heap initialized\n");
}


================================================================================
 FILE: ./libc/src/stdlib/realloc.c
================================================================================


#include <stdlib.h>
#include <string.h>
#include "heap.h"
#include "../../../kernel/include/io/serial.h"

void *realloc(void *ptr, size_t size) {
    if (!ptr)  return malloc(size);
    if (!size) { free(ptr); return NULL; }

    heap_block_t *b = (heap_block_t *)ptr - 1;
    if (b->magic != HEAP_MAGIC) {
        serial_printf("[MALLOC ERROR] realloc() corrupt block at %p\n", ptr);
        return NULL;
    }

    if (b->size >= _heap_align_up(size, HEAP_ALIGNMENT))
        return ptr;

    void *new_ptr = malloc(size);
    if (!new_ptr) return NULL;

    memcpy(new_ptr, ptr, b->size < size ? b->size : size);
    free(ptr);
    return new_ptr;
}


================================================================================
 FILE: ./libc/src/string/memchr.c
================================================================================


#include <string.h>

void *memchr(void *ptr, int val, size_t n) {
    const unsigned char *p = (const unsigned char*)ptr;
    unsigned char c = (unsigned char)val;
    for (size_t i = 0; i < n; i++) {
        if (p[i] == c)
            return (void*)(p + i);
    }

    return NULL;
}



================================================================================
 FILE: ./libc/src/string/memcmp.c
================================================================================


#include <string.h>

int memcmp(const void *s1, const void *s2, size_t n) {
    const uint8_t *p1 = (const uint8_t *)s1;
    const uint8_t *p2 = (const uint8_t *)s2;

    for (size_t i = 0; i < n; i++) {
        if (p1[i] != p2[i]) {
            return p1[i] < p2[i] ? -1 : 1;
        }
    }

    return 0;
}


================================================================================
 FILE: ./libc/src/string/memcpy.c
================================================================================


#include <string.h>

void *memcpy(void *restrict dest, const void *restrict src, size_t n) {
    uint8_t *restrict pdest = (uint8_t *restrict)dest;
    const uint8_t *restrict psrc = (const uint8_t *restrict)src;

    for (size_t i = 0; i < n; i++) {
        pdest[i] = psrc[i];
    }

    return dest;
}


================================================================================
 FILE: ./libc/src/string/memmove.c
================================================================================


#include <string.h>

void *memmove(void *dest, const void *src, size_t n) {
    uint8_t *pdest = (uint8_t *)dest;
    const uint8_t *psrc = (const uint8_t *)src;

    if (src > dest) {
        for (size_t i = 0; i < n; i++) {
            pdest[i] = psrc[i];
        }
    } else if (src < dest) {
        for (size_t i = n; i > 0; i--) {
            pdest[i-1] = psrc[i-1];
        }
    }

    return dest;
}


================================================================================
 FILE: ./libc/src/string/memset.c
================================================================================


#include <string.h>

void *memset(void *s, int c, size_t n) {
    uint8_t *p = (uint8_t *)s;

    for (size_t i = 0; i < n; i++) {
        p[i] = (uint8_t)c;
    }

    return s;
}


================================================================================
 FILE: ./libc/src/string/memset_explicit.c
================================================================================


#include <string.h>

void* memset_explicit(void* dst, int c, size_t n) {
    volatile unsigned char* p = (volatile unsigned char*)dst;
    while (n--) *p++ = (unsigned char)c;
    return dst;
}


================================================================================
 FILE: ./libc/src/string/rawmemchr.c
================================================================================


#include <string.h>

void *rawmemchr(void *ptr, int val) {
    const unsigned char *p = (const unsigned char*)ptr;
    unsigned char c = (unsigned char)val;
    for (;;) {
        if (*p == c)
            return (void*)p;
        p++;
    }
}



================================================================================
 FILE: ./libc/src/string/strcat.c
================================================================================


#include <string.h>

char *strcat(char *dest, const char *src) {
    char *ptr = dest;
    
    while (*ptr != '\0') {
        ptr++;
    }
    
    while (*src != '\0') {
        *ptr++ = *src++;
    }
    
    *ptr = '\0';
    
    return dest;
}


================================================================================
 FILE: ./libc/src/string/strchr.c
================================================================================


#include <string.h>

char *strchr(const char *str, int c) {
    char ch = (char)c;
    while (*str) {
        if (*str == ch)
            return (char*)str;

        str++;
    }

    if (ch == '\0')
        return (char*)str;

    return NULL;
}



================================================================================
 FILE: ./libc/src/string/strcmp.c
================================================================================


#include <string.h>

int strcmp(const char *str1, const char *str2) {
    size_t i = 0;
    while (str1[i] != '\0' && str2[i] != '\0') {
        if (str1[i] != str2[i])
            goto ret;

        i++;
    }
ret:
    return (unsigned char)str1[i] - (unsigned char)str2[i];
}



================================================================================
 FILE: ./libc/src/string/strcpy.c
================================================================================


#include <string.h>

char *strcpy(char *dest, const char *src) {
    char *p = dest;
    while ((*p++ = *src++) != '\0') { }
    return dest;
}



================================================================================
 FILE: ./libc/src/string/strcspn.c
================================================================================


#include <string.h>

size_t strcspn(const char* s, const char* reject) {
    size_t n = 0;
    while (s[n]) {
        for (const char* r = reject; *r; r++)
            if (s[n] == *r) return n;
        n++;
    }
    return n;
}


================================================================================
 FILE: ./libc/src/string/strdup.c
================================================================================


#include <string.h>
#include <stdlib.h>

char* strdup(const char* s) {
    size_t len = strlen(s) + 1;
    char* copy = malloc(len);
    if (copy) memcpy(copy, s, len);
    return copy;
}


================================================================================
 FILE: ./libc/src/string/strlen.c
================================================================================


#include <string.h>

size_t strlen(const char *str) {
    size_t len = 0;
    while (*str != '\0') {
        len++;
        str++;
    }

    return len;
}



================================================================================
 FILE: ./libc/src/string/strncat.c
================================================================================


#include <string.h>

char* strncat(char* restrict dst, const char* restrict src, size_t n) {
    char* d = dst + strlen(dst);
    while (n-- && *src)
        *d++ = *src++;
    *d = '\0';
    return dst;
}


================================================================================
 FILE: ./libc/src/string/strncmp.c
================================================================================


#include <string.h>

int strncmp(const char *str1, const char *str2, size_t n) {
    size_t i = 0;
    while (i < n) {
        unsigned char c1 = (unsigned char)str1[i], 
            c2 = (unsigned char)str2[i];
        if (c1 != c2)
            return c1 - c2;

        if (c1 == '\0') // значит и c2 также уже нуль
            return 0;

        i++;
    }

    return 0;
}



================================================================================
 FILE: ./libc/src/string/strncpy.c
================================================================================


#include <string.h>

char *strncpy(char *dest, const char *src, size_t n) {
    size_t i = 0;
    for (; i < n && src[i] != '\0'; i++)
        dest[i] = src[i];
    for (; i < n; i++)
        dest[i] = '\0';

    return dest;
}



================================================================================
 FILE: ./libc/src/string/strnlen.c
================================================================================


#include <string.h>

size_t strnlen(const char* s, size_t maxlen) {
    size_t n = 0;
    while (n < maxlen && s[n]) n++;
    return n;
}


================================================================================
 FILE: ./libc/src/string/strpbrk.c
================================================================================


#include <string.h>

char *strpbrk(const char *str1, const char *str2) {
    for (; *str1 != '\0'; str1++) {
        for (const char *p = str2; *p != '\0'; p++) {
            if (*str1 == *p)
                return (char*)str1;
        }
    }
    return NULL;
}



================================================================================
 FILE: ./libc/src/string/strrchr.c
================================================================================


#include <string.h>

char* strrchr(const char* s, int c) {
    const char* last = NULL;
    do {
        if (*s == (char)c) last = s;
    } while (*s++);
    return (char*)last;
}


================================================================================
 FILE: ./libc/src/string/strspn.c
================================================================================


#include <string.h>

size_t strspn(const char *str1, const char *str2) {
    size_t count = 0;
    while (*str1) {
        const char *p = str2;
        int found = 0;
        while (*p) {
            if (*str1 == *p) {
                found = 1;
                break;
            }
            p++;
        }

        if (!found)
            break;

        count++;
        str1++;
    }

    return count;
}



================================================================================
 FILE: ./libc/src/string/strstr.c
================================================================================


#include <string.h>

char *strstr(const char *haystack, const char *needle) {
    if (*needle == '\0')
        return (char*)haystack;

    for (size_t i = 0; haystack[i] != '\0'; i++) {
        size_t j = 0;
        while (needle[j] != '\0' && haystack[j + i] == needle[j])
            j++;

        if (needle[j] == '\0')
            return (char*)&haystack[i];
    }

    return NULL;
}



================================================================================
 FILE: ./libc/src/string/strtok.c
================================================================================


#include <string.h>

static char *old_string = NULL;

char *strtok(char *str, const char *delim) {
    if (str == NULL) str = old_string;
    str += strspn(str, delim);
    if (*str == '\0') {
        old_string = str;
        return NULL;
    }

    char *token = str;
    str = strpbrk(token, delim);
    if (str == NULL)
        old_string = rawmemchr(token, '\0');
    else {
        *str = '\0';
        old_string = str + 1;
    }
    return token;
}



================================================================================
 FILE: ./libc/src/string/strtol.c
================================================================================


#include <string.h>
#include <ctype.h>

long strtol(const char* restrict s, char** restrict end, int base) {
    while (isspace((unsigned char)*s)) s++;

    int neg = 0;
    if (*s == '-') { neg = 1; s++; }
    else if (*s == '+') { s++; }

    if ((base == 0 || base == 16) && s[0] == '0' &&
        (s[1] == 'x' || s[1] == 'X')) {
        base = 16;
        s += 2;
    } else if (base == 0 && s[0] == '0') {
        base = 8;
        s++;
    } else if (base == 0) {
        base = 10;
    }

    long result = 0;
    int any = 0;
    for (; *s; s++) {
        int digit;
        unsigned char c = (unsigned char)*s;
        if (isdigit(c))          digit = c - '0';
        else if (isupper(c))     digit = c - 'A' + 10;
        else if (islower(c))     digit = c - 'a' + 10;
        else break;

        if (digit >= base) break;
        result = result * base + digit;
        any = 1;
    }

    if (end) *end = (char*)(any ? s : (const char*)s);
    return neg ? -result : result;
}


================================================================================
 FILE: ./libc/src/string/strtoul.c
================================================================================


#include <string.h>
#include <ctype.h>

unsigned long strtoul(const char* restrict s, char** restrict end, int base) {
    while (isspace((unsigned char)*s)) s++;

    if (*s == '+') s++;

    if ((base == 0 || base == 16) && s[0] == '0' &&
        (s[1] == 'x' || s[1] == 'X')) {
        base = 16;
        s += 2;
    } else if (base == 0 && s[0] == '0') {
        base = 8;
        s++;
    } else if (base == 0) {
        base = 10;
    }

    unsigned long result = 0;
    int any = 0;
    for (; *s; s++) {
        int digit;
        unsigned char c = (unsigned char)*s;
        if (isdigit(c))          digit = c - '0';
        else if (isupper(c))     digit = c - 'A' + 10;
        else if (islower(c))     digit = c - 'a' + 10;
        else break;

        if (digit >= base) break;
        result = result * (unsigned long)base + (unsigned long)digit;
        any = 1;
    }

    if (end) *end = (char*)(any ? s : (const char*)s);
    return result;
}


================================================================================
 FILE: ./test/hello.c
================================================================================


static void serial_putc(char c) {
    unsigned char lsr;
    do {
        __asm__ volatile ("inb %1, %0" : "=a"(lsr) : "Nd"((unsigned short)0x3FD));
    } while (!(lsr & 0x20));

    __asm__ volatile ("outb %0, %1" :: "a"(c), "Nd"((unsigned short)0x3F8));
}

static void serial_print(const char* s) {
    while (*s) serial_putc(*s++);
}

void _start(void) {
    serial_print("[hello.elf] _start reached! ELF loader works!\n");

    unsigned long counter = 0;
    while (1) {
        __asm__ volatile ("pause");
        counter++;
        if (counter == 50000000UL) {
            serial_print("[hello.elf] still alive!\n");
            counter = 0;
        }
    }
}