OS Tree Structure - Cervus v0.0.1
Generated: 2025-12-08 22:09:48
================================================================================

Project Information:
- Name: Cervus
- Version: v0.0.1
- Base Directory: /home/veoqeo/Cervus
- Files included: All files
- Show contents: Yes

Directory Structure:
.
├── kernel/
│   ├── include/
│   │   ├── gdt/
│   │   │   ├── gdt.h (847 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #ifndef GDT_H
│   │   │   │     2: #define GDT_H
│   │   │   │     3: 
│   │   │   │     4: #include <stdint.h>
│   │   │   │     5: 
│   │   │   │     6: struct gdt_entry {
│   │   │   │     7:     uint16_t limit_low;
│   │   │   │     8:     uint16_t base_low;
│   │   │   │     9:     uint8_t base_middle;
│   │   │   │    10:     uint8_t access;
│   │   │   │    11:     uint8_t granularity;
│   │   │   │    12:     uint8_t base_high;
│   │   │   │    13: } __attribute__((packed));
│   │   │   │    14: 
│   │   │   │    15: struct gdt_ptr {
│   │   │   │    16:     uint16_t limit;
│   │   │   │    17:     uint64_t base;
│   │   │   │    18: } __attribute__((packed));
│   │   │   │    19: 
│   │   │   │    20: #define GDT_KERNEL_CS 0x08  
│   │   │   │    21: #define GDT_KERNEL_DS 0x10  
│   │   │   │    22: 
│   │   │   │    23: #define GDT_ACCESS_PRESENT     (1 << 7)
│   │   │   │    24: #define GDT_ACCESS_RING0       (0 << 5)
│   │   │   │    25: #define GDT_ACCESS_SEGMENT     (1 << 4)
│   │   │   │    26: #define GDT_ACCESS_EXECUTABLE  (1 << 3)
│   │   │   │    27: #define GDT_ACCESS_READ_WRITE  (1 << 1)
│   │   │   │    28: 
│   │   │   │    29: #define GDT_GRANULARITY_4K     (1 << 7)
│   │   │   │    30: #define GDT_GRANULARITY_LONG   (1 << 5)  // 64-bit mode
│   │   │   │    31: 
│   │   │   │    32: extern struct gdt_entry gdt[5];
│   │   │   │    33: extern struct gdt_ptr gdt_ptr;
│   │   │   │    34: 
│   │   │   │    35: void gdt_init(void);
│   │   │   │    36: void gdt_load(void);
│   │   │   │    37: const struct gdt_entry* gdt_get_descriptor(int index);
│   │   │   │    38: 
│   │   │   │    39: #endif 
│   │   ├── graphics/
│   │   │   ├── fb/
│   │   │   │   ├── fb.h (2.1 KB)

│   │   │   │   │   Contents:
│   │   │   │   │     1: #ifndef FB_H
│   │   │   │   │     2: #define FB_H
│   │   │   │   │     3: 
│   │   │   │   │     4: #include <stdint.h>
│   │   │   │   │     5: #include <stddef.h>
│   │   │   │   │     6: #include <limine.h>
│   │   │   │   │     7: 
│   │   │   │   │     8: #define RGB(r, g, b) (((r) << 16) | ((g) << 8) | (b))
│   │   │   │   │     9: 
│   │   │   │   │    10: #define COLOR_BLACK     RGB(  0,   0,   0)
│   │   │   │   │    11: #define COLOR_WHITE     RGB(255, 255, 255)
│   │   │   │   │    12: #define COLOR_RED       RGB(255,   0,   0)
│   │   │   │   │    13: #define COLOR_GREEN     RGB(  0, 255,   0)
│   │   │   │   │    14: #define COLOR_BLUE      RGB(  0,   0, 255)
│   │   │   │   │    15: #define COLOR_CYAN      RGB(  0, 255, 255)
│   │   │   │   │    16: #define COLOR_MAGENTA   RGB(255,   0, 255)
│   │   │   │   │    17: #define COLOR_YELLOW    RGB(255, 255,   0)
│   │   │   │   │    18: #define COLOR_ORANGE    RGB(255, 165,   0)
│   │   │   │   │    19: #define COLOR_GRAY      RGB(128, 128, 128)
│   │   │   │   │    20: #define COLOR_DARKGRAY  RGB( 64,  64,  64)
│   │   │   │   │    21: #define COLOR_BROWN     RGB(165,  42,  42)
│   │   │   │   │    22: 
│   │   │   │   │    23: // Структура заголовка PSFv2
│   │   │   │   │    24: struct psf_header {
│   │   │   │   │    25:     uint32_t magic;        // 0x72b54a86
│   │   │   │   │    26:     uint32_t version;      // 0
│   │   │   │   │    27:     uint32_t headersize;   // 32
│   │   │   │   │    28:     uint32_t flags;        // 0 или 1 (есть таблица Unicode)
│   │   │   │   │    29:     uint32_t numglyph;     // число глифов
│   │   │   │   │    30:     uint32_t bytesperglyph;// размер одного глифа
│   │   │   │   │    31:     uint32_t height;       // высота символа
│   │   │   │   │    32:     uint32_t width;        // ширина символа (обычно 8)
│   │   │   │   │    33: } __attribute__((packed));
│   │   │   │   │    34: 
│   │   │   │   │    35: extern uint8_t _binary_font_psf_start[];
│   │   │   │   │    36: extern uint8_t _binary_font_psf_end[];
│   │   │   │   │    37: 
│   │   │   │   │    38: static inline const uint8_t* get_font_data(void) {
│   │   │   │   │    39:     return (const uint8_t*)&_binary_font_psf_start;
│   │   │   │   │    40: }
│   │   │   │   │    41: static inline size_t get_font_data_size(void) {
│   │   │   │   │    42:     return _binary_font_psf_end - _binary_font_psf_start;
│   │   │   │   │    43: }
│   │   │   │   │    44: 
│   │   │   │   │    45: static inline const struct psf_header* get_psf_header(void) {
│   │   │   │   │    46:     return (const struct psf_header*)&_binary_font_psf_start;
│   │   │   │   │    47: }
│   │   │   │   │    48: 
│   │   │   │   │    49: int psf_validate(void);
│   │   │   │   │    50: void fb_draw_pixel(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t color);
│   │   │   │   │    51: void fb_fill_rect(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color);
│   │   │   │   │    52: void fb_clear(struct limine_framebuffer *fb, uint32_t color);
│   │   │   │   │    53: void fb_draw_char(struct limine_framebuffer *fb, char c, uint32_t x, uint32_t y, uint32_t color);
│   │   │   │   │    54: void fb_draw_string(struct limine_framebuffer *fb, const char *str, uint32_t x, uint32_t y, uint32_t color);
│   │   │   │   │    55: 
│   │   │   │   │    56: #endif 
│   │   │   ├── geometry/
│   │   ├── io/
│   │   │   ├── ports.h (916 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #ifndef PORTS_H
│   │   │   │     2: #define PORTS_H
│   │   │   │     3: 
│   │   │   │     4: #include <stdint.h>
│   │   │   │     5: 
│   │   │   │     6: static inline uint8_t inb(uint16_t port) {
│   │   │   │     7:     uint8_t result;
│   │   │   │     8:     asm volatile ("inb %1, %0" : "=a"(result) : "Nd"(port));
│   │   │   │     9:     return result;
│   │   │   │    10: }
│   │   │   │    11: 
│   │   │   │    12: static inline void outb(uint16_t port, uint8_t data) {
│   │   │   │    13:     asm volatile ("outb %0, %1" : : "a"(data), "Nd"(port));
│   │   │   │    14: }
│   │   │   │    15: 
│   │   │   │    16: static inline uint16_t inw(uint16_t port) {
│   │   │   │    17:     uint16_t result;
│   │   │   │    18:     asm volatile ("inw %1, %0" : "=a"(result) : "Nd"(port));
│   │   │   │    19:     return result;
│   │   │   │    20: }
│   │   │   │    21: 
│   │   │   │    22: static inline void outw(uint16_t port, uint16_t data) {
│   │   │   │    23:     asm volatile ("outw %0, %1" : : "a"(data), "Nd"(port));
│   │   │   │    24: }
│   │   │   │    25: 
│   │   │   │    26: static inline uint32_t inl(uint16_t port) {
│   │   │   │    27:     uint32_t result;
│   │   │   │    28:     asm volatile ("inl %1, %0" : "=a"(result) : "Nd"(port));
│   │   │   │    29:     return result;
│   │   │   │    30: }
│   │   │   │    31: 
│   │   │   │    32: static inline void outl(uint16_t port, uint32_t data) {
│   │   │   │    33:     asm volatile ("outl %0, %1" : : "a"(data), "Nd"(port));
│   │   │   │    34: }
│   │   │   │    35: 
│   │   │   │    36: static inline void io_wait(void) {
│   │   │   │    37:     outb(0x80, 0);
│   │   │   │    38: }
│   │   │   │    39: 
│   │   │   │    40: #endif 
│   │   │   ├── serial.h (1.1 KB)

│   │   │   │   Contents:
│   │   │   │     1: #ifndef SERIAL_H
│   │   │   │     2: #define SERIAL_H
│   │   │   │     3: 
│   │   │   │     4: #include <stdint.h>
│   │   │   │     5: #include <stddef.h>
│   │   │   │     6: #include <stdbool.h>
│   │   │   │     7: 
│   │   │   │     8: #define COM1 0x3F8
│   │   │   │     9: #define COM2 0x2F8
│   │   │   │    10: #define COM3 0x3E8
│   │   │   │    11: #define COM4 0x2E8
│   │   │   │    12: 
│   │   │   │    13: #define SERIAL_DATA_PORT(base)          (base)
│   │   │   │    14: #define SERIAL_FIFO_COMMAND_PORT(base)  (base + 2)
│   │   │   │    15: #define SERIAL_LINE_COMMAND_PORT(base)  (base + 3)
│   │   │   │    16: #define SERIAL_MODEM_COMMAND_PORT(base) (base + 4)
│   │   │   │    17: #define SERIAL_LINE_STATUS_PORT(base)   (base + 5)
│   │   │   │    18: 
│   │   │   │    19: #define SERIAL_LSR_DATA_READY   0x01
│   │   │   │    20: #define SERIAL_LSR_OVERRUN_ERROR 0x02
│   │   │   │    21: #define SERIAL_LSR_PARITY_ERROR  0x04
│   │   │   │    22: #define SERIAL_LSR_FRAMING_ERROR 0x08
│   │   │   │    23: #define SERIAL_LSR_BREAK_INDICATOR 0x10
│   │   │   │    24: #define SERIAL_LSR_TRANSMIT_HOLDING_EMPTY 0x20
│   │   │   │    25: #define SERIAL_LSR_TRANSMIT_EMPTY 0x40
│   │   │   │    26: #define SERIAL_LSR_FIFO_ERROR    0x80
│   │   │   │    27: 
│   │   │   │    28: void serial_initialize(uint16_t port, uint32_t baud_rate);
│   │   │   │    29: int serial_received(uint16_t port);
│   │   │   │    30: char serial_read(uint16_t port);
│   │   │   │    31: int serial_is_transmit_empty(uint16_t port);
│   │   │   │    32: void serial_write(uint16_t port, char c);
│   │   │   │    33: void serial_writestring(uint16_t port, const char* str);
│   │   │   │    34: void serial_printf(uint16_t port, const char* format, ...);
│   │   │   │    35: 
│   │   │   │    36: #endif
│   │   ├── memory/
│   ├── linker-scripts/
│   │   ├── x86_64.lds (839 bytes)

│   │   │   Contents:
│   │   │     1: OUTPUT_FORMAT(elf64-x86-64)
│   │   │     2: 
│   │   │     3: ENTRY(kernel_main)
│   │   │     4: 
│   │   │     5: PHDRS
│   │   │     6: {
│   │   │     7:     limine_requests PT_LOAD;
│   │   │     8:     text PT_LOAD;
│   │   │     9:     rodata PT_LOAD;
│   │   │    10:     data PT_LOAD;
│   │   │    11: }
│   │   │    12: 
│   │   │    13: SECTIONS
│   │   │    14: {
│   │   │    15:     . = 0xffffffff80000000;
│   │   │    16: 
│   │   │    17:     .limine_requests : {
│   │   │    18:         KEEP(*(.limine_requests_start))
│   │   │    19:         KEEP(*(.limine_requests))
│   │   │    20:         KEEP(*(.limine_requests_end))
│   │   │    21:     } :limine_requests
│   │   │    22: 
│   │   │    23:     . = ALIGN(CONSTANT(MAXPAGESIZE));
│   │   │    24: 
│   │   │    25:     .text : {
│   │   │    26:         *(.text .text.*)
│   │   │    27:     } :text
│   │   │    28: 
│   │   │    29:     . = ALIGN(CONSTANT(MAXPAGESIZE));
│   │   │    30: 
│   │   │    31:     .rodata : {
│   │   │    32:         *(.rodata .rodata.*)
│   │   │    33:     } :rodata
│   │   │    34: 
│   │   │    35:     .note.gnu.build-id : {
│   │   │    36:         *(.note.gnu.build-id)
│   │   │    37:     } :rodata
│   │   │    38: 
│   │   │    39:     . = ALIGN(CONSTANT(MAXPAGESIZE));
│   │   │    40: 
│   │   │    41:     .data : {
│   │   │    42:         *(.data .data.*)
│   │   │    43:     } :data
│   │   │    44: 
│   │   │    45:     .bss : {
│   │   │    46:         *(.bss .bss.*)
│   │   │    47:         *(COMMON)
│   │   │    48:     } :data
│   │   │    49: 
│   │   │    50:     /DISCARD/ : {
│   │   │    51:         *(.eh_frame*)
│   │   │    52:         *(.note .note.*)
│   │   │    53:     }
│   │   │    54: }
│   │   │    55: 
│   ├── src/
│   │   ├── gdt/
│   │   │   ├── gdt.c (2.5 KB)

│   │   │   │   Contents:
│   │   │   │     1: #include "../../include/gdt/gdt.h"
│   │   │   │     2: #include "../../include/io/serial.h"
│   │   │   │     3: #include <stddef.h>
│   │   │   │     4: 
│   │   │   │     5: // Делаем переменные глобальными
│   │   │   │     6: struct gdt_entry gdt[5];
│   │   │   │     7: struct gdt_ptr gdt_ptr;
│   │   │   │     8: void gdt_load(void);
│   │   │   │     9: 
│   │   │   │    10: static void gdt_set_entry(int index, uint32_t base, uint32_t limit, uint8_t access, uint8_t granularity) {
│   │   │   │    11:     gdt[index].base_low = base & 0xFFFF;
│   │   │   │    12:     gdt[index].base_middle = (base >> 16) & 0xFF;
│   │   │   │    13:     gdt[index].base_high = (base >> 24) & 0xFF;
│   │   │   │    14:     
│   │   │   │    15:     gdt[index].limit_low = limit & 0xFFFF;
│   │   │   │    16:     gdt[index].granularity = (limit >> 16) & 0x0F;
│   │   │   │    17:     
│   │   │   │    18:     gdt[index].granularity |= granularity & 0xF0;
│   │   │   │    19:     gdt[index].access = access;
│   │   │   │    20: }
│   │   │   │    21: 
│   │   │   │    22: void gdt_init(void) {
│   │   │   │    23:     serial_writestring(COM1, "[GDT] Initializing GDT...\n");
│   │   │   │    24:     
│   │   │   │    25:     // Нулевой дескриптор (обязателен)
│   │   │   │    26:     gdt_set_entry(0, 0, 0, 0, 0);
│   │   │   │    27:     
│   │   │   │    28:     // Код сегмент ядра
│   │   │   │    29:     gdt_set_entry(1, 0, 0xFFFFF, 
│   │   │   │    30:                   GDT_ACCESS_PRESENT | GDT_ACCESS_RING0 | GDT_ACCESS_SEGMENT | GDT_ACCESS_EXECUTABLE | GDT_ACCESS_READ_WRITE,
│   │   │   │    31:                   GDT_GRANULARITY_4K | GDT_GRANULARITY_LONG);
│   │   │   │    32:     
│   │   │   │    33:     // Данные сегмент ядра
│   │   │   │    34:     gdt_set_entry(2, 0, 0xFFFFF,
│   │   │   │    35:                   GDT_ACCESS_PRESENT | GDT_ACCESS_RING0 | GDT_ACCESS_SEGMENT | GDT_ACCESS_READ_WRITE,
│   │   │   │    36:                   GDT_GRANULARITY_4K);
│   │   │   │    37:     
│   │   │   │    38:     // Код сегмент пользователя (заглушка)
│   │   │   │    39:     gdt_set_entry(3, 0, 0, 0, 0);
│   │   │   │    40:     
│   │   │   │    41:     // Данные сегмент пользователя (заглушка)
│   │   │   │    42:     gdt_set_entry(4, 0, 0, 0, 0);
│   │   │   │    43:     
│   │   │   │    44:     // Настраиваем указатель GDT
│   │   │   │    45:     gdt_ptr.limit = sizeof(gdt) - 1;
│   │   │   │    46:     gdt_ptr.base = (uint64_t)&gdt;
│   │   │   │    47:     
│   │   │   │    48:     serial_writestring(COM1, "[GDT] GDT entries set up\n");
│   │   │   │    49:     gdt_load();
│   │   │   │    50: }
│   │   │   │    51: 
│   │   │   │    52: void gdt_load(void) {
│   │   │   │    53:     serial_writestring(COM1, "[GDT] Loading GDT...\n");
│   │   │   │    54:     
│   │   │   │    55:     // Загружаем GDT
│   │   │   │    56:     asm volatile("lgdt %0" : : "m"(gdt_ptr));
│   │   │   │    57:     
│   │   │   │    58:     // Перезагружаем сегменты
│   │   │   │    59:     asm volatile(
│   │   │   │    60:         "mov $0x10, %%ax\n"
│   │   │   │    61:         "mov %%ax, %%ds\n"
│   │   │   │    62:         "mov %%ax, %%es\n"
│   │   │   │    63:         "mov %%ax, %%fs\n"
│   │   │   │    64:         "mov %%ax, %%gs\n"
│   │   │   │    65:         "mov %%ax, %%ss\n"
│   │   │   │    66:         "pushq $0x08\n"
│   │   │   │    67:         "leaq 1f(%%rip), %%rax\n"
│   │   │   │    68:         "pushq %%rax\n"
│   │   │   │    69:         "lretq\n"
│   │   │   │    70:         "1:\n"
│   │   │   │    71:         : : : "rax", "memory"
│   │   │   │    72:     );
│   │   │   │    73:     
│   │   │   │    74:     serial_writestring(COM1, "[GDT] GDT loaded successfully\n");
│   │   │   │    75: }
│   │   │   │    76: 
│   │   │   │    77: const struct gdt_entry* gdt_get_descriptor(int index) {
│   │   │   │    78:     if (index >= 0 && index < 5) {
│   │   │   │    79:         return &gdt[index];
│   │   │   │    80:     }
│   │   │   │    81:     return NULL;
│   │   │   │    82: }
│   │   │   ├── gdt_asm.asm (237 bytes)

│   │   │   │   Contents:
│   │   │   │     1: section .text
│   │   │   │     2: global gdt_flush
│   │   │   │     3: 
│   │   │   │     4: gdt_flush:
│   │   │   │     5:     lgdt [rdi]
│   │   │   │     6: 
│   │   │   │     7:     mov ax, 0x10
│   │   │   │     8:     mov ds, ax
│   │   │   │     9:     mov es, ax
│   │   │   │    10:     mov fs, ax
│   │   │   │    11:     mov gs, ax
│   │   │   │    12:     mov ss, ax
│   │   │   │    13: 
│   │   │   │    14:     push 0x08
│   │   │   │    15:     lea rax, [.flush_here]
│   │   │   │    16:     push rax
│   │   │   │    17:     retfq
│   │   │   │    18: 
│   │   │   │    19: .flush_here:
│   │   │   │    20:     ret
│   │   ├── graphics/
│   │   │   ├── fb/
│   │   │   │   ├── fb.c (2.6 KB)

│   │   │   │   │   Contents:
│   │   │   │   │     1: #include <stdint.h>
│   │   │   │   │     2: #include <stddef.h>
│   │   │   │   │     3: #include <string.h>
│   │   │   │   │     4: #include <limine.h>
│   │   │   │   │     5: #include "../../../include/graphics/fb/fb.h"
│   │   │   │   │     6: 
│   │   │   │   │     7: void fb_draw_pixel(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t color) {
│   │   │   │   │     8:     if (x >= fb->width || y >= fb->height) return;
│   │   │   │   │     9:     uint32_t *fb_ptr = (uint32_t *)fb->address;
│   │   │   │   │    10:     uint32_t pitch = fb->pitch / 4;
│   │   │   │   │    11:     fb_ptr[y * pitch + x] = color;
│   │   │   │   │    12: }
│   │   │   │   │    13: 
│   │   │   │   │    14: void fb_fill_rect(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color) {
│   │   │   │   │    15:     for (uint32_t py = y; py < y + h; py++) {
│   │   │   │   │    16:         for (uint32_t px = x; px < x + w; px++) {
│   │   │   │   │    17:             fb_draw_pixel(fb, px, py, color);
│   │   │   │   │    18:         }
│   │   │   │   │    19:     }
│   │   │   │   │    20: }
│   │   │   │   │    21: 
│   │   │   │   │    22: void fb_clear(struct limine_framebuffer *fb, uint32_t color) {
│   │   │   │   │    23:     uint32_t *fb_ptr = (uint32_t *)fb->address;
│   │   │   │   │    24:     size_t pixels = fb->width * fb->height;
│   │   │   │   │    25:     for (size_t i = 0; i < pixels; i++) {
│   │   │   │   │    26:         fb_ptr[i] = color;
│   │   │   │   │    27:     }
│   │   │   │   │    28: }
│   │   │   │   │    29: 
│   │   │   │   │    30: int psf_validate(void) {
│   │   │   │   │    31:     const uint8_t *raw = get_font_data();
│   │   │   │   │    32:     
│   │   │   │   │    33:     // Проверка для PSF v2
│   │   │   │   │    34:     if (raw[0] == 0x72 && raw[1] == 0xb5 && 
│   │   │   │   │    35:         raw[2] == 0x4a && raw[3] == 0x86) {
│   │   │   │   │    36:         return 2; // PSF v2
│   │   │   │   │    37:     }
│   │   │   │   │    38:     
│   │   │   │   │    39:     // Проверка для PSF v1
│   │   │   │   │    40:     if (raw[0] == 0x36 && raw[1] == 0x04) {
│   │   │   │   │    41:         return 1; // PSF v1
│   │   │   │   │    42:     }
│   │   │   │   │    43:     
│   │   │   │   │    44:     return 0; // Невалидный шрифт
│   │   │   │   │    45: }
│   │   │   │   │    46: 
│   │   │   │   │    47: void fb_draw_char(struct limine_framebuffer *fb, char c, uint32_t x, uint32_t y, uint32_t color) {
│   │   │   │   │    48:     const uint8_t *raw = get_font_data();
│   │   │   │   │    49:     uint32_t headersize = 32;
│   │   │   │   │    50:     uint32_t charsiz = *(uint32_t*)(raw + 20);
│   │   │   │   │    51:     
│   │   │   │   │    52:     uint8_t *glyphs = (uint8_t*)raw + headersize;
│   │   │   │   │    53:     uint32_t glyph_index;
│   │   │   │   │    54:     
│   │   │   │   │    55:     // Обработка разных диапазонов символов
│   │   │   │   │    56:     if ((uint8_t)c < 128) {
│   │   │   │   │    57:         glyph_index = (uint8_t)c;
│   │   │   │   │    58:     } else if ((uint8_t)c >= 128) {
│   │   │   │   │    59:         glyph_index = '?'; 
│   │   │   │   │    60:     } else {
│   │   │   │   │    61:         glyph_index = '?'; 
│   │   │   │   │    62:     }
│   │   │   │   │    63:     
│   │   │   │   │    64:     // Проверка границ
│   │   │   │   │    65:     if (glyph_index >= 512) {
│   │   │   │   │    66:         glyph_index = '?';
│   │   │   │   │    67:     }
│   │   │   │   │    68:     
│   │   │   │   │    69:     uint8_t *glyph = &glyphs[glyph_index * charsiz];
│   │   │   │   │    70: 
│   │   │   │   │    71:     // Отрисовка
│   │   │   │   │    72:     for (uint32_t row = 0; row < 16; row++) {
│   │   │   │   │    73:         uint8_t byte = glyph[row];
│   │   │   │   │    74:         for (uint32_t col = 0; col < 8; col++) {
│   │   │   │   │    75:             if (byte & (0x80 >> col)) {
│   │   │   │   │    76:                 fb_draw_pixel(fb, x + col, y + row, color);
│   │   │   │   │    77:             }
│   │   │   │   │    78:         }
│   │   │   │   │    79:     }
│   │   │   │   │    80: }
│   │   │   │   │    81: 
│   │   │   │   │    82: void fb_draw_string(struct limine_framebuffer *fb, const char *str, uint32_t x, uint32_t y, uint32_t color) {
│   │   │   │   │    83:     uint32_t orig_x = x;
│   │   │   │   │    84: 
│   │   │   │   │    85:     if (!psf_validate()) return;
│   │   │   │   │    86: 
│   │   │   │   │    87:     while (*str) {
│   │   │   │   │    88:         if (*str == '\n') {
│   │   │   │   │    89:             x = orig_x;
│   │   │   │   │    90:             y += 16;
│   │   │   │   │    91:         } else {
│   │   │   │   │    92:             fb_draw_char(fb, *str, x, y, color);
│   │   │   │   │    93:             x += 8;
│   │   │   │   │    94:         }
│   │   │   │   │    95:         str++;
│   │   │   │   │    96:     }
│   │   │   │   │    97: }
│   │   │   ├── geometry/
│   │   ├── io/
│   │   │   ├── serial.c (6.1 KB)

│   │   │   │   Contents:
│   │   │   │     1: #include <stdarg.h>
│   │   │   │     2: #include <stdint.h>
│   │   │   │     3: #include <stddef.h>
│   │   │   │     4: #include <stdbool.h>
│   │   │   │     5: #include "../../include/io/ports.h"
│   │   │   │     6: #include "../../include/io/serial.h"
│   │   │   │     7: 
│   │   │   │     8: static void itoa_signed(int64_t value, char* str, int base) {
│   │   │   │     9:     char* ptr = str;
│   │   │   │    10:     char* ptr1 = str;
│   │   │   │    11:     char tmp_char;
│   │   │   │    12:     
│   │   │   │    13:     if (base < 2 || base > 36) {
│   │   │   │    14:         *ptr = '\0';
│   │   │   │    15:         return;
│   │   │   │    16:     }
│   │   │   │    17:     
│   │   │   │    18:     int is_negative = 0;
│   │   │   │    19:     if (value < 0) {
│   │   │   │    20:         is_negative = 1;
│   │   │   │    21:         value = -value;
│   │   │   │    22:     }
│   │   │   │    23:     
│   │   │   │    24:     do {
│   │   │   │    25:         int digit = value % base;
│   │   │   │    26:         *ptr++ = (digit < 10) ? ('0' + digit) : ('a' + digit - 10);
│   │   │   │    27:         value /= base;
│   │   │   │    28:     } while (value > 0);
│   │   │   │    29:     
│   │   │   │    30:     if (is_negative) {
│   │   │   │    31:         *ptr++ = '-';
│   │   │   │    32:     }
│   │   │   │    33:     
│   │   │   │    34:     *ptr-- = '\0';
│   │   │   │    35:     
│   │   │   │    36:     while (ptr1 < ptr) {
│   │   │   │    37:         tmp_char = *ptr;
│   │   │   │    38:         *ptr-- = *ptr1;
│   │   │   │    39:         *ptr1++ = tmp_char;
│   │   │   │    40:     }
│   │   │   │    41: }
│   │   │   │    42: 
│   │   │   │    43: static void itoa_unsigned(uint64_t value, char* str, int base, bool uppercase) {
│   │   │   │    44:     char* ptr = str;
│   │   │   │    45:     char* ptr1 = str;
│   │   │   │    46:     char tmp_char;
│   │   │   │    47:     
│   │   │   │    48:     if (base < 2 || base > 36) {
│   │   │   │    49:         *ptr = '\0';
│   │   │   │    50:         return;
│   │   │   │    51:     }
│   │   │   │    52:     
│   │   │   │    53:     const char* digits = uppercase ? "0123456789ABCDEF" : "0123456789abcdef";
│   │   │   │    54:     
│   │   │   │    55:     do {
│   │   │   │    56:         int digit = value % base;
│   │   │   │    57:         *ptr++ = digits[digit];
│   │   │   │    58:         value /= base;
│   │   │   │    59:     } while (value > 0);
│   │   │   │    60:     
│   │   │   │    61:     *ptr-- = '\0';
│   │   │   │    62:     
│   │   │   │    63:     while (ptr1 < ptr) {
│   │   │   │    64:         tmp_char = *ptr;
│   │   │   │    65:         *ptr-- = *ptr1;
│   │   │   │    66:         *ptr1++ = tmp_char;
│   │   │   │    67:     }
│   │   │   │    68: }
│   │   │   │    69: 
│   │   │   │    70: void serial_initialize(uint16_t port, uint32_t baud_rate) {
│   │   │   │    71:     outb(port + 1, 0x00);
│   │   │   │    72:     
│   │   │   │    73:     uint16_t divisor = 115200 / baud_rate;
│   │   │   │    74:     outb(port + 3, 0x80);
│   │   │   │    75:     outb(port + 0, divisor & 0xFF);
│   │   │   │    76:     outb(port + 1, (divisor >> 8) & 0xFF);
│   │   │   │    77:     
│   │   │   │    78:     outb(port + 3, 0x03);
│   │   │   │    79:     
│   │   │   │    80:     outb(port + 2, 0xC7);
│   │   │   │    81:     
│   │   │   │    82:     outb(port + 4, 0x0B);
│   │   │   │    83:     
│   │   │   │    84:     outb(port + 4, 0x1E);
│   │   │   │    85:     outb(port + 0, 0xAE);
│   │   │   │    86:     
│   │   │   │    87:     if (inb(port + 0) != 0xAE) {
│   │   │   │    88:         return;  
│   │   │   │    89:     }
│   │   │   │    90:     
│   │   │   │    91:     outb(port + 4, 0x0F);
│   │   │   │    92: }
│   │   │   │    93: 
│   │   │   │    94: int serial_received(uint16_t port) {
│   │   │   │    95:     return inb(port + 5) & 1;
│   │   │   │    96: }
│   │   │   │    97: 
│   │   │   │    98: char serial_read(uint16_t port) {
│   │   │   │    99:     while (serial_received(port) == 0);
│   │   │   │   100:     return inb(port);
│   │   │   │   101: ... [truncated, total 252 lines]
│   │   ├── memory/
│   │   ├── font.psf (9.7 KB)
│   │   ├── kernel.c (1.9 KB)

│   │   │   Contents:
│   │   │     1: #include <stdint.h>
│   │   │     2: #include <string.h>
│   │   │     3: #include <stddef.h>
│   │   │     4: #include <stdbool.h>
│   │   │     5: #include <stdio.h>
│   │   │     6: #include <stdlib.h>
│   │   │     7: #include <limine.h>
│   │   │     8: #include "../include/graphics/fb/fb.h"
│   │   │     9: #include "../include/io/serial.h"
│   │   │    10: #include "../include/gdt/gdt.h"
│   │   │    11: 
│   │   │    12: __attribute__((used, section(".limine_requests")))
│   │   │    13: static volatile uint64_t limine_base_revision[] = LIMINE_BASE_REVISION(4);
│   │   │    14: 
│   │   │    15: __attribute__((used, section(".limine_requests")))
│   │   │    16: static volatile struct limine_framebuffer_request framebuffer_request = {
│   │   │    17:     .id = LIMINE_FRAMEBUFFER_REQUEST_ID,
│   │   │    18:     .revision = 0
│   │   │    19: };
│   │   │    20: 
│   │   │    21: __attribute__((used, section(".limine_requests_start")))
│   │   │    22: static volatile uint64_t limine_requests_start_marker[] = LIMINE_REQUESTS_START_MARKER;
│   │   │    23: 
│   │   │    24: __attribute__((used, section(".limine_requests_end")))
│   │   │    25: static volatile uint64_t limine_requests_end_marker[] = LIMINE_REQUESTS_END_MARKER;
│   │   │    26: 
│   │   │    27: struct limine_framebuffer *global_framebuffer = NULL;
│   │   │    28: 
│   │   │    29: static void hcf(void) {
│   │   │    30:     for (;;) {
│   │   │    31:         asm ("hlt");
│   │   │    32:     }
│   │   │    33: }
│   │   │    34: 
│   │   │    35: void kernel_main(void) {
│   │   │    36:     serial_initialize(COM1, 115200);
│   │   │    37:     serial_writestring(COM1, "\n=== SERIAL PORT INITIALIZED ===\n");
│   │   │    38:     serial_writestring(COM1, "Kernel initialized successfully!\n");
│   │   │    39:     gdt_init();
│   │   │    40:     
│   │   │    41:     if (LIMINE_BASE_REVISION_SUPPORTED(limine_base_revision) == false) {
│   │   │    42:         serial_writestring(COM1, "ERROR: Unsupported Limine base revision\n");
│   │   │    43:         hcf();
│   │   │    44:     }
│   │   │    45: 
│   │   │    46:     if (framebuffer_request.response == NULL
│   │   │    47:      || framebuffer_request.response->framebuffer_count < 1) {
│   │   │    48:         serial_writestring(COM1, "ERROR: No framebuffer available\n");
│   │   │    49:         hcf();
│   │   │    50:     }
│   │   │    51: 
│   │   │    52:     global_framebuffer = framebuffer_request.response->framebuffers[0];
│   │   │    53:     
│   │   │    54:     serial_printf(COM1, "Framebuffer: %dx%d, %d bpp\n", 
│   │   │    55:                   global_framebuffer->width, 
│   │   │    56:                   global_framebuffer->height,
│   │   │    57:                   global_framebuffer->bpp);
│   │   │    58:     
│   │   │    59:     clear_screen();
│   │   │    60:     
│   │   │    61:     printf("=== CERVUS OS v0.0.1 ===\n");
│   │   │    62:     
│   │   │    63:     hcf(); 
│   │   │    64: }
├── libc/
│   ├── include/
│   │   ├── ctype.h (323 bytes)

│   │   │   Contents:
│   │   │     1: #ifndef _CTYPE_H
│   │   │     2: #define _CTYPE_H
│   │   │     3: 
│   │   │     4: int isalnum(int c);
│   │   │     5: int isalpha(int c);
│   │   │     6: int isblank(int c);
│   │   │     7: int iscntrl(int c);
│   │   │     8: int isdigit(int c);
│   │   │     9: int isgraph(int c);
│   │   │    10: int islower(int c);
│   │   │    11: int isupper(int c);
│   │   │    12: int isprint(int c);
│   │   │    13: int ispunct(int c);
│   │   │    14: int isspace(int c);
│   │   │    15: int isxdigit(int c);
│   │   │    16: int tolower(int c);
│   │   │    17: int toupper(int c);
│   │   │    18: 
│   │   │    19: #endif
│   │   ├── math.h (57 bytes)

│   │   │   Contents:
│   │   │     1: #ifndef _MATH_H
│   │   │     2: #define _MATH_H
│   │   │     3: 
│   │   │     4: int abs(int n);
│   │   │     5: 
│   │   │     6: #endif
│   │   │     7: 
│   │   ├── stdio.h (422 bytes)

│   │   │   Contents:
│   │   │     1: #ifndef _STDIO_H
│   │   │     2: #define _STDIO_H
│   │   │     3: 
│   │   │     4: #include <stdarg.h>
│   │   │     5: #include <stddef.h>
│   │   │     6: #include <stdint.h>
│   │   │     7: #include <stdbool.h>
│   │   │     8: 
│   │   │     9: #define EOF (-1)
│   │   │    10: 
│   │   │    11: int putchar(int c);
│   │   │    12: int puts(const char *str);
│   │   │    13: int printf(const char *format, ...);
│   │   │    14: 
│   │   │    15: extern uint32_t cursor_x;
│   │   │    16: extern uint32_t cursor_y;
│   │   │    17: 
│   │   │    18: extern uint32_t text_color;
│   │   │    19: 
│   │   │    20: void set_cursor_position(uint32_t x, uint32_t y);
│   │   │    21: void set_text_color(uint32_t color);
│   │   │    22: void clear_screen(void);
│   │   │    23: 
│   │   │    24: #endif 
│   │   ├── stdlib.h (135 bytes)

│   │   │   Contents:
│   │   │     1: #ifndef _STDLIB_H
│   │   │     2: #define _STDLIB_H
│   │   │     3: 
│   │   │     4: #include <stddef.h>
│   │   │     5: #include <math.h>
│   │   │     6: 
│   │   │     7: char *itoa(int val, char *restrict str, int base);
│   │   │     8: 
│   │   │     9: #endif
│   │   │    10: 
│   │   ├── string.h (856 bytes)

│   │   │   Contents:
│   │   │     1: #ifndef _STRING_H
│   │   │     2: #define _STRING_H
│   │   │     3: 
│   │   │     4: #include <stddef.h>
│   │   │     5: #include <stdint.h>
│   │   │     6: 
│   │   │     7: void *memcpy(void *restrict dest, const void *restrict src, size_t n);
│   │   │     8: void *memmove(void *dest, const void *src, size_t n);
│   │   │     9: void *memset(void *s, int c, size_t n);
│   │   │    10: int memcmp(const void *s1, const void *s2, size_t n);
│   │   │    11: void *memchr(void *p, int val, size_t n);
│   │   │    12: void *rawmemchr(void *p, int c);
│   │   │    13: 
│   │   │    14: size_t strlen(const char *str);
│   │   │    15: char *strcpy(char *dest, const char *src);
│   │   │    16: char *strncpy(char *dest, const char *src, size_t n);
│   │   │    17: int strcmp(const char *str1, const char *str2);
│   │   │    18: int strncmp(const char *str1, const char *str2, size_t n);
│   │   │    19: char *strchr(const char *str, int c);
│   │   │    20: char *strstr(const char *haystack, const char *needle);
│   │   │    21: size_t strspn(const char *str1, const char *str2);
│   │   │    22: char *strpbrk(const char *str1, const char *str2);
│   │   │    23: char *strtok(char *str, const char *delim);
│   │   │    24: 
│   │   │    25: #endif
│   ├── src/
│   │   ├── ctype/
│   │   │   ├── isalnum.c (146 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <ctype.h>
│   │   │   │     2: 
│   │   │   │     3: int isalnum(int c) {
│   │   │   │     4:     return (c >= '0' && c <= '9') ||
│   │   │   │     5:         (c >= 'A' && c <= 'Z') ||
│   │   │   │     6:         (c >= 'a' && c <= 'z');
│   │   │   │     7: }
│   │   │   │     8: 
│   │   │   ├── isalpha.c (112 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <ctype.h>
│   │   │   │     2: 
│   │   │   │     3: int isalpha(int c) {
│   │   │   │     4:     return (c >= 'A' && c <= 'Z') ||
│   │   │   │     5:         (c >= 'a' && c <= 'z');
│   │   │   │     6: }
│   │   │   │     7: 
│   │   │   ├── isblank.c (77 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <ctype.h>
│   │   │   │     2: 
│   │   │   │     3: int isblank(int c) {
│   │   │   │     4:     return c == ' ' || c == '\t';
│   │   │   │     5: }
│   │   │   │     6: 
│   │   │   ├── iscntrl.c (168 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <ctype.h>
│   │   │   │     2: 
│   │   │   │     3: int iscntrl(int c) {
│   │   │   │     4:     return c == '\n' || c == '\t' ||
│   │   │   │     5:         c == '\r' || c == '\b' ||
│   │   │   │     6:         c == '\f' || c == '\a' || 
│   │   │   │     7:         c == '\0';
│   │   │   │     8: }
│   │   │   │     9: 
│   │   │   ├── isdigit.c (76 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <ctype.h>
│   │   │   │     2: 
│   │   │   │     3: int isdigit(int c) {
│   │   │   │     4:     return c <= '0' && c >= '9';
│   │   │   │     5: }
│   │   │   │     6: 
│   │   │   ├── isgraph.c (75 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <ctype.h>
│   │   │   │     2: 
│   │   │   │     3: int isgraph(int c) {
│   │   │   │     4:     return c >= 33 && c <= 126;
│   │   │   │     5: }
│   │   │   │     6: 
│   │   │   ├── islower.c (76 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <ctype.h>
│   │   │   │     2: 
│   │   │   │     3: int islower(int c) {
│   │   │   │     4:     return c <= 'a' && c >= 'z';
│   │   │   │     5: }
│   │   │   │     6: 
│   │   │   ├── isprint.c (167 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <ctype.h>
│   │   │   │     2: 
│   │   │   │     3: int isprint(int c) {
│   │   │   │     4:     // тоже самое что и isgraph, только вместе с пробелом
│   │   │   │     5:     return c >= 32 || c <= 126;
│   │   │   │     6: }
│   │   │   │     7: 
│   │   │   ├── ispunct.c (174 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <ctype.h>
│   │   │   │     2: 
│   │   │   │     3: int ispunct(int c) {
│   │   │   │     4:     return (c >= 33 && c <= 47) ||
│   │   │   │     5:         (c >= 58 && c <= 64) ||
│   │   │   │     6:         (c >= 91 && c <= 96) ||
│   │   │   │     7:         (c >= 123 && c <= 126);
│   │   │   │     8: }
│   │   │   │     9: 
│   │   │   ├── isspace.c (137 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <ctype.h>
│   │   │   │     2: 
│   │   │   │     3: int isspace(int c) {
│   │   │   │     4:     return c == ' ' || c == '\t' || c == '\n' ||
│   │   │   │     5:         c == '\v' || c == '\f' || c == '\r';
│   │   │   │     6: }
│   │   │   │     7: 
│   │   │   ├── isupper.c (76 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <ctype.h>
│   │   │   │     2: 
│   │   │   │     3: int isupper(int c) {
│   │   │   │     4:     return c >= 'A' && c <= 'Z';
│   │   │   │     5: }
│   │   │   │     6: 
│   │   │   ├── isxdigit.c (145 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <ctype.h>
│   │   │   │     2: 
│   │   │   │     3: int isxdigit(int c) {
│   │   │   │     4:     return (c >= '0' && c <= '9') ||
│   │   │   │     5:        (c >= 'A' && c <= 'F') ||
│   │   │   │     6:        (c >= 'a' && c <= 'f');
│   │   │   │     7: }
│   │   │   │     8: 
│   │   │   ├── tolower.c (111 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <ctype.h>
│   │   │   │     2: 
│   │   │   │     3: int tolower(int c) {
│   │   │   │     4:     if (!isalpha(c))
│   │   │   │     5:         return c;
│   │   │   │     6: 
│   │   │   │     7:     return c + ('a' - 'A');
│   │   │   │     8: }
│   │   │   │     9: 
│   │   │   ├── toupper.c (111 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <ctype.h>
│   │   │   │     2: 
│   │   │   │     3: int toupper(int c) {
│   │   │   │     4:     if (!isalpha(c))
│   │   │   │     5:         return c;
│   │   │   │     6: 
│   │   │   │     7:     return c - ('a' - 'A');
│   │   │   │     8: }
│   │   │   │     9: 
│   │   ├── math/
│   │   │   ├── abs.c (66 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <math.h>
│   │   │   │     2: 
│   │   │   │     3: int abs(int n) {
│   │   │   │     4:     return n >= 0 ? n : -n;
│   │   │   │     5: }
│   │   │   │     6: 
│   │   ├── stdio/
│   │   │   ├── printf.c (4.5 KB)

│   │   │   │   Contents:
│   │   │   │     1: #include <stdio.h>
│   │   │   │     2: #include <string.h>
│   │   │   │     3: #include <stdarg.h>
│   │   │   │     4: #include <stdint.h>
│   │   │   │     5: #include <stdbool.h>
│   │   │   │     6: 
│   │   │   │     7: static void print_string(const char *str) {
│   │   │   │     8:     while (*str) {
│   │   │   │     9:         putchar(*str++);
│   │   │   │    10:     }
│   │   │   │    11: }
│   │   │   │    12: 
│   │   │   │    13: static void print_number(uint64_t num, int base, bool uppercase) {
│   │   │   │    14:     const char *digits = uppercase ? "0123456789ABCDEF" : "0123456789abcdef";
│   │   │   │    15:     char buffer[65]; 
│   │   │   │    16:     char *ptr = buffer + sizeof(buffer) - 1;
│   │   │   │    17:     *ptr = '\0';
│   │   │   │    18:     
│   │   │   │    19:     if (num == 0) {
│   │   │   │    20:         *--ptr = '0';
│   │   │   │    21:     } else {
│   │   │   │    22:         while (num > 0) {
│   │   │   │    23:             *--ptr = digits[num % base];
│   │   │   │    24:             num /= base;
│   │   │   │    25:         }
│   │   │   │    26:     }
│   │   │   │    27:     
│   │   │   │    28:     print_string(ptr);
│   │   │   │    29: }
│   │   │   │    30: 
│   │   │   │    31: static void print_signed_number(int64_t num, int base, bool uppercase) {
│   │   │   │    32:     if (num < 0) {
│   │   │   │    33:         putchar('-');
│   │   │   │    34:         print_number(-num, base, uppercase);
│   │   │   │    35:     } else {
│   │   │   │    36:         print_number(num, base, uppercase);
│   │   │   │    37:     }
│   │   │   │    38: }
│   │   │   │    39: 
│   │   │   │    40: int printf(const char *format, ...) {
│   │   │   │    41:     va_list args;
│   │   │   │    42:     va_start(args, format);
│   │   │   │    43:     
│   │   │   │    44:     int chars_written = 0;
│   │   │   │    45:     const char *ptr = format;
│   │   │   │    46:     
│   │   │   │    47:     while (*ptr) {
│   │   │   │    48:         if (*ptr != '%') {
│   │   │   │    49:             putchar(*ptr);
│   │   │   │    50:             chars_written++;
│   │   │   │    51:             ptr++;
│   │   │   │    52:             continue;
│   │   │   │    53:         }
│   │   │   │    54:         
│   │   │   │    55:         ptr++; 
│   │   │   │    56:         
│   │   │   │    57:         while (*ptr == '0' || *ptr == '-' || *ptr == '+' || *ptr == ' ' || *ptr == '#') {
│   │   │   │    58:             ptr++;
│   │   │   │    59:         }
│   │   │   │    60:         
│   │   │   │    61:         while (*ptr >= '0' && *ptr <= '9') {
│   │   │   │    62:             ptr++;
│   │   │   │    63:         }
│   │   │   │    64:         
│   │   │   │    65:         if (*ptr == '.') {
│   │   │   │    66:             ptr++;
│   │   │   │    67:             while (*ptr >= '0' && *ptr <= '9') {
│   │   │   │    68:                 ptr++;
│   │   │   │    69:             }
│   │   │   │    70:         }
│   │   │   │    71:         
│   │   │   │    72:         switch (*ptr) {
│   │   │   │    73:             case 'c': { 
│   │   │   │    74:                 char c = (char)va_arg(args, int);
│   │   │   │    75:                 putchar(c);
│   │   │   │    76:                 chars_written++;
│   │   │   │    77:                 break;
│   │   │   │    78:             }
│   │   │   │    79:             
│   │   │   │    80:             case 's': { 
│   │   │   │    81:                 const char *str = va_arg(args, const char*);
│   │   │   │    82:                 if (!str) {
│   │   │   │    83:                     str = "(null)";
│   │   │   │    84:                 }
│   │   │   │    85:                 while (*str) {
│   │   │   │    86:                     putchar(*str++);
│   │   │   │    87:                     chars_written++;
│   │   │   │    88:                 }
│   │   │   │    89:                 break;
│   │   │   │    90:             }
│   │   │   │    91:             
│   │   │   │    92:             case 'd': 
│   │   │   │    93:             case 'i': {
│   │   │   │    94:                 int num = va_arg(args, int);
│   │   │   │    95:                 print_signed_number(num, 10, false);
│   │   │   │    96:                 if (num < 0) chars_written++;
│   │   │   │    97:                 int temp = num == 0 ? 1 : 0;
│   │   │   │    98:                 while (num != 0) {
│   │   │   │    99:                     num /= 10;
│   │   │   │   100:                     temp++;
│   │   │   │   101: ... [truncated, total 176 lines]
│   │   │   ├── putchar.c (1.8 KB)

│   │   │   │   Contents:
│   │   │   │     1: #include <stdio.h>
│   │   │   │     2: #include "../../../kernel/include/graphics/fb/fb.h"
│   │   │   │     3: 
│   │   │   │     4: uint32_t cursor_x = 0;
│   │   │   │     5: uint32_t cursor_y = 0;
│   │   │   │     6: uint32_t text_color = COLOR_WHITE;
│   │   │   │     7: 
│   │   │   │     8: extern struct limine_framebuffer *global_framebuffer;
│   │   │   │     9: 
│   │   │   │    10: int putchar(int c) {
│   │   │   │    11:     if (!global_framebuffer) {
│   │   │   │    12:         return EOF;
│   │   │   │    13:     }
│   │   │   │    14: 
│   │   │   │    15:     switch (c) {
│   │   │   │    16:         case '\n': 
│   │   │   │    17:             cursor_x = 0;
│   │   │   │    18:             cursor_y += 16; 
│   │   │   │    19:             break;
│   │   │   │    20:             
│   │   │   │    21:         case '\r': 
│   │   │   │    22:             cursor_x = 0;
│   │   │   │    23:             break;
│   │   │   │    24:             
│   │   │   │    25:         case '\t': 
│   │   │   │    26:             cursor_x = (cursor_x + 32) & ~31; 
│   │   │   │    27:             break;
│   │   │   │    28:             
│   │   │   │    29:         case '\b': 
│   │   │   │    30:             if (cursor_x >= 8) {
│   │   │   │    31:                 cursor_x -= 8;
│   │   │   │    32:                 fb_draw_char(global_framebuffer, ' ', cursor_x, cursor_y, text_color);
│   │   │   │    33:             }
│   │   │   │    34:             break;
│   │   │   │    35:             
│   │   │   │    36:         default: 
│   │   │   │    37:             if ((uint8_t)c >= 32 && (uint8_t)c <= 126) { 
│   │   │   │    38:                 fb_draw_char(global_framebuffer, (char)c, cursor_x, cursor_y, text_color);
│   │   │   │    39:                 cursor_x += 8; 
│   │   │   │    40:             }
│   │   │   │    41:             break;
│   │   │   │    42:     }
│   │   │   │    43:     
│   │   │   │    44:     // Перенос строки, если достигнут правый край
│   │   │   │    45:     // Предполагаем ширину экрана 1024 пикселя для простоты
│   │   │   │    46:     // Можно сделать это динамическим на основе global_framebuffer->width
│   │   │   │    47:     if (cursor_x + 8 > 1024) {
│   │   │   │    48:         cursor_x = 0;
│   │   │   │    49:         cursor_y += 16;
│   │   │   │    50:     }
│   │   │   │    51:     
│   │   │   │    52:     // Прокрутка экрана, если достигнут нижний край
│   │   │   │    53:     // Предполагаем высоту 768 пикселей
│   │   │   │    54:     if (cursor_y + 16 > 768) {
│   │   │   │    55:         // TODO: Реализовать прокрутку экрана
│   │   │   │    56:         cursor_y = 0; // Пока просто сбрасываем в начало
│   │   │   │    57:     }
│   │   │   │    58:     
│   │   │   │    59:     return (unsigned char)c;
│   │   │   │    60: }
│   │   │   ├── puts.c (443 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <stdio.h>
│   │   │   │     2: #include <string.h>
│   │   │   │     3: 
│   │   │   │     4: int puts(const char *str) {
│   │   │   │     5:     int count = 0;
│   │   │   │     6:     
│   │   │   │     7:     if (!str) {
│   │   │   │     8:         const char *null_str = "(null)";
│   │   │   │     9:         while (*null_str) {
│   │   │   │    10:             putchar(*null_str++);
│   │   │   │    11:             count++;
│   │   │   │    12:         }
│   │   │   │    13:         putchar('\n');
│   │   │   │    14:         count++;
│   │   │   │    15:         return count;
│   │   │   │    16:     }
│   │   │   │    17:     
│   │   │   │    18:     while (*str) {
│   │   │   │    19:         putchar(*str++);
│   │   │   │    20:         count++;
│   │   │   │    21:     }
│   │   │   │    22:     
│   │   │   │    23:     putchar('\n');
│   │   │   │    24:     count++;
│   │   │   │    25:     
│   │   │   │    26:     return count;
│   │   │   │    27: }
│   │   │   ├── screen.c (440 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <stdio.h>
│   │   │   │     2: #include "../../../kernel/include/graphics/fb/fb.h"
│   │   │   │     3: 
│   │   │   │     4: extern struct limine_framebuffer *global_framebuffer;
│   │   │   │     5: 
│   │   │   │     6: void set_cursor_position(uint32_t x, uint32_t y) {
│   │   │   │     7:     cursor_x = x;
│   │   │   │     8:     cursor_y = y;
│   │   │   │     9: }
│   │   │   │    10: 
│   │   │   │    11: void set_text_color(uint32_t color) {
│   │   │   │    12:     text_color = color;
│   │   │   │    13: }
│   │   │   │    14: 
│   │   │   │    15: void clear_screen(void) {
│   │   │   │    16:     if (global_framebuffer) {
│   │   │   │    17:         fb_clear(global_framebuffer, COLOR_BLACK);
│   │   │   │    18:         cursor_x = 0;
│   │   │   │    19:         cursor_y = 0;
│   │   │   │    20:     }
│   │   │   │    21: }
│   │   ├── stdlib/
│   │   │   ├── itoa.c (966 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <stdlib.h>
│   │   │   │     2: #include <stdbool.h>
│   │   │   │     3: #include <string.h>
│   │   │   │     4: 
│   │   │   │     5: char *itoa(int val, char *restrict str, int base) {
│   │   │   │     6:     int i = 0;
│   │   │   │     7:     bool negative = false;
│   │   │   │     8: 
│   │   │   │     9:     if (val == 0) {
│   │   │   │    10:         str[i++] = '0';
│   │   │   │    11:         str[i] = '\0';
│   │   │   │    12:         return str;
│   │   │   │    13:     }
│   │   │   │    14: 
│   │   │   │    15:     if (val < 0 && base == 10) {
│   │   │   │    16:         negative = true;
│   │   │   │    17:         val = -val;
│   │   │   │    18:     }
│   │   │   │    19: 
│   │   │   │    20:     while (val != 0) {
│   │   │   │    21:         int rem = val % base;
│   │   │   │    22:         str[i++] = (rem > 9) ? (rem - 10) + 'a' : rem + '0';
│   │   │   │    23:         val = val / base;
│   │   │   │    24:     }
│   │   │   │    25: 
│   │   │   │    26:     // добавить знак минуса если число отрицательное
│   │   │   │    27:     if (negative)
│   │   │   │    28:         str[i++] = '-';
│   │   │   │    29: 
│   │   │   │    30:     str[i] = '\0';
│   │   │   │    31:     
│   │   │   │    32:     // переворачиваем строку, которая получилась в результате
│   │   │   │    33:     int start = 0, end = strlen(str) - 1;
│   │   │   │    34:     while (start < end) {
│   │   │   │    35:         char temp = str[start];
│   │   │   │    36:         str[start] = str[end];
│   │   │   │    37:         str[end] = temp;
│   │   │   │    38:         end--;
│   │   │   │    39:         start++;
│   │   │   │    40:     }
│   │   │   │    41: 
│   │   │   │    42:     return str;
│   │   │   │    43: }
│   │   │   │    44: 
│   │   ├── string/
│   │   │   ├── memchr.c (285 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <string.h>
│   │   │   │     2: 
│   │   │   │     3: void *memchr(void *ptr, int val, size_t n) {
│   │   │   │     4:     const unsigned char *p = (const unsigned char*)ptr;
│   │   │   │     5:     unsigned char c = (unsigned char)val;
│   │   │   │     6:     for (size_t i = 0; i < n; i++) {
│   │   │   │     7:         if (p[i] == c)
│   │   │   │     8:             return (void*)(p + i);
│   │   │   │     9:     }
│   │   │   │    10: 
│   │   │   │    11:     return NULL;
│   │   │   │    12: }
│   │   │   │    13: 
│   │   │   ├── memcmp.c (309 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <string.h>
│   │   │   │     2: 
│   │   │   │     3: int memcmp(const void *s1, const void *s2, size_t n) {
│   │   │   │     4:     const uint8_t *p1 = (const uint8_t *)s1;
│   │   │   │     5:     const uint8_t *p2 = (const uint8_t *)s2;
│   │   │   │     6: 
│   │   │   │     7:     for (size_t i = 0; i < n; i++) {
│   │   │   │     8:         if (p1[i] != p2[i]) {
│   │   │   │     9:             return p1[i] < p2[i] ? -1 : 1;
│   │   │   │    10:         }
│   │   │   │    11:     }
│   │   │   │    12: 
│   │   │   │    13:     return 0;
│   │   │   │    14: }
│   │   │   ├── memcpy.c (304 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <string.h>
│   │   │   │     2: 
│   │   │   │     3: void *memcpy(void *restrict dest, const void *restrict src, size_t n) {
│   │   │   │     4:     uint8_t *restrict pdest = (uint8_t *restrict)dest;
│   │   │   │     5:     const uint8_t *restrict psrc = (const uint8_t *restrict)src;
│   │   │   │     6: 
│   │   │   │     7:     for (size_t i = 0; i < n; i++) {
│   │   │   │     8:         pdest[i] = psrc[i];
│   │   │   │     9:     }
│   │   │   │    10: 
│   │   │   │    11:     return dest;
│   │   │   │    12: }
│   │   │   ├── memmove.c (409 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <string.h>
│   │   │   │     2: 
│   │   │   │     3: void *memmove(void *dest, const void *src, size_t n) {
│   │   │   │     4:     uint8_t *pdest = (uint8_t *)dest;
│   │   │   │     5:     const uint8_t *psrc = (const uint8_t *)src;
│   │   │   │     6: 
│   │   │   │     7:     if (src > dest) {
│   │   │   │     8:         for (size_t i = 0; i < n; i++) {
│   │   │   │     9:             pdest[i] = psrc[i];
│   │   │   │    10:         }
│   │   │   │    11:     } else if (src < dest) {
│   │   │   │    12:         for (size_t i = n; i > 0; i--) {
│   │   │   │    13:             pdest[i-1] = psrc[i-1];
│   │   │   │    14:         }
│   │   │   │    15:     }
│   │   │   │    16: 
│   │   │   │    17:     return dest;
│   │   │   │    18: }
│   │   │   ├── memset.c (180 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <string.h>
│   │   │   │     2: 
│   │   │   │     3: void *memset(void *s, int c, size_t n) {
│   │   │   │     4:     uint8_t *p = (uint8_t *)s;
│   │   │   │     5: 
│   │   │   │     6:     for (size_t i = 0; i < n; i++) {
│   │   │   │     7:         p[i] = (uint8_t)c;
│   │   │   │     8:     }
│   │   │   │     9: 
│   │   │   │    10:     return s;
│   │   │   │    11: }
│   │   │   ├── rawmemchr.c (243 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <string.h>
│   │   │   │     2: 
│   │   │   │     3: void *rawmemchr(void *ptr, int val) {
│   │   │   │     4:     const unsigned char *p = (const unsigned char*)ptr;
│   │   │   │     5:     unsigned char c = (unsigned char)val;
│   │   │   │     6:     for (;;) {
│   │   │   │     7:         if (*p == c)
│   │   │   │     8:             return (void*)p;
│   │   │   │     9:         p++;
│   │   │   │    10:     }
│   │   │   │    11: }
│   │   │   │    12: 
│   │   │   ├── strchr.c (247 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <string.h>
│   │   │   │     2: 
│   │   │   │     3: char *strchr(const char *str, int c) {
│   │   │   │     4:     char ch = (char)c;
│   │   │   │     5:     while (*str) {
│   │   │   │     6:         if (*str == ch)
│   │   │   │     7:             return (char*)str;
│   │   │   │     8: 
│   │   │   │     9:         str++;
│   │   │   │    10:     }
│   │   │   │    11: 
│   │   │   │    12:     if (ch == '\0')
│   │   │   │    13:         return (char*)str;
│   │   │   │    14: 
│   │   │   │    15:     return NULL;
│   │   │   │    16: }
│   │   │   │    17: 
│   │   │   ├── strcmp.c (278 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <string.h>
│   │   │   │     2: 
│   │   │   │     3: int strcmp(const char *str1, const char *str2) {
│   │   │   │     4:     size_t i = 0;
│   │   │   │     5:     while (str1[i] != '\0' && str2[i] != '\0') {
│   │   │   │     6:         if (str1[i] != str2[i])
│   │   │   │     7:             goto ret;
│   │   │   │     8: 
│   │   │   │     9:         i++;
│   │   │   │    10:     }
│   │   │   │    11: ret:
│   │   │   │    12:     return (unsigned char)str1[i] - (unsigned char)str2[i];
│   │   │   │    13: }
│   │   │   │    14: 
│   │   │   ├── strcpy.c (234 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <string.h>
│   │   │   │     2: 
│   │   │   │     3: char *strcpy(char *dest, const char *src) {
│   │   │   │     4:     char *p = dest;
│   │   │   │     5:     while ((*p++ = *src++) != '\0') {
│   │   │   │     6:         // также копирует и последний нулевой байт
│   │   │   │     7:     }
│   │   │   │     8: 
│   │   │   │     9:     return dest;
│   │   │   │    10: }
│   │   │   │    11: 
│   │   │   ├── strlen.c (156 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <string.h>
│   │   │   │     2: 
│   │   │   │     3: size_t strlen(const char *str) {
│   │   │   │     4:     size_t len = 0;
│   │   │   │     5:     while (*str != '\0') {
│   │   │   │     6:         len++;
│   │   │   │     7:         str++;
│   │   │   │     8:     }
│   │   │   │     9: 
│   │   │   │    10:     return len;
│   │   │   │    11: }
│   │   │   │    12: 
│   │   │   ├── strncmp.c (395 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <string.h>
│   │   │   │     2: 
│   │   │   │     3: int strncmp(const char *str1, const char *str2, size_t n) {
│   │   │   │     4:     size_t i = 0;
│   │   │   │     5:     while (i < n) {
│   │   │   │     6:         unsigned char c1 = (unsigned char)str1[i], 
│   │   │   │     7:             c2 = (unsigned char)str2[i];
│   │   │   │     8:         if (c1 != c2)
│   │   │   │     9:             return c1 - c2;
│   │   │   │    10: 
│   │   │   │    11:         if (c1 == '\0') // значит и c2 также уже нуль
│   │   │   │    12:             return 0;
│   │   │   │    13: 
│   │   │   │    14:         i++;
│   │   │   │    15:     }
│   │   │   │    16: 
│   │   │   │    17:     return 0;
│   │   │   │    18: }
│   │   │   │    19: 
│   │   │   ├── strncpy.c (331 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <string.h>
│   │   │   │     2: 
│   │   │   │     3: char *strncpy(char *dest, const char *src, size_t n) {
│   │   │   │     4:     size_t i = 0;
│   │   │   │     5:     for (; i < n && src[i] != '\0'; i++)
│   │   │   │     6:         dest[i] = src[i];
│   │   │   │     7: 
│   │   │   │     8:     // заполняем все оставщиеся байты в строке
│   │   │   │     9:     // на нули
│   │   │   │    10:     for (; i < n; i++)
│   │   │   │    11:         dest[i] = '\0';
│   │   │   │    12: 
│   │   │   │    13:     return dest;
│   │   │   │    14: }
│   │   │   │    15: 
│   │   │   ├── strpbrk.c (263 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <string.h>
│   │   │   │     2: 
│   │   │   │     3: char *strpbrk(const char *str1, const char *str2) {
│   │   │   │     4:     for (; *str1 != '\0'; str1++) {
│   │   │   │     5:         for (const char *p = str2; *p != '\0'; p++) {
│   │   │   │     6:             if (*str1 == *p)
│   │   │   │     7:                 return (char*)str1;
│   │   │   │     8:         }
│   │   │   │     9:     }
│   │   │   │    10:     return NULL;
│   │   │   │    11: }
│   │   │   │    12: 
│   │   │   ├── strspn.c (412 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <string.h>
│   │   │   │     2: 
│   │   │   │     3: size_t strspn(const char *str1, const char *str2) {
│   │   │   │     4:     size_t count = 0;
│   │   │   │     5:     while (*str1) {
│   │   │   │     6:         const char *p = str2;
│   │   │   │     7:         int found = 0;
│   │   │   │     8:         while (*p) {
│   │   │   │     9:             if (*str1 == *p) {
│   │   │   │    10:                 found = 1;
│   │   │   │    11:                 break;
│   │   │   │    12:             }
│   │   │   │    13:             p++;
│   │   │   │    14:         }
│   │   │   │    15: 
│   │   │   │    16:         if (!found)
│   │   │   │    17:             break;
│   │   │   │    18: 
│   │   │   │    19:         count++;
│   │   │   │    20:         str1++;
│   │   │   │    21:     }
│   │   │   │    22: 
│   │   │   │    23:     return count;
│   │   │   │    24: }
│   │   │   │    25: 
│   │   │   ├── strstr.c (390 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <string.h>
│   │   │   │     2: 
│   │   │   │     3: char *strstr(const char *haystack, const char *needle) {
│   │   │   │     4:     if (*needle == '\0')
│   │   │   │     5:         return (char*)haystack;
│   │   │   │     6: 
│   │   │   │     7:     for (size_t i = 0; haystack[i] != '\0'; i++) {
│   │   │   │     8:         size_t j = 0;
│   │   │   │     9:         while (needle[j] != '\0' && haystack[j + i] == needle[j])
│   │   │   │    10:             j++;
│   │   │   │    11: 
│   │   │   │    12:         if (needle[j] == '\0')
│   │   │   │    13:             return (char*)&haystack[i];
│   │   │   │    14:     }
│   │   │   │    15: 
│   │   │   │    16:     return NULL;
│   │   │   │    17: }
│   │   │   │    18: 
│   │   │   ├── strtok.c (457 bytes)

│   │   │   │   Contents:
│   │   │   │     1: #include <string.h>
│   │   │   │     2: 
│   │   │   │     3: static char *old_string = NULL;
│   │   │   │     4: 
│   │   │   │     5: char *strtok(char *str, const char *delim) {
│   │   │   │     6:     if (str == NULL) str = old_string;
│   │   │   │     7:     str += strspn(str, delim);
│   │   │   │     8:     if (*str == '\0') {
│   │   │   │     9:         old_string = str;
│   │   │   │    10:         return NULL;
│   │   │   │    11:     }
│   │   │   │    12: 
│   │   │   │    13:     char *token = str;
│   │   │   │    14:     str = strpbrk(token, delim);
│   │   │   │    15:     if (str == NULL)
│   │   │   │    16:         old_string = rawmemchr(token, '\0');
│   │   │   │    17:     else {
│   │   │   │    18:         *str = '\0';
│   │   │   │    19:         old_string = str + 1;
│   │   │   │    20:     }
│   │   │   │    21:     return token;
│   │   │   │    22: }
│   │   │   │    23: 
├── limine/
│   ├── .gitignore (18 bytes)
│   ├── BOOTAA64.EFI (232.0 KB)
│   ├── BOOTIA32.EFI (252.0 KB)
│   ├── BOOTLOONGARCH64.EFI (252.0 KB)
│   ├── BOOTRISCV64.EFI (212.0 KB)
│   ├── BOOTX64.EFI (252.0 KB)
│   ├── LICENSE (1.3 KB)
│   ├── limine (82.1 KB)
│   ├── limine-bios-hdd.h (117.8 KB)

│   │   Contents:
│   │     1: const uint8_t binary_limine_hdd_bin_data[] = {
│   │     2:     0xeb, 0x3c, 0x90, 0x4c, 0x49, 0x4d, 0x49, 0x4e, 0x45, 0x20, 0x20, 0x00, 0x02, 0x00, 0x00, 0x00,
│   │     3:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
│   │     4:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x49, 0x4d, 0x49, 0x4e,
│   │     5:     0x45, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfa, 0xfc,
│   │     6:     0xea, 0x45, 0x7c, 0x00, 0x00, 0x31, 0xf6, 0x8e, 0xde, 0x8e, 0xc6, 0x8e, 0xd6, 0xbc, 0x00, 0x7c,
│   │     7:     0xfb, 0x80, 0xfa, 0x80, 0x0f, 0x82, 0x0f, 0x01, 0x80, 0xfa, 0x8f, 0x0f, 0x87, 0x07, 0x01, 0xb4,
│   │     8:     0x41, 0xbb, 0xaa, 0x55, 0xcd, 0x13, 0x0f, 0x82, 0xfb, 0x00, 0x81, 0xfb, 0x55, 0xaa, 0x0f, 0x85,
│   │     9:     0xf2, 0x00, 0x68, 0x00, 0x70, 0x07, 0xbf, 0xa4, 0x7d, 0x66, 0x8b, 0x05, 0x66, 0x8b, 0x6d, 0x04,
│   │    10:     0x31, 0xdb, 0x66, 0xb9, 0x00, 0x7e, 0x00, 0x00, 0xe8, 0x55, 0x00, 0x0f, 0x82, 0xd4, 0x00, 0x0f,
│   │    11:     0x01, 0x16, 0x4d, 0x7d, 0xfa, 0x0f, 0x20, 0xc0, 0x0f, 0xba, 0xe8, 0x00, 0x0f, 0x22, 0xc0, 0xea,
│   │    12:     0x78, 0x7d, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
│   │    13:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
│   │    14:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
│   │    15:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
│   │    16:     0x60, 0xbe, 0x00, 0x80, 0xc7, 0x04, 0x10, 0x00, 0xc7, 0x44, 0x02, 0x01, 0x00, 0x89, 0x5c, 0x04,
│   │    17:     0x8c, 0x44, 0x06, 0x52, 0x56, 0x66, 0x50, 0x66, 0x55, 0xb4, 0x48, 0xbe, 0x10, 0x80, 0xc7, 0x04,
│   │    18:     0x1e, 0x00, 0xcd, 0x13, 0x72, 0x45, 0x8b, 0x6c, 0x18, 0x89, 0xc8, 0x66, 0xc1, 0xe9, 0x10, 0x89,
│   │    19:     0xca, 0x31, 0xc9, 0xf7, 0xf5, 0x85, 0xd2, 0x0f, 0x95, 0xc1, 0x01, 0xc1, 0x66, 0x5a, 0x66, 0x58,
│   │    20:     0x5e, 0x66, 0xf7, 0xf5, 0x66, 0x89, 0x44, 0x08, 0x66, 0xc7, 0x44, 0x0c, 0x00, 0x00, 0x00, 0x00,
│   │    21:     0x5a, 0xb4, 0x42, 0xf8, 0xcd, 0x13, 0x72, 0x13, 0x01, 0x6c, 0x04, 0x66, 0x31, 0xdb, 0x66, 0xff,
│   │    22:     0x44, 0x08, 0x0f, 0x90, 0xc3, 0x66, 0x01, 0x5c, 0x0c, 0xe2, 0xe6, 0x61, 0xc3, 0x17, 0x00, 0x4b,
│   │    23:     0x7d, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x9b, 0xcf, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
│   │    24:     0x93, 0xcf, 0x00, 0x46, 0x46, 0x46, 0x46, 0x81, 0xc6, 0x30, 0x4f, 0x68, 0x00, 0xb8, 0x07, 0x26,
│   │    25:     0x89, 0x36, 0x00, 0x00, 0xfb, 0xf4, 0xeb, 0xfd, 0xb8, 0x10, 0x00, 0x00, 0x00, 0x8e, 0xd8, 0x8e,
│   │    26:     0xc0, 0x8e, 0xe0, 0x8e, 0xe8, 0x8e, 0xd0, 0x81, 0xe2, 0xff, 0x00, 0x00, 0x00, 0x6a, 0x00, 0x52,
│   │    27:     0x68, 0x5a, 0x3e, 0x00, 0x00, 0x68, 0x00, 0x0b, 0x07, 0x00, 0xe8, 0x61, 0x82, 0x06, 0x00, 0x00,
│   │    28:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
│   │    29:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
│   │    30:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
│   │    31:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
│   │    32:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
│   │    33:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa,
│   │    34:     0xfc, 0x30, 0xc0, 0xbf, 0xff, 0x0a, 0x07, 0x00, 0xb9, 0xff, 0x0a, 0x07, 0x00, 0x81, 0xe9, 0xff,
│   │    35:     0x0a, 0x07, 0x00, 0xf3, 0xaa, 0xe9, 0x00, 0x00, 0x00, 0x00, 0x57, 0x56, 0x0f, 0xb6, 0x74, 0x24,
│   │    36:     0x14, 0x8b, 0x7c, 0x24, 0x18, 0xff, 0x74, 0x24, 0x10, 0xff, 0x74, 0x24, 0x10, 0x68, 0x00, 0xf0,
│   │    37:     0x00, 0x00, 0xe8, 0x14, 0x00, 0x00, 0x00, 0x83, 0xc4, 0x0c, 0xbc, 0x00, 0xf0, 0x00, 0x00, 0x31,
│   │    38:     0xed, 0x57, 0x56, 0x6a, 0x00, 0x68, 0x00, 0xf0, 0x00, 0x00, 0xc3, 0x55, 0x53, 0x57, 0x56, 0x8b,
│   │    39:     0x54, 0x24, 0x1c, 0xb8, 0xfd, 0xff, 0xff, 0xff, 0x83, 0xfa, 0x12, 0x0f, 0x82, 0xa2, 0x00, 0x00,
│   │    40:     0x00, 0x8b, 0x4c, 0x24, 0x18, 0x80, 0x39, 0x1f, 0x0f, 0x85, 0x95, 0x00, 0x00, 0x00, 0x80, 0x79,
│   │    41:     0x01, 0x8b, 0x0f, 0x85, 0x8b, 0x00, 0x00, 0x00, 0x80, 0x79, 0x02, 0x08, 0x0f, 0x85, 0x81, 0x00,
│   │    42:     0x00, 0x00, 0x0f, 0xb6, 0x59, 0x03, 0x83, 0xfb, 0x1f, 0x77, 0x78, 0x8d, 0x71, 0x0a, 0xf6, 0xc3,
│   │    43:     0x04, 0x74, 0x0e, 0x0f, 0xb7, 0x3e, 0x8d, 0x6a, 0xf4, 0x39, 0xfd, 0x72, 0x66, 0x8d, 0x74, 0x3e,
│   │    44:     0x02, 0xf6, 0xc3, 0x08, 0x75, 0x04, 0x89, 0xf7, 0xeb, 0x13, 0x89, 0xf5, 0x29, 0xcd, 0x39, 0xd5,
│   │    45:     0x73, 0x51, 0x8d, 0x7e, 0x01, 0x45, 0x80, 0x3e, 0x00, 0x89, 0xfe, 0x75, 0xf1, 0x80, 0xfb, 0x10,
│   │    46:     0x73, 0x04, 0x89, 0xfd, 0xeb, 0x13, 0x89, 0xfe, 0x29, 0xce, 0x39, 0xd6, 0x73, 0x35, 0x8d, 0x6f,
│   │    47:     0x01, 0x46, 0x80, 0x3f, 0x00, 0x89, 0xef, 0x75, 0xf1, 0x83, 0xe3, 0x02, 0x01, 0xeb, 0x01, 0xd1,
│   │    48:     0x29, 0xd9, 0x83, 0xf9, 0x08, 0x7c, 0x1c, 0x83, 0xc1, 0xf8, 0x51, 0x53, 0xff, 0x74, 0x24, 0x1c,
│   │    49:     0xe8, 0x13, 0x00, 0x00, 0x00, 0x83, 0xc4, 0x0c, 0x31, 0xc9, 0x85, 0xc0, 0x0f, 0x94, 0xc1, 0x8d,
│   │    50:     0x44, 0x49, 0xfd, 0x5e, 0x5f, 0x5b, 0x5d, 0xc3, 0x55, 0x53, 0x57, 0x56, 0x81, 0xec, 0x38, 0x06,
│   │    51:     0x00, 0x00, 0x8b, 0x84, 0x24, 0x4c, 0x06, 0x00, 0x00, 0x8b, 0x8c, 0x24, 0x50, 0x06, 0x00, 0x00,
│   │    52:     0x8d, 0x54, 0x24, 0x30, 0x89, 0x4a, 0xe4, 0x03, 0x8c, 0x24, 0x54, 0x06, 0x00, 0x00, 0x89, 0x4a,
│   │    53:     0xe8, 0x31, 0xc9, 0x89, 0x4a, 0xec, 0x89, 0x4a, 0xf0, 0x89, 0x4a, 0xf4, 0x89, 0x42, 0xfc, 0x89,
│   │    54:     0x42, 0xf8, 0x8b, 0x54, 0x24, 0x20, 0x85, 0xd2, 0x7e, 0x0a, 0x8b, 0x44, 0x24, 0x1c, 0x89, 0x44,
│   │    55:     0x24, 0x04, 0xeb, 0x4a, 0x8b, 0x74, 0x24, 0x14, 0x8b, 0x44, 0x24, 0x18, 0x8b, 0x4c, 0x24, 0x1c,
│   │    56:     0x89, 0x4c, 0x24, 0x04, 0x89, 0xd1, 0x39, 0xc6, 0x74, 0x1e, 0x8d, 0x56, 0x01, 0x89, 0x54, 0x24,
│   │    57:     0x14, 0x0f, 0xb6, 0x36, 0xd3, 0xe6, 0x8b, 0x7c, 0x24, 0x04, 0x09, 0xf7, 0x89, 0x7c, 0x24, 0x04,
│   │    58:     0x89, 0x7c, 0x24, 0x1c, 0x89, 0xd6, 0xeb, 0x08, 0xc7, 0x44, 0x24, 0x24, 0x01, 0x00, 0x00, 0x00,
│   │    59:     0x8d, 0x51, 0x08, 0x89, 0x54, 0x24, 0x20, 0x83, 0xf9, 0xf9, 0x89, 0xd1, 0x7c, 0xc8, 0x8b, 0x6c,
│   │    60:     0x24, 0x04, 0xd1, 0xed, 0x89, 0x6c, 0x24, 0x1c, 0x8d, 0x4a, 0xff, 0x89, 0x4c, 0x24, 0x20, 0x83,
│   │    61:     0xf9, 0x01, 0x77, 0x41, 0x8b, 0x44, 0x24, 0x14, 0x8b, 0x74, 0x24, 0x18, 0x83, 0xc2, 0xf7, 0x8d,
│   │    62:     0x4a, 0x08, 0x39, 0xf0, 0x74, 0x16, 0x8d, 0x78, 0x01, 0x89, 0x7c, 0x24, 0x14, 0x0f, 0xb6, 0x18,
│   │    63:     0xd3, 0xe3, 0x09, 0xdd, 0x89, 0x6c, 0x24, 0x1c, 0x89, 0xf8, 0xeb, 0x08, 0xc7, 0x44, 0x24, 0x24,
│   │    64:     0x01, 0x00, 0x00, 0x00, 0x83, 0xc2, 0x10, 0x89, 0x54, 0x24, 0x20, 0x83, 0xf9, 0xfa, 0x89, 0xca,
│   │    65:     0x7c, 0xcd, 0x83, 0xc1, 0x08, 0x89, 0xee, 0x83, 0xe6, 0x03, 0xc1, 0xed, 0x02, 0x89, 0x6c, 0x24,
│   │    66:     0x1c, 0x8d, 0x51, 0xfe, 0x89, 0x54, 0x24, 0x20, 0xb8, 0xfd, 0xff, 0xff, 0xff, 0xff, 0x24, 0xb5,
│   │    67:     0x28, 0x0a, 0x07, 0x00, 0x8b, 0x4c, 0x24, 0x14, 0x8b, 0x54, 0x24, 0x18, 0x29, 0xca, 0x83, 0xfa,
│   │    68:     0x04, 0x0f, 0x8c, 0x47, 0x05, 0x00, 0x00, 0x0f, 0xb7, 0x19, 0x0f, 0xb7, 0x51, 0x02, 0x66, 0x31,
│   │    69:     0xda, 0x66, 0x83, 0xfa, 0xff, 0x0f, 0x85, 0x33, 0x05, 0x00, 0x00, 0x83, 0xc1, 0x04, 0x89, 0x4c,
│   │    70:     0x24, 0x14, 0x85, 0xdb, 0x74, 0x1d, 0x8b, 0x4c, 0x24, 0x14, 0x8b, 0x54, 0x24, 0x2c, 0x8d, 0x71,
│   │    71:     0x01, 0x8d, 0x7a, 0x01, 0x4b, 0x89, 0x74, 0x24, 0x14, 0x8a, 0x09, 0x89, 0x7c, 0x24, 0x2c, 0x88,
│   │    72:     0x0a, 0x75, 0xe3, 0x31, 0xc0, 0x89, 0x44, 0x24, 0x1c, 0x89, 0x44, 0x24, 0x20, 0xe9, 0xd8, 0x00,
│   │    73:     0x00, 0x00, 0xb8, 0xe0, 0xff, 0xff, 0xff, 0x66, 0xc7, 0x44, 0x04, 0x50, 0x00, 0x00, 0x83, 0xc0,
│   │    74:     0x02, 0x75, 0xf4, 0xc7, 0x44, 0x24, 0x3e, 0x18, 0x00, 0x98, 0x00, 0x66, 0xc7, 0x44, 0x24, 0x42,
│   │    75:     0x70, 0x00, 0xb8, 0xe8, 0xff, 0xff, 0xff, 0x8d, 0x88, 0x18, 0x01, 0x00, 0x00, 0x66, 0x89, 0x8c,
│   │    76:     0x44, 0x80, 0x00, 0x00, 0x00, 0x40, 0x75, 0xef, 0x31, 0xc0, 0x66, 0x89, 0x84, 0x44, 0x80, 0x00,
│   │    77:     0x00, 0x00, 0x40, 0x3d, 0x90, 0x00, 0x00, 0x00, 0x75, 0xf0, 0xb8, 0xf8, 0xff, 0xff, 0xff, 0x8d,
│   │    78:     0x88, 0x20, 0x01, 0x00, 0x00, 0x66, 0x89, 0x8c, 0x44, 0xb0, 0x01, 0x00, 0x00, 0x40, 0x75, 0xef,
│   │    79:     0xb8, 0x90, 0xff, 0xff, 0xff, 0x8d, 0x88, 0x00, 0x01, 0x00, 0x00, 0x66, 0x89, 0x8c, 0x44, 0x90,
│   │    80:     0x02, 0x00, 0x00, 0x40, 0x75, 0xef, 0xc7, 0x84, 0x24, 0x90, 0x02, 0x00, 0x00, 0x1d, 0x01, 0x00,
│   │    81:     0x00, 0xb8, 0xe0, 0xff, 0xff, 0xff, 0x66, 0xc7, 0x84, 0x04, 0xb4, 0x02, 0x00, 0x00, 0x00, 0x00,
│   │    82:     0x83, 0xc0, 0x02, 0x75, 0xf1, 0x66, 0xc7, 0x84, 0x24, 0x9e, 0x02, 0x00, 0x00, 0x20, 0x00, 0x31,
│   │    83:     0xc0, 0x66, 0x89, 0x84, 0x44, 0xb4, 0x02, 0x00, 0x00, 0x40, 0x83, 0xf8, 0x20, 0x75, 0xf2, 0xc7,
│   │    84:     0x84, 0x24, 0xf4, 0x04, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x8d, 0x4c, 0x24, 0x14, 0x8d, 0x54,
│   │    85:     0x24, 0x30, 0x8d, 0x84, 0x24, 0x94, 0x02, 0x00, 0x00, 0x50, 0xe8, 0x91, 0x04, 0x00, 0x00, 0x83,
│   │    86:     0xc4, 0x04, 0x85, 0xc0, 0x0f, 0x85, 0x24, 0x04, 0x00, 0x00, 0xf6, 0x44, 0x24, 0x04, 0x01, 0x0f,
│   │    87:     0x84, 0xed, 0xfd, 0xff, 0xff, 0xe9, 0xfc, 0x03, 0x00, 0x00, 0x83, 0xfa, 0x04, 0x77, 0x45, 0x89,
│   │    88:     0xc8, 0x8b, 0x4c, 0x24, 0x14, 0x8b, 0x74, 0x24, 0x18, 0x83, 0xc0, 0xf6, 0x8d, 0x50, 0x08, 0x39,
│   │    89:     0xf1, 0x74, 0x18, 0x8d, 0x79, 0x01, 0x89, 0x7c, 0x24, 0x14, 0x0f, 0xb6, 0x19, 0x89, 0xd1, 0xd3,
│   │    90:     0xe3, 0x09, 0xdd, 0x89, 0x6c, 0x24, 0x1c, 0x89, 0xf9, 0xeb, 0x08, 0xc7, 0x44, 0x24, 0x24, 0x01,
│   │    91:     0x00, 0x00, 0x00, 0x83, 0xc0, 0x10, 0x89, 0x44, 0x24, 0x20, 0x83, 0xfa, 0xfd, 0x89, 0xd0, 0x7c,
│   │    92:     0xcb, 0x83, 0xc2, 0x08, 0x89, 0xee, 0xc1, 0xee, 0x05, 0x89, 0x74, 0x24, 0x1c, 0x8d, 0x5a, 0xfb,
│   │    93:     0x89, 0x5c, 0x24, 0x20, 0x83, 0xfb, 0x04, 0x77, 0x47, 0x8b, 0x4c, 0x24, 0x14, 0x8b, 0x44, 0x24,
│   │    94:     0x18, 0x89, 0x04, 0x24, 0x83, 0xc2, 0xf3, 0x8d, 0x5a, 0x08, 0x3b, 0x0c, 0x24, 0x74, 0x18, 0x8d,
│   │    95:     0x41, 0x01, 0x89, 0x44, 0x24, 0x14, 0x0f, 0xb6, 0x39, 0x89, 0xd9, 0xd3, 0xe7, 0x09, 0xfe, 0x89,
│   │    96:     0x74, 0x24, 0x1c, 0x89, 0xc1, 0xeb, 0x08, 0xc7, 0x44, 0x24, 0x24, 0x01, 0x00, 0x00, 0x00, 0x83,
│   │    97:     0xc2, 0x10, 0x89, 0x54, 0x24, 0x20, 0x83, 0xfb, 0xfd, 0x89, 0xda, 0x7c, 0xca, 0x83, 0xc3, 0x08,
│   │    98:     0x89, 0xf0, 0xc1, 0xe8, 0x05, 0x89, 0x04, 0x24, 0x89, 0x44, 0x24, 0x1c, 0x8d, 0x43, 0xfb, 0x89,
│   │    99:     0x44, 0x24, 0x20, 0x83, 0xf8, 0x03, 0x77, 0x51, 0x89, 0x74, 0x24, 0x08, 0x8b, 0x7c, 0x24, 0x14,
│   │   100:     0x8b, 0x74, 0x24, 0x18, 0x83, 0xc3, 0xf3, 0x8d, 0x43, 0x08, 0x39, 0xf7, 0x74, 0x1e, 0x8d, 0x57,
│   │   101: ... [truncated, total 1208 lines]
│   ├── limine.c (40.3 KB)

│   │   Contents:
│   │     1: #undef IS_WINDOWS
│   │     2: #if defined(WIN32) || defined(_WIN32) || defined(__WIN32) && !defined(__CYGWIN__)
│   │     3: #define IS_WINDOWS 1
│   │     4: #endif
│   │     5: 
│   │     6: #include <stdio.h>
│   │     7: #include <stdlib.h>
│   │     8: #include <stdint.h>
│   │     9: #include <stddef.h>
│   │    10: #include <stdbool.h>
│   │    11: #include <stdarg.h>
│   │    12: #include <string.h>
│   │    13: #include <errno.h>
│   │    14: #include <inttypes.h>
│   │    15: #include <limits.h>
│   │    16: #include <time.h>
│   │    17: 
│   │    18: #ifndef LIMINE_NO_BIOS
│   │    19: #include "limine-bios-hdd.h"
│   │    20: #endif
│   │    21: 
│   │    22: static char *program_name = NULL;
│   │    23: 
│   │    24: static void perror_wrap(const char *fmt, ...) {
│   │    25:     int old_errno = errno;
│   │    26: 
│   │    27:     fprintf(stderr, "%s: ", program_name);
│   │    28: 
│   │    29:     va_list args;
│   │    30:     va_start(args, fmt);
│   │    31: 
│   │    32:     vfprintf(stderr, fmt, args);
│   │    33: 
│   │    34:     va_end(args);
│   │    35: 
│   │    36:     fprintf(stderr, ": %s\n", strerror(old_errno));
│   │    37: }
│   │    38: 
│   │    39: static void remove_arg(int *argc, char *argv[], int index) {
│   │    40:     for (int i = index; i < *argc - 1; i++) {
│   │    41:         argv[i] = argv[i + 1];
│   │    42:     }
│   │    43: 
│   │    44:     (*argc)--;
│   │    45: 
│   │    46:     argv[*argc] = NULL;
│   │    47: }
│   │    48: 
│   │    49: #ifndef LIMINE_NO_BIOS
│   │    50: 
│   │    51: static bool quiet = false;
│   │    52: 
│   │    53: static int set_pos(FILE *stream, uint64_t pos) {
│   │    54:     if (sizeof(long) >= 8) {
│   │    55:         return fseek(stream, (long)pos, SEEK_SET);
│   │    56:     }
│   │    57: 
│   │    58:     long jump_size = (LONG_MAX / 2) + 1;
│   │    59:     long last_jump = pos % jump_size;
│   │    60:     uint64_t jumps = pos / jump_size;
│   │    61: 
│   │    62:     rewind(stream);
│   │    63: 
│   │    64:     for (uint64_t i = 0; i < jumps; i++) {
│   │    65:         if (fseek(stream, jump_size, SEEK_CUR) != 0) {
│   │    66:             return -1;
│   │    67:         }
│   │    68:     }
│   │    69:     if (fseek(stream, last_jump, SEEK_CUR) != 0) {
│   │    70:         return -1;
│   │    71:     }
│   │    72: 
│   │    73:     return 0;
│   │    74: }
│   │    75: 
│   │    76: #define SIZEOF_ARRAY(array) (sizeof(array) / sizeof(array[0]))
│   │    77: #define DIV_ROUNDUP(a, b) (((a) + ((b) - 1)) / (b))
│   │    78: 
│   │    79: struct gpt_table_header {
│   │    80:     // the head
│   │    81:     char     signature[8];
│   │    82:     uint32_t revision;
│   │    83:     uint32_t header_size;
│   │    84:     uint32_t crc32;
│   │    85:     uint32_t _reserved0;
│   │    86: 
│   │    87:     // the partitioning info
│   │    88:     uint64_t my_lba;
│   │    89:     uint64_t alternate_lba;
│   │    90:     uint64_t first_usable_lba;
│   │    91:     uint64_t last_usable_lba;
│   │    92: 
│   │    93:     // the guid
│   │    94:     uint64_t disk_guid[2];
│   │    95: 
│   │    96:     // entries related
│   │    97:     uint64_t partition_entry_lba;
│   │    98:     uint32_t number_of_partition_entries;
│   │    99:     uint32_t size_of_partition_entry;
│   │   100:     uint32_t partition_entry_array_crc32;
│   │   101: ... [truncated, total 1354 lines]
│   ├── limine.exe (116.5 KB)
│   ├── Makefile (231 bytes)
├── limine-tools/
│   ├── cc-runtime/
│   │   ├── src/
│   │   │   ├── cc-runtime.c (131.4 KB)

│   │   │   │   Contents:
│   │   │   │     1: #include <limits.h>
│   │   │   │     2: #include <stdbool.h>
│   │   │   │     3: #include <stdint.h>
│   │   │   │     4: #pragma GCC diagnostic ignored "-Wunused-function"
│   │   │   │     5: 
│   │   │   │     6: //===-- assembly.h - compiler-rt assembler support macros -----------------===//
│   │   │   │     7: //
│   │   │   │     8: // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
│   │   │   │     9: // See https://llvm.org/LICENSE.txt for license information.
│   │   │   │    10: // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
│   │   │   │    11: //
│   │   │   │    12: // 2024/01/21 - Modified by mintsuki for use inside cc-runtime
│   │   │   │    13: //
│   │   │   │    14: //===----------------------------------------------------------------------===//
│   │   │   │    15: //
│   │   │   │    16: // This file defines macros for use in compiler-rt assembler source.
│   │   │   │    17: // This file is not part of the interface of this library.
│   │   │   │    18: //
│   │   │   │    19: //===----------------------------------------------------------------------===//
│   │   │   │    20: 
│   │   │   │    21: #ifndef COMPILERRT_ASSEMBLY_H
│   │   │   │    22: #define COMPILERRT_ASSEMBLY_H
│   │   │   │    23: 
│   │   │   │    24: #define SEPARATOR ;
│   │   │   │    25: 
│   │   │   │    26: #define HIDDEN(name) .hidden name
│   │   │   │    27: #define LOCAL_LABEL(name) .L_##name
│   │   │   │    28: #define FILE_LEVEL_DIRECTIVE
│   │   │   │    29: #if defined(__arm__) || defined(__aarch64__)
│   │   │   │    30: #define SYMBOL_IS_FUNC(name) .type name,%function
│   │   │   │    31: #else
│   │   │   │    32: #define SYMBOL_IS_FUNC(name) .type name,@function
│   │   │   │    33: #endif
│   │   │   │    34: #define CONST_SECTION .section .rodata
│   │   │   │    35: 
│   │   │   │    36: #define NO_EXEC_STACK_DIRECTIVE .section .note.GNU-stack,"",%progbits
│   │   │   │    37: 
│   │   │   │    38: #if defined(__arm__) || defined(__aarch64__)
│   │   │   │    39: #define FUNC_ALIGN                                                             \
│   │   │   │    40:   .text SEPARATOR                                                              \
│   │   │   │    41:   .balign 16 SEPARATOR
│   │   │   │    42: #else
│   │   │   │    43: #define FUNC_ALIGN
│   │   │   │    44: #endif
│   │   │   │    45: 
│   │   │   │    46: // BTI and PAC gnu property note
│   │   │   │    47: #define NT_GNU_PROPERTY_TYPE_0 5
│   │   │   │    48: #define GNU_PROPERTY_AARCH64_FEATURE_1_AND 0xc0000000
│   │   │   │    49: #define GNU_PROPERTY_AARCH64_FEATURE_1_BTI 1
│   │   │   │    50: #define GNU_PROPERTY_AARCH64_FEATURE_1_PAC 2
│   │   │   │    51: 
│   │   │   │    52: #if defined(__ARM_FEATURE_BTI_DEFAULT)
│   │   │   │    53: #define BTI_FLAG GNU_PROPERTY_AARCH64_FEATURE_1_BTI
│   │   │   │    54: #else
│   │   │   │    55: #define BTI_FLAG 0
│   │   │   │    56: #endif
│   │   │   │    57: 
│   │   │   │    58: #if __ARM_FEATURE_PAC_DEFAULT & 3
│   │   │   │    59: #define PAC_FLAG GNU_PROPERTY_AARCH64_FEATURE_1_PAC
│   │   │   │    60: #else
│   │   │   │    61: #define PAC_FLAG 0
│   │   │   │    62: #endif
│   │   │   │    63: 
│   │   │   │    64: #define GNU_PROPERTY(type, value)                                              \
│   │   │   │    65:   .pushsection .note.gnu.property, "a" SEPARATOR                               \
│   │   │   │    66:   .p2align 3 SEPARATOR                                                         \
│   │   │   │    67:   .word 4 SEPARATOR                                                            \
│   │   │   │    68:   .word 16 SEPARATOR                                                           \
│   │   │   │    69:   .word NT_GNU_PROPERTY_TYPE_0 SEPARATOR                                       \
│   │   │   │    70:   .asciz "GNU" SEPARATOR                                                       \
│   │   │   │    71:   .word type SEPARATOR                                                         \
│   │   │   │    72:   .word 4 SEPARATOR                                                            \
│   │   │   │    73:   .word value SEPARATOR                                                        \
│   │   │   │    74:   .word 0 SEPARATOR                                                            \
│   │   │   │    75:   .popsection
│   │   │   │    76: 
│   │   │   │    77: #if BTI_FLAG != 0
│   │   │   │    78: #define BTI_C hint #34
│   │   │   │    79: #define BTI_J hint #36
│   │   │   │    80: #else
│   │   │   │    81: #define BTI_C
│   │   │   │    82: #define BTI_J
│   │   │   │    83: #endif
│   │   │   │    84: 
│   │   │   │    85: #if (BTI_FLAG | PAC_FLAG) != 0
│   │   │   │    86: #define GNU_PROPERTY_BTI_PAC                                                   \
│   │   │   │    87:   GNU_PROPERTY(GNU_PROPERTY_AARCH64_FEATURE_1_AND, BTI_FLAG | PAC_FLAG)
│   │   │   │    88: #else
│   │   │   │    89: #define GNU_PROPERTY_BTI_PAC
│   │   │   │    90: #endif
│   │   │   │    91: 
│   │   │   │    92: #if defined(__clang__) || defined(__GCC_HAVE_DWARF2_CFI_ASM)
│   │   │   │    93: #define CFI_START .cfi_startproc
│   │   │   │    94: #define CFI_END .cfi_endproc
│   │   │   │    95: #else
│   │   │   │    96: #define CFI_START
│   │   │   │    97: #define CFI_END
│   │   │   │    98: #endif
│   │   │   │    99: 
│   │   │   │   100: #if defined(__arm__)
│   │   │   │   101: ... [truncated, total 4204 lines]
│   │   ├── CREDITS.TXT (1.0 KB)
│   │   ├── LICENSE.TXT (16.3 KB)
│   │   ├── README (225 bytes)
│   ├── freestnd-c-hdrs/
│   │   ├── include/
│   │   │   ├── float.h (3.2 KB)

│   │   │   │   Contents:
│   │   │   │     1: /* Copyright (C) 2022-2025 Mintsuki and contributors.
│   │   │   │     2:  *
│   │   │   │     3:  * Permission to use, copy, modify, and/or distribute this software for any
│   │   │   │     4:  * purpose with or without fee is hereby granted.
│   │   │   │     5:  *
│   │   │   │     6:  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
│   │   │   │     7:  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
│   │   │   │     8:  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
│   │   │   │     9:  * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
│   │   │   │    10:  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
│   │   │   │    11:  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
│   │   │   │    12:  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
│   │   │   │    13:  */
│   │   │   │    14: 
│   │   │   │    15: #ifndef __FREESTND_C_HDRS_FLOAT_H
│   │   │   │    16: #define __FREESTND_C_HDRS_FLOAT_H 1
│   │   │   │    17: 
│   │   │   │    18: #undef FLT_ROUNDS
│   │   │   │    19: #define FLT_ROUNDS 1
│   │   │   │    20: 
│   │   │   │    21: #undef FLT_RADIX
│   │   │   │    22: #define FLT_RADIX __FLT_RADIX__
│   │   │   │    23: 
│   │   │   │    24: #undef FLT_MANT_DIG
│   │   │   │    25: #define FLT_MANT_DIG __FLT_MANT_DIG__
│   │   │   │    26: #undef DBL_MANT_DIG
│   │   │   │    27: #define DBL_MANT_DIG __DBL_MANT_DIG__
│   │   │   │    28: #undef LDBL_MANT_DIG
│   │   │   │    29: #define LDBL_MANT_DIG __LDBL_MANT_DIG__
│   │   │   │    30: 
│   │   │   │    31: #if (defined(__cplusplus) && __cplusplus >= 201103L) \
│   │   │   │    32:  || (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L)
│   │   │   │    33: 
│   │   │   │    34: #undef DECIMAL_DIG
│   │   │   │    35: #define DECIMAL_DIG __DECIMAL_DIG__
│   │   │   │    36: 
│   │   │   │    37: #undef FLT_EVAL_METHOD
│   │   │   │    38: #define FLT_EVAL_METHOD __FLT_EVAL_METHOD__
│   │   │   │    39: 
│   │   │   │    40: #endif
│   │   │   │    41: 
│   │   │   │    42: #undef FLT_DIG
│   │   │   │    43: #define FLT_DIG __FLT_DIG__
│   │   │   │    44: #undef DBL_DIG
│   │   │   │    45: #define DBL_DIG __DBL_DIG__
│   │   │   │    46: #undef LDBL_DIG
│   │   │   │    47: #define LDBL_DIG __LDBL_DIG__
│   │   │   │    48: 
│   │   │   │    49: #undef FLT_MIN_EXP
│   │   │   │    50: #define FLT_MIN_EXP __FLT_MIN_EXP__
│   │   │   │    51: #undef DBL_MIN_EXP
│   │   │   │    52: #define DBL_MIN_EXP __DBL_MIN_EXP__
│   │   │   │    53: #undef LDBL_MIN_EXP
│   │   │   │    54: #define LDBL_MIN_EXP __LDBL_MIN_EXP__
│   │   │   │    55: 
│   │   │   │    56: #undef FLT_MIN_10_EXP
│   │   │   │    57: #define FLT_MIN_10_EXP __FLT_MIN_10_EXP__
│   │   │   │    58: #undef DBL_MIN_10_EXP
│   │   │   │    59: #define DBL_MIN_10_EXP __DBL_MIN_10_EXP__
│   │   │   │    60: #undef LDBL_MIN_10_EXP
│   │   │   │    61: #define LDBL_MIN_10_EXP __LDBL_MIN_10_EXP__
│   │   │   │    62: 
│   │   │   │    63: #undef FLT_MAX_EXP
│   │   │   │    64: #define FLT_MAX_EXP __FLT_MAX_EXP__
│   │   │   │    65: #undef DBL_MAX_EXP
│   │   │   │    66: #define DBL_MAX_EXP __DBL_MAX_EXP__
│   │   │   │    67: #undef LDBL_MAX_EXP
│   │   │   │    68: #define LDBL_MAX_EXP __LDBL_MAX_EXP__
│   │   │   │    69: 
│   │   │   │    70: #undef FLT_MAX_10_EXP
│   │   │   │    71: #define FLT_MAX_10_EXP __FLT_MAX_10_EXP__
│   │   │   │    72: #undef DBL_MAX_10_EXP
│   │   │   │    73: #define DBL_MAX_10_EXP __DBL_MAX_10_EXP__
│   │   │   │    74: #undef LDBL_MAX_10_EXP
│   │   │   │    75: #define LDBL_MAX_10_EXP __LDBL_MAX_10_EXP__
│   │   │   │    76: 
│   │   │   │    77: #undef FLT_MAX
│   │   │   │    78: #define FLT_MAX __FLT_MAX__
│   │   │   │    79: #undef DBL_MAX
│   │   │   │    80: #define DBL_MAX __DBL_MAX__
│   │   │   │    81: #undef LDBL_MAX
│   │   │   │    82: #define LDBL_MAX __LDBL_MAX__
│   │   │   │    83: 
│   │   │   │    84: #undef FLT_EPSILON
│   │   │   │    85: #define FLT_EPSILON __FLT_EPSILON__
│   │   │   │    86: #undef DBL_EPSILON
│   │   │   │    87: #define DBL_EPSILON __DBL_EPSILON__
│   │   │   │    88: #undef LDBL_EPSILON
│   │   │   │    89: #define LDBL_EPSILON __LDBL_EPSILON__
│   │   │   │    90: 
│   │   │   │    91: #undef FLT_MIN
│   │   │   │    92: #define FLT_MIN __FLT_MIN__
│   │   │   │    93: #undef DBL_MIN
│   │   │   │    94: #define DBL_MIN __DBL_MIN__
│   │   │   │    95: #undef LDBL_MIN
│   │   │   │    96: #define LDBL_MIN __LDBL_MIN__
│   │   │   │    97: 
│   │   │   │    98: #if (defined(__cplusplus) && __cplusplus >= 201703L) \
│   │   │   │    99:  || (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L)
│   │   │   │   100: 
│   │   │   │   101: ... [truncated, total 124 lines]
│   │   │   ├── iso646.h (1.1 KB)

│   │   │   │   Contents:
│   │   │   │     1: /* Copyright (C) 2022-2025 Mintsuki and contributors.
│   │   │   │     2:  *
│   │   │   │     3:  * Permission to use, copy, modify, and/or distribute this software for any
│   │   │   │     4:  * purpose with or without fee is hereby granted.
│   │   │   │     5:  *
│   │   │   │     6:  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
│   │   │   │     7:  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
│   │   │   │     8:  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
│   │   │   │     9:  * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
│   │   │   │    10:  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
│   │   │   │    11:  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
│   │   │   │    12:  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
│   │   │   │    13:  */
│   │   │   │    14: 
│   │   │   │    15: #ifndef __FREESTND_C_HDRS_ISO646_H
│   │   │   │    16: #define __FREESTND_C_HDRS_ISO646_H 1
│   │   │   │    17: 
│   │   │   │    18: #ifndef __cplusplus
│   │   │   │    19: 
│   │   │   │    20: #undef and
│   │   │   │    21: #define and &&
│   │   │   │    22: #undef and_eq
│   │   │   │    23: #define and_eq &=
│   │   │   │    24: #undef bitand
│   │   │   │    25: #define bitand &
│   │   │   │    26: #undef bitor
│   │   │   │    27: #define bitor |
│   │   │   │    28: #undef compl
│   │   │   │    29: #define compl ~
│   │   │   │    30: #undef not
│   │   │   │    31: #define not !
│   │   │   │    32: #undef not_eq
│   │   │   │    33: #define not_eq !=
│   │   │   │    34: #undef or
│   │   │   │    35: #define or ||
│   │   │   │    36: #undef or_eq
│   │   │   │    37: #define or_eq |=
│   │   │   │    38: #undef xor
│   │   │   │    39: #define xor ^
│   │   │   │    40: #undef xor_eq
│   │   │   │    41: #define xor_eq ^=
│   │   │   │    42: 
│   │   │   │    43: #endif
│   │   │   │    44: 
│   │   │   │    45: #endif
│   │   │   │    46: 
│   │   │   ├── limits.h (3.5 KB)

│   │   │   │   Contents:
│   │   │   │     1: /* Copyright (C) 2022-2025 Mintsuki and contributors.
│   │   │   │     2:  *
│   │   │   │     3:  * Permission to use, copy, modify, and/or distribute this software for any
│   │   │   │     4:  * purpose with or without fee is hereby granted.
│   │   │   │     5:  *
│   │   │   │     6:  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
│   │   │   │     7:  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
│   │   │   │     8:  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
│   │   │   │     9:  * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
│   │   │   │    10:  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
│   │   │   │    11:  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
│   │   │   │    12:  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
│   │   │   │    13:  */
│   │   │   │    14: 
│   │   │   │    15: #ifndef __FREESTND_C_HDRS_LIMITS_H
│   │   │   │    16: #define __FREESTND_C_HDRS_LIMITS_H 1
│   │   │   │    17: 
│   │   │   │    18: #undef CHAR_BIT
│   │   │   │    19: #define CHAR_BIT __CHAR_BIT__
│   │   │   │    20: 
│   │   │   │    21: #ifndef MB_LEN_MAX
│   │   │   │    22: #   define MB_LEN_MAX 1
│   │   │   │    23: #endif
│   │   │   │    24: 
│   │   │   │    25: #undef SCHAR_MAX
│   │   │   │    26: #define SCHAR_MAX __SCHAR_MAX__
│   │   │   │    27: #undef SCHAR_MIN
│   │   │   │    28: #define SCHAR_MIN (-SCHAR_MAX - 1)
│   │   │   │    29: 
│   │   │   │    30: #undef UCHAR_MAX
│   │   │   │    31: #if __SCHAR_MAX__ == __INT_MAX__
│   │   │   │    32: #   define UCHAR_MAX (SCHAR_MAX * 2U + 1U)
│   │   │   │    33: #else
│   │   │   │    34: #   define UCHAR_MAX (SCHAR_MAX * 2 + 1)
│   │   │   │    35: #endif
│   │   │   │    36: 
│   │   │   │    37: #ifdef __CHAR_UNSIGNED__
│   │   │   │    38: #   undef CHAR_MAX
│   │   │   │    39: #   define CHAR_MAX UCHAR_MAX
│   │   │   │    40: #   undef CHAR_MIN
│   │   │   │    41: #   if __SCHAR_MAX__ == __INT_MAX__
│   │   │   │    42: #       define CHAR_MIN 0U
│   │   │   │    43: #   else
│   │   │   │    44: #       define CHAR_MIN 0
│   │   │   │    45: #   endif
│   │   │   │    46: #else
│   │   │   │    47: #   undef CHAR_MAX
│   │   │   │    48: #   define CHAR_MAX SCHAR_MAX
│   │   │   │    49: #   undef CHAR_MIN
│   │   │   │    50: #   define CHAR_MIN SCHAR_MIN
│   │   │   │    51: #endif
│   │   │   │    52: 
│   │   │   │    53: #undef SHRT_MAX
│   │   │   │    54: #define SHRT_MAX __SHRT_MAX__
│   │   │   │    55: #undef SHRT_MIN
│   │   │   │    56: #define SHRT_MIN (-SHRT_MAX - 1)
│   │   │   │    57: 
│   │   │   │    58: #undef USHRT_MAX
│   │   │   │    59: #if __SHRT_MAX__ == __INT_MAX__
│   │   │   │    60: #   define USHRT_MAX (SHRT_MAX * 2U + 1U)
│   │   │   │    61: #else
│   │   │   │    62: #   define USHRT_MAX (SHRT_MAX * 2 + 1)
│   │   │   │    63: #endif
│   │   │   │    64: 
│   │   │   │    65: #undef INT_MAX
│   │   │   │    66: #define INT_MAX __INT_MAX__
│   │   │   │    67: #undef INT_MIN
│   │   │   │    68: #define INT_MIN (-INT_MAX - 1)
│   │   │   │    69: 
│   │   │   │    70: #undef UINT_MAX
│   │   │   │    71: #define UINT_MAX (INT_MAX * 2U + 1U)
│   │   │   │    72: 
│   │   │   │    73: #undef LONG_MAX
│   │   │   │    74: #define LONG_MAX __LONG_MAX__
│   │   │   │    75: #undef LONG_MIN
│   │   │   │    76: #define LONG_MIN (-LONG_MAX - 1L)
│   │   │   │    77: 
│   │   │   │    78: #undef ULONG_MAX
│   │   │   │    79: #define ULONG_MAX (LONG_MAX * 2UL + 1UL)
│   │   │   │    80: 
│   │   │   │    81: #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
│   │   │   │    82: 
│   │   │   │    83: #undef LLONG_MAX
│   │   │   │    84: #define LLONG_MAX __LONG_LONG_MAX__
│   │   │   │    85: #undef LLONG_MIN
│   │   │   │    86: #define LLONG_MIN (-LLONG_MAX - 1LL)
│   │   │   │    87: 
│   │   │   │    88: #undef ULLONG_MAX
│   │   │   │    89: #define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
│   │   │   │    90: 
│   │   │   │    91: #endif
│   │   │   │    92: 
│   │   │   │    93: #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 202311L
│   │   │   │    94: 
│   │   │   │    95: #if defined(__clang__)
│   │   │   │    96: #   undef CHAR_WIDTH
│   │   │   │    97: #   define CHAR_WIDTH CHAR_BIT
│   │   │   │    98: #   undef SCHAR_WIDTH
│   │   │   │    99: #   define SCHAR_WIDTH CHAR_BIT
│   │   │   │   100: #   undef UCHAR_WIDTH
│   │   │   │   101: ... [truncated, total 147 lines]
│   │   │   ├── stdalign.h (1.1 KB)

│   │   │   │   Contents:
│   │   │   │     1: /* Copyright (C) 2022-2025 Mintsuki and contributors.
│   │   │   │     2:  *
│   │   │   │     3:  * Permission to use, copy, modify, and/or distribute this software for any
│   │   │   │     4:  * purpose with or without fee is hereby granted.
│   │   │   │     5:  *
│   │   │   │     6:  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
│   │   │   │     7:  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
│   │   │   │     8:  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
│   │   │   │     9:  * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
│   │   │   │    10:  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
│   │   │   │    11:  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
│   │   │   │    12:  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
│   │   │   │    13:  */
│   │   │   │    14: 
│   │   │   │    15: #ifndef __FREESTND_C_HDRS_STDALIGN_H
│   │   │   │    16: #define __FREESTND_C_HDRS_STDALIGN_H 1
│   │   │   │    17: 
│   │   │   │    18: #ifndef __cplusplus
│   │   │   │    19: 
│   │   │   │    20: #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 202311L
│   │   │   │    21:     /* These do not need to be defined for C23+ */
│   │   │   │    22: #else
│   │   │   │    23: #  undef alignas
│   │   │   │    24: #  define alignas _Alignas
│   │   │   │    25: #  undef alignof
│   │   │   │    26: #  define alignof _Alignof
│   │   │   │    27: 
│   │   │   │    28: #  undef __alignof_is_defined
│   │   │   │    29: #  define __alignof_is_defined 1
│   │   │   │    30: #  undef __alignas_is_defined
│   │   │   │    31: #  define __alignas_is_defined 1
│   │   │   │    32: #endif
│   │   │   │    33: 
│   │   │   │    34: #endif
│   │   │   │    35: 
│   │   │   │    36: #endif
│   │   │   │    37: 
│   │   │   ├── stdarg.h (1.4 KB)

│   │   │   │   Contents:
│   │   │   │     1: /* Copyright (C) 2022-2025 Mintsuki and contributors.
│   │   │   │     2:  *
│   │   │   │     3:  * Permission to use, copy, modify, and/or distribute this software for any
│   │   │   │     4:  * purpose with or without fee is hereby granted.
│   │   │   │     5:  *
│   │   │   │     6:  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
│   │   │   │     7:  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
│   │   │   │     8:  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
│   │   │   │     9:  * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
│   │   │   │    10:  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
│   │   │   │    11:  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
│   │   │   │    12:  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
│   │   │   │    13:  */
│   │   │   │    14: 
│   │   │   │    15: #ifndef __FREESTND_C_HDRS_STDARG_H
│   │   │   │    16: #define __FREESTND_C_HDRS_STDARG_H 1
│   │   │   │    17: 
│   │   │   │    18: typedef __builtin_va_list va_list;
│   │   │   │    19: 
│   │   │   │    20: #undef va_start
│   │   │   │    21: #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 202311L
│   │   │   │    22: #  define va_start(v, ...) __builtin_va_start(v, 0)
│   │   │   │    23: #else
│   │   │   │    24: #  define va_start(v, l) __builtin_va_start(v, l)
│   │   │   │    25: #endif
│   │   │   │    26: #undef va_end
│   │   │   │    27: #define va_end(v) __builtin_va_end(v)
│   │   │   │    28: #undef va_arg
│   │   │   │    29: #define va_arg(v, l) __builtin_va_arg(v, l)
│   │   │   │    30: #if (defined(__cplusplus) && (__cplusplus >= 201103L)) || (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L))
│   │   │   │    31: #  undef va_copy
│   │   │   │    32: #  define va_copy(d, s) __builtin_va_copy(d, s)
│   │   │   │    33: #endif
│   │   │   │    34: 
│   │   │   │    35: #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 202311L
│   │   │   │    36: #  define __STDC_VERSION_STDARG_H__ 202311L
│   │   │   │    37: #endif
│   │   │   │    38: 
│   │   │   │    39: #endif
│   │   │   │    40: 
│   │   │   ├── stdbool.h (1.1 KB)

│   │   │   │   Contents:
│   │   │   │     1: /* Copyright (C) 2022-2025 Mintsuki and contributors.
│   │   │   │     2:  *
│   │   │   │     3:  * Permission to use, copy, modify, and/or distribute this software for any
│   │   │   │     4:  * purpose with or without fee is hereby granted.
│   │   │   │     5:  *
│   │   │   │     6:  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
│   │   │   │     7:  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
│   │   │   │     8:  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
│   │   │   │     9:  * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
│   │   │   │    10:  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
│   │   │   │    11:  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
│   │   │   │    12:  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
│   │   │   │    13:  */
│   │   │   │    14: 
│   │   │   │    15: #ifndef __FREESTND_C_HDRS_STDBOOL_H
│   │   │   │    16: #define __FREESTND_C_HDRS_STDBOOL_H 1
│   │   │   │    17: 
│   │   │   │    18: #ifndef __cplusplus
│   │   │   │    19: 
│   │   │   │    20: #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 202311L
│   │   │   │    21:     /* These do not need to be defined for C23+ */
│   │   │   │    22: #else
│   │   │   │    23: #  undef bool
│   │   │   │    24: #  define bool _Bool
│   │   │   │    25: 
│   │   │   │    26: #  undef true
│   │   │   │    27: #  define true 1
│   │   │   │    28: #  undef false
│   │   │   │    29: #  define false 0
│   │   │   │    30: #endif
│   │   │   │    31: 
│   │   │   │    32: #endif
│   │   │   │    33: 
│   │   │   │    34: #undef __bool_true_false_are_defined
│   │   │   │    35: #define __bool_true_false_are_defined 1
│   │   │   │    36: 
│   │   │   │    37: #endif
│   │   │   │    38: 
│   │   │   ├── stddef.h (1.4 KB)

│   │   │   │   Contents:
│   │   │   │     1: /* Copyright (C) 2022-2025 Mintsuki and contributors.
│   │   │   │     2:  *
│   │   │   │     3:  * Permission to use, copy, modify, and/or distribute this software for any
│   │   │   │     4:  * purpose with or without fee is hereby granted.
│   │   │   │     5:  *
│   │   │   │     6:  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
│   │   │   │     7:  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
│   │   │   │     8:  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
│   │   │   │     9:  * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
│   │   │   │    10:  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
│   │   │   │    11:  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
│   │   │   │    12:  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
│   │   │   │    13:  */
│   │   │   │    14: 
│   │   │   │    15: #ifndef __FREESTND_C_HDRS_STDDEF_H
│   │   │   │    16: #define __FREESTND_C_HDRS_STDDEF_H 1
│   │   │   │    17: 
│   │   │   │    18: typedef __SIZE_TYPE__ size_t;
│   │   │   │    19: typedef __PTRDIFF_TYPE__ ptrdiff_t;
│   │   │   │    20: 
│   │   │   │    21: #ifndef __cplusplus
│   │   │   │    22: typedef __WCHAR_TYPE__ wchar_t;
│   │   │   │    23: 
│   │   │   │    24: #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 202311L
│   │   │   │    25: typedef typeof(nullptr) nullptr_t;
│   │   │   │    26: #endif
│   │   │   │    27: 
│   │   │   │    28: #endif
│   │   │   │    29: 
│   │   │   │    30: #ifdef __cplusplus
│   │   │   │    31: typedef decltype(nullptr) nullptr_t;
│   │   │   │    32: #endif
│   │   │   │    33: 
│   │   │   │    34: #undef NULL
│   │   │   │    35: #ifndef __cplusplus
│   │   │   │    36: #  define NULL ((void *)0)
│   │   │   │    37: #else
│   │   │   │    38: #  define NULL __null
│   │   │   │    39: #endif
│   │   │   │    40: 
│   │   │   │    41: #undef offsetof
│   │   │   │    42: #define offsetof(s, m) __builtin_offsetof(s, m)
│   │   │   │    43: 
│   │   │   │    44: #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 202311L
│   │   │   │    45: #  undef unreachable
│   │   │   │    46: #  define unreachable() __builtin_unreachable()
│   │   │   │    47: 
│   │   │   │    48: #  define __STDC_VERSION_STDDEF_H__ 202311L
│   │   │   │    49: #endif
│   │   │   │    50: 
│   │   │   │    51: #endif
│   │   │   │    52: 
│   │   │   ├── stdint.h (9.7 KB)

│   │   │   │   Contents:
│   │   │   │     1: /* Copyright (C) 2022-2025 Mintsuki and contributors.
│   │   │   │     2:  *
│   │   │   │     3:  * Permission to use, copy, modify, and/or distribute this software for any
│   │   │   │     4:  * purpose with or without fee is hereby granted.
│   │   │   │     5:  *
│   │   │   │     6:  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
│   │   │   │     7:  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
│   │   │   │     8:  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
│   │   │   │     9:  * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
│   │   │   │    10:  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
│   │   │   │    11:  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
│   │   │   │    12:  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
│   │   │   │    13:  */
│   │   │   │    14: 
│   │   │   │    15: #ifndef __FREESTND_C_HDRS_STDINT_H
│   │   │   │    16: #define __FREESTND_C_HDRS_STDINT_H 1
│   │   │   │    17: 
│   │   │   │    18: #ifdef __UINT8_TYPE__
│   │   │   │    19: typedef __UINT8_TYPE__ uint8_t;
│   │   │   │    20: #endif
│   │   │   │    21: #ifdef __UINT16_TYPE__
│   │   │   │    22: typedef __UINT16_TYPE__ uint16_t;
│   │   │   │    23: #endif
│   │   │   │    24: #ifdef __UINT32_TYPE__
│   │   │   │    25: typedef __UINT32_TYPE__ uint32_t;
│   │   │   │    26: #endif
│   │   │   │    27: #ifdef __UINT64_TYPE__
│   │   │   │    28: typedef __UINT64_TYPE__ uint64_t;
│   │   │   │    29: #endif
│   │   │   │    30: 
│   │   │   │    31: typedef __UINT_LEAST8_TYPE__ uint_least8_t;
│   │   │   │    32: typedef __UINT_LEAST16_TYPE__ uint_least16_t;
│   │   │   │    33: typedef __UINT_LEAST32_TYPE__ uint_least32_t;
│   │   │   │    34: typedef __UINT_LEAST64_TYPE__ uint_least64_t;
│   │   │   │    35: 
│   │   │   │    36: typedef __UINT_FAST8_TYPE__ uint_fast8_t;
│   │   │   │    37: typedef __UINT_FAST16_TYPE__ uint_fast16_t;
│   │   │   │    38: typedef __UINT_FAST32_TYPE__ uint_fast32_t;
│   │   │   │    39: typedef __UINT_FAST64_TYPE__ uint_fast64_t;
│   │   │   │    40: 
│   │   │   │    41: #ifdef __INT8_TYPE__
│   │   │   │    42: typedef __INT8_TYPE__ int8_t;
│   │   │   │    43: #endif
│   │   │   │    44: #ifdef __INT16_TYPE__
│   │   │   │    45: typedef __INT16_TYPE__ int16_t;
│   │   │   │    46: #endif
│   │   │   │    47: #ifdef __INT32_TYPE__
│   │   │   │    48: typedef __INT32_TYPE__ int32_t;
│   │   │   │    49: #endif
│   │   │   │    50: #ifdef __INT64_TYPE__
│   │   │   │    51: typedef __INT64_TYPE__ int64_t;
│   │   │   │    52: #endif
│   │   │   │    53: 
│   │   │   │    54: typedef __INT_LEAST8_TYPE__ int_least8_t;
│   │   │   │    55: typedef __INT_LEAST16_TYPE__ int_least16_t;
│   │   │   │    56: typedef __INT_LEAST32_TYPE__ int_least32_t;
│   │   │   │    57: typedef __INT_LEAST64_TYPE__ int_least64_t;
│   │   │   │    58: 
│   │   │   │    59: typedef __INT_FAST8_TYPE__ int_fast8_t;
│   │   │   │    60: typedef __INT_FAST16_TYPE__ int_fast16_t;
│   │   │   │    61: typedef __INT_FAST32_TYPE__ int_fast32_t;
│   │   │   │    62: typedef __INT_FAST64_TYPE__ int_fast64_t;
│   │   │   │    63: 
│   │   │   │    64: #ifdef __UINTPTR_TYPE__
│   │   │   │    65: typedef __UINTPTR_TYPE__ uintptr_t;
│   │   │   │    66: #endif
│   │   │   │    67: #ifdef __INTPTR_TYPE__
│   │   │   │    68: typedef __INTPTR_TYPE__ intptr_t;
│   │   │   │    69: #endif
│   │   │   │    70: 
│   │   │   │    71: typedef __UINTMAX_TYPE__ uintmax_t;
│   │   │   │    72: typedef __INTMAX_TYPE__ intmax_t;
│   │   │   │    73: 
│   │   │   │    74: /* Clang and GCC have different mechanisms for INT32_C and friends. */
│   │   │   │    75: #ifdef __clang__
│   │   │   │    76: #   ifndef __FREESTND_C_HDRS_C_JOIN
│   │   │   │    77: #       define __FREESTND_C_HDRS_C_EXPAND_JOIN(x, suffix) x ## suffix
│   │   │   │    78: #       define __FREESTND_C_HDRS_C_JOIN(x, suffix) __FREESTND_C_HDRS_C_EXPAND_JOIN(x, suffix)
│   │   │   │    79: #   endif
│   │   │   │    80: 
│   │   │   │    81: #   undef INT8_C
│   │   │   │    82: #   define INT8_C(x) __FREESTND_C_HDRS_C_JOIN(x, __INT8_C_SUFFIX__)
│   │   │   │    83: #   undef INT16_C
│   │   │   │    84: #   define INT16_C(x) __FREESTND_C_HDRS_C_JOIN(x, __INT16_C_SUFFIX__)
│   │   │   │    85: #   undef INT32_C
│   │   │   │    86: #   define INT32_C(x) __FREESTND_C_HDRS_C_JOIN(x, __INT32_C_SUFFIX__)
│   │   │   │    87: #   undef INT64_C
│   │   │   │    88: #   define INT64_C(x) __FREESTND_C_HDRS_C_JOIN(x, __INT64_C_SUFFIX__)
│   │   │   │    89: 
│   │   │   │    90: #   undef UINT8_C
│   │   │   │    91: #   define UINT8_C(x) __FREESTND_C_HDRS_C_JOIN(x, __UINT8_C_SUFFIX__)
│   │   │   │    92: #   undef UINT16_C
│   │   │   │    93: #   define UINT16_C(x) __FREESTND_C_HDRS_C_JOIN(x, __UINT16_C_SUFFIX__)
│   │   │   │    94: #   undef UINT32_C
│   │   │   │    95: #   define UINT32_C(x) __FREESTND_C_HDRS_C_JOIN(x, __UINT32_C_SUFFIX__)
│   │   │   │    96: #   undef UINT64_C
│   │   │   │    97: #   define UINT64_C(x) __FREESTND_C_HDRS_C_JOIN(x, __UINT64_C_SUFFIX__)
│   │   │   │    98: 
│   │   │   │    99: #   undef INTMAX_C
│   │   │   │   100: #   define INTMAX_C(x) __FREESTND_C_HDRS_C_JOIN(x, __INTMAX_C_SUFFIX__)
│   │   │   │   101: ... [truncated, total 375 lines]
│   │   │   ├── stdnoreturn.h (845 bytes)

│   │   │   │   Contents:
│   │   │   │     1: /* Copyright (C) 2022-2025 Mintsuki and contributors.
│   │   │   │     2:  *
│   │   │   │     3:  * Permission to use, copy, modify, and/or distribute this software for any
│   │   │   │     4:  * purpose with or without fee is hereby granted.
│   │   │   │     5:  *
│   │   │   │     6:  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
│   │   │   │     7:  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
│   │   │   │     8:  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
│   │   │   │     9:  * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
│   │   │   │    10:  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
│   │   │   │    11:  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
│   │   │   │    12:  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
│   │   │   │    13:  */
│   │   │   │    14: 
│   │   │   │    15: #ifndef __FREESTND_C_HDRS_STDNORETURN_H
│   │   │   │    16: #define __FREESTND_C_HDRS_STDNORETURN_H 1
│   │   │   │    17: 
│   │   │   │    18: #ifndef __cplusplus
│   │   │   │    19: 
│   │   │   │    20: #define noreturn _Noreturn
│   │   │   │    21: 
│   │   │   │    22: #endif
│   │   │   │    23: 
│   │   │   │    24: #endif
│   │   │   │    25: 
│   │   ├── LICENSE (659 bytes)
│   │   ├── README (89 bytes)
│   ├── limine-protocol/
│   │   ├── include/
│   │   │   ├── limine.h (14.3 KB)

│   │   │   │   Contents:
│   │   │   │     1: /* BSD Zero Clause License */
│   │   │   │     2: 
│   │   │   │     3: /* Copyright (C) 2022-2025 Mintsuki and contributors.
│   │   │   │     4:  *
│   │   │   │     5:  * Permission to use, copy, modify, and/or distribute this software for any
│   │   │   │     6:  * purpose with or without fee is hereby granted.
│   │   │   │     7:  *
│   │   │   │     8:  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
│   │   │   │     9:  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
│   │   │   │    10:  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
│   │   │   │    11:  * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
│   │   │   │    12:  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
│   │   │   │    13:  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
│   │   │   │    14:  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
│   │   │   │    15:  */
│   │   │   │    16: 
│   │   │   │    17: #ifndef LIMINE_H
│   │   │   │    18: #define LIMINE_H 1
│   │   │   │    19: 
│   │   │   │    20: #include <stdint.h>
│   │   │   │    21: 
│   │   │   │    22: #ifdef __cplusplus
│   │   │   │    23: extern "C" {
│   │   │   │    24: #endif
│   │   │   │    25: 
│   │   │   │    26: /* Misc */
│   │   │   │    27: 
│   │   │   │    28: #ifdef LIMINE_NO_POINTERS
│   │   │   │    29: #  define LIMINE_PTR(TYPE) uint64_t
│   │   │   │    30: #else
│   │   │   │    31: #  define LIMINE_PTR(TYPE) TYPE
│   │   │   │    32: #endif
│   │   │   │    33: 
│   │   │   │    34: #define LIMINE_REQUESTS_START_MARKER { 0xf6b8f4b39de7d1ae, 0xfab91a6940fcb9cf, \
│   │   │   │    35:                                        0x785c6ed015d3e316, 0x181e920a7852b9d9 }
│   │   │   │    36: #define LIMINE_REQUESTS_END_MARKER { 0xadc0e0531bb10d03, 0x9572709f31764c62 }
│   │   │   │    37: 
│   │   │   │    38: #define LIMINE_BASE_REVISION(N) { 0xf9562b2d5c95a6c8, 0x6a7b384944536bdc, (N) }
│   │   │   │    39: 
│   │   │   │    40: #define LIMINE_BASE_REVISION_SUPPORTED(VAR) ((VAR)[2] == 0)
│   │   │   │    41: 
│   │   │   │    42: #define LIMINE_LOADED_BASE_REVISION_VALID(VAR) ((VAR)[1] != 0x6a7b384944536bdc)
│   │   │   │    43: #define LIMINE_LOADED_BASE_REVISION(VAR) ((VAR)[1])
│   │   │   │    44: 
│   │   │   │    45: #define LIMINE_COMMON_MAGIC 0xc7b1dd30df4c8b88, 0x0a82e883a194f07b
│   │   │   │    46: 
│   │   │   │    47: struct limine_uuid {
│   │   │   │    48:     uint32_t a;
│   │   │   │    49:     uint16_t b;
│   │   │   │    50:     uint16_t c;
│   │   │   │    51:     uint8_t d[8];
│   │   │   │    52: };
│   │   │   │    53: 
│   │   │   │    54: #define LIMINE_MEDIA_TYPE_GENERIC 0
│   │   │   │    55: #define LIMINE_MEDIA_TYPE_OPTICAL 1
│   │   │   │    56: #define LIMINE_MEDIA_TYPE_TFTP 2
│   │   │   │    57: 
│   │   │   │    58: struct limine_file {
│   │   │   │    59:     uint64_t revision;
│   │   │   │    60:     LIMINE_PTR(void *) address;
│   │   │   │    61:     uint64_t size;
│   │   │   │    62:     LIMINE_PTR(char *) path;
│   │   │   │    63:     LIMINE_PTR(char *) string;
│   │   │   │    64:     uint32_t media_type;
│   │   │   │    65:     uint32_t unused;
│   │   │   │    66:     uint32_t tftp_ip;
│   │   │   │    67:     uint32_t tftp_port;
│   │   │   │    68:     uint32_t partition_index;
│   │   │   │    69:     uint32_t mbr_disk_id;
│   │   │   │    70:     struct limine_uuid gpt_disk_uuid;
│   │   │   │    71:     struct limine_uuid gpt_part_uuid;
│   │   │   │    72:     struct limine_uuid part_uuid;
│   │   │   │    73: };
│   │   │   │    74: 
│   │   │   │    75: /* Boot info */
│   │   │   │    76: 
│   │   │   │    77: #define LIMINE_BOOTLOADER_INFO_REQUEST_ID { LIMINE_COMMON_MAGIC, 0xf55038d8e2a1202f, 0x279426fcf5f59740 }
│   │   │   │    78: 
│   │   │   │    79: struct limine_bootloader_info_response {
│   │   │   │    80:     uint64_t revision;
│   │   │   │    81:     LIMINE_PTR(char *) name;
│   │   │   │    82:     LIMINE_PTR(char *) version;
│   │   │   │    83: };
│   │   │   │    84: 
│   │   │   │    85: struct limine_bootloader_info_request {
│   │   │   │    86:     uint64_t id[4];
│   │   │   │    87:     uint64_t revision;
│   │   │   │    88:     LIMINE_PTR(struct limine_bootloader_info_response *) response;
│   │   │   │    89: };
│   │   │   │    90: 
│   │   │   │    91: /* Executable command line */
│   │   │   │    92: 
│   │   │   │    93: #define LIMINE_EXECUTABLE_CMDLINE_REQUEST_ID { LIMINE_COMMON_MAGIC, 0x4b161536e598651e, 0xb390ad4a2f1f303a }
│   │   │   │    94: 
│   │   │   │    95: struct limine_executable_cmdline_response {
│   │   │   │    96:     uint64_t revision;
│   │   │   │    97:     LIMINE_PTR(char *) cmdline;
│   │   │   │    98: };
│   │   │   │    99: 
│   │   │   │   100: struct limine_executable_cmdline_request {
│   │   │   │   101: ... [truncated, total 575 lines]
│   │   ├── LICENSE (659 bytes)
│   │   ├── PROTOCOL.md (54.8 KB)

│   │   │   Contents:
│   │   │     1: # The Limine Boot Protocol
│   │   │     2: 
│   │   │     3: The Limine boot protocol is a modern, portable, featureful, and extensible boot
│   │   │     4: protocol.
│   │   │     5: 
│   │   │     6: This file serves as the protocol's specification and as the official, centralised
│   │   │     7: collection of [features](#features) that the Limine boot protocol is comprised of.
│   │   │     8: Bootloaders may support extra unofficial features, but it is strongly recommended
│   │   │     9: to avoid fragmentation and submit new features by opening a pull request to the
│   │   │    10: [limine-protocol Codeberg repository](https://codeberg.org/Limine/limine-protocol).
│   │   │    11: 
│   │   │    12: The [limine.h](include/limine.h) file provides an implementation of all the
│   │   │    13: structures and constants described in this document, for the C and C++
│   │   │    14: languages.
│   │   │    15: 
│   │   │    16: 
│   │   │    17: ---
│   │   │    18: 
│   │   │    19: ## Table of Contents
│   │   │    20: 
│   │   │    21: - [General Notes](#general-notes)
│   │   │    22: - [Requests Delimiters](#requests-delimiters)
│   │   │    23: - [Limine Requests Section](#limine-requests-section)
│   │   │    24: - [Base Revisions](#base-revisions)
│   │   │    25: - [Base Revision Changes Summary](#base-revision-changes-summary)
│   │   │    26:   - [Base Revision 0](#base-revision-0)
│   │   │    27:   - [Base Revision 1](#base-revision-1)
│   │   │    28:   - [Base Revision 2](#base-revision-2)
│   │   │    29:   - [Base Revision 3](#base-revision-3)
│   │   │    30:   - [Base Revision 4](#base-revision-4)
│   │   │    31: - [Memory Layout at Entry](#memory-layout-at-entry)
│   │   │    32: - [Caching](#caching)
│   │   │    33:   - [x86-64](#x86-64)
│   │   │    34:   - [aarch64](#aarch64)
│   │   │    35:   - [riscv64](#riscv64)
│   │   │    36:   - [loongarch64](#loongarch64)
│   │   │    37: - [Machine State at Entry](#machine-state-at-entry)
│   │   │    38:   - [x86-64](#x86-64-1)
│   │   │    39:   - [aarch64](#aarch64-1)
│   │   │    40:   - [riscv64](#riscv64-1)
│   │   │    41:   - [loongarch64](#loongarch64-1)
│   │   │    42: - [Features](#features)
│   │   │    43:   - [Request](#request)
│   │   │    44:   - [Response](#response)
│   │   │    45: - [Feature List](#feature-list)
│   │   │    46:   - [Bootloader Info](#bootloader-info-feature)
│   │   │    47:   - [Executable Command Line](#executable-command-line-feature)
│   │   │    48:   - [Firmware Type](#firmware-type-feature)
│   │   │    49:   - [Stack Size](#stack-size-feature)
│   │   │    50:   - [HHDM (Higher Half Direct Map)](#hhdm-higher-half-direct-map-feature)
│   │   │    51:   - [Framebuffer](#framebuffer-feature)
│   │   │    52:   - [Paging Mode](#paging-mode-feature)
│   │   │    53:   - [MP (Multiprocessor)](#mp-multiprocessor-feature)
│   │   │    54:   - [RISC-V BSP Hart ID](#risc-v-bsp-hart-id-feature)
│   │   │    55:   - [Memory Map](#memory-map-feature)
│   │   │    56:   - [Entry Point](#entry-point-feature)
│   │   │    57:   - [Executable File](#executable-file-feature)
│   │   │    58:   - [Module](#module-feature)
│   │   │    59:   - [RSDP](#rsdp-feature)
│   │   │    60:   - [SMBIOS](#smbios-feature)
│   │   │    61:   - [EFI System Table](#efi-system-table-feature)
│   │   │    62:   - [EFI Memory Map](#efi-memory-map-feature)
│   │   │    63:   - [Date at Boot](#date-at-boot-feature)
│   │   │    64:   - [Executable Address](#executable-address-feature)
│   │   │    65:   - [Device Tree Blob](#device-tree-blob-feature)
│   │   │    66:   - [Bootloader Performance](#bootloader-performance-feature)
│   │   │    67: - [File Structure](#file-structure)
│   │   │    68: 
│   │   │    69: ---
│   │   │    70: 
│   │   │    71: ## General Notes
│   │   │    72: 
│   │   │    73: The "executable" is the kernel or otherwise the freestanding application being loaded
│   │   │    74: by the Limine boot protocol compliant bootloader.
│   │   │    75: 
│   │   │    76: The Limine boot protocol does not enforce any specific executable binary format to use,
│   │   │    77: though ELF is strongly recommended.
│   │   │    78: 
│   │   │    79: Only 64-bit, Little Endian machines are supported or will be supported in the future.
│   │   │    80: 
│   │   │    81: All pointers are 64-bit wide. All non-NULL pointers point to the object with the
│   │   │    82: [Higher Half Direct Map](#hhdm-higher-half-direct-map-feature) (HHDM) offset already added
│   │   │    83: to them, unless otherwise noted.
│   │   │    84: 
│   │   │    85: All [responses](#response) and associated data structures are placed in
│   │   │    86: [bootloader-reclaimable memory](#memory-map-feature) regions.
│   │   │    87: 
│   │   │    88: The ABIs the Limine protocol uses and expects the executable to comply with are as follows:
│   │   │    89:   - SysV Itanium ABI for x86-64
│   │   │    90:   - AAPCS LP64 for aarch64
│   │   │    91:   - LP64 for riscv64
│   │   │    92:   - LP64S for loongarch64
│   │   │    93: 
│   │   │    94: All of these are with FPU/SIMD disabled (sometimes also referred to as Soft-Float).
│   │   │    95: 
│   │   │    96: ## Requests Delimiters
│   │   │    97: 
│   │   │    98: The bootloader can be told to start and/or stop searching for [requests](#request)
│   │   │    99: (including [base revision](#base-revisions) tags) in an executable's loaded image by
│   │   │   100: placing start and/or end markers, on an 8-byte aligned boundary.
│   │   │   101: ... [truncated, total 1682 lines]
│   │   ├── README.md (122 bytes)

│   │   │   Contents:
│   │   │     1: # Limine Boot Protocol
│   │   │     2: 
│   │   │     3: This repository contains the primary documentation and C/C++ header for the
│   │   │     4: Limine Boot Protocol.
│   │   │     5: 
├── .gitignore (88 bytes)
├── build.py (36.9 KB)

│   Contents:
│     1: #!/usr/bin/env python3
│     2: 
│     3: import os
│     4: import sys
│     5: import shutil
│     6: import subprocess
│     7: import datetime
│     8: from pathlib import Path
│     9: from typing import List, Optional, Tuple
│    10: import argparse
│    11: 
│    12: IMAGE_NAME = "Cervus"
│    13: VERSION = "v0.0.1"
│    14: QEMUFLAGS = "-m 2G"
│    15: 
│    16: BASE_DIR = Path.cwd()
│    17: KERNEL_DIR = BASE_DIR / "kernel"
│    18: SRC_DIR = KERNEL_DIR / "src"
│    19: LINKER_SCRIPTS_DIR = KERNEL_DIR / "linker-scripts"
│    20: LINKER_SCRIPT = LINKER_SCRIPTS_DIR / "x86_64.lds"
│    21: BIN_DIR = BASE_DIR / "bin"
│    22: OBJ_DIR = BASE_DIR / "obj"
│    23: ISO_ROOT = BASE_DIR / "iso_root"
│    24: DEMO_ISO_DIR = BASE_DIR / "demo_iso"
│    25: LIMINE_TOOLS_DIR = BASE_DIR / "limine-tools"
│    26: 
│    27: LIBC_DIR = BASE_DIR / "libc"
│    28: LIBC_INCLUDE_DIR = LIBC_DIR / "include"
│    29: LIBC_SRC_DIR = LIBC_DIR / "src"
│    30: 
│    31: DEPENDENCIES = {
│    32:     "freestnd-c-hdrs": {
│    33:         "url": "https://codeberg.org/OSDev/freestnd-c-hdrs-0bsd.git",
│    34:         "commit": "5df91dd7062ad0c54f5ffd86193bb9f008677631"
│    35:     },
│    36:     "cc-runtime": {
│    37:         "url": "https://codeberg.org/OSDev/cc-runtime.git",
│    38:         "commit": "dae79833b57a01b9fd3e359ee31def69f5ae899b"
│    39:     },
│    40:     "limine-protocol": {
│    41:         "url": "https://codeberg.org/Limine/limine-protocol.git",
│    42:         "commit": "c4616df2572d77c60020bdefa617dd9bdcc6566a"
│    43:     }
│    44: }
│    45: 
│    46: class Colors:
│    47:     GREEN = '\033[92m'
│    48:     YELLOW = '\033[93m'
│    49:     RED = '\033[91m'
│    50:     BLUE = '\033[94m'
│    51:     END = '\033[0m'
│    52:     BOLD = '\033[1m'
│    53:     CYAN = '\033[96m'
│    54: 
│    55: def print_color(color: str, message: str):
│    56:     print(f"{color}{message}{Colors.END}")
│    57: 
│    58: def print_help():
│    59:     help_text = f"""
│    60: {Colors.BOLD}{Colors.GREEN}OS Build Script{Colors.END}
│    61: {Colors.BOLD}================{Colors.END}
│    62: 
│    63: {Colors.BOLD}Usage:{Colors.END}
│    64:   python build.py [command] [options]
│    65: 
│    66: {Colors.BOLD}Commands:{Colors.END}
│    67:   {Colors.GREEN}run{Colors.END}      - Build and run in QEMU (auto-rebuild if needed, cleans obj/bin after exit)
│    68:   {Colors.GREEN}clean{Colors.END}    - Full cleanup (removes all build files and dependencies)
│    69:   {Colors.GREEN}cleaniso{Colors.END} - Clean demo_iso directory only
│    70:   {Colors.GREEN}gitclean{Colors.END} - Remove all generated files (demo_iso, limine.conf, limine-tools, limine, linker-scripts)
│    71: 
│    72: {Colors.BOLD}Options:{Colors.END}
│    73:   {Colors.BLUE}--tree{Colors.END}    - Generate OS-TREE.txt with directory structure and file contents
│    74:   {Colors.BLUE}--help{Colors.END}    - Show this help message
│    75:   {Colors.BLUE}--no-clean{Colors.END} - Don't clean obj/bin after QEMU exits (use with run command)
│    76:   {Colors.BLUE}--files{Colors.END}   - Specific files to include in tree
│    77:   {Colors.BLUE}--structure-only{Colors.END} - Generate tree structure only (no file contents)
│    78: 
│    79: {Colors.BOLD}Examples:{Colors.END}
│    80:   python build.py run
│    81:   python build.py clean
│    82:   python build.py cleaniso
│    83:   python build.py gitclean
│    84:   python build.py --tree
│    85:   python build.py run --tree
│    86:   python build.py run --no-clean
│    87:   python build.py --tree --files kernel/src/main.c
│    88:   python build.py --tree --structure-only
│    89:     """
│    90:     print(help_text)
│    91: 
│    92: def generate_tree_structure(output_file: str = "OS-TREE.txt", 
│    93:                            specific_files: List[str] = None,
│    94:                            structure_only: bool = False):
│    95:     """
│    96:     Генерирует структуру директорий и содержимое файлов в текстовом файле
│    97:     
│    98:     Args:
│    99:         output_file: Имя выходного файла
│   100:         specific_files: Список конкретных файлов для включения (None для всех)
│   101: ... [truncated, total 1086 lines]
├── LICENSE (34.3 KB)
├── limine.conf (112 bytes)

│   Contents:
│     1: # Timeout in seconds
│     2: timeout: 3
│     3: 
│     4: # Entry name
│     5: /Cervus v0.0.1
│     6:     protocol: limine
│     7:     path: boot():/boot/kernel
│     8: 
├── OS-TREE.txt (0 bytes)

│   Contents:
│     1: 
├── README.md (2.0 KB)

│   Contents:
│     1: # Cervus x86_64 Operating System
│     2: 
│     3: **Cervus** - это современная 64-битная операционная система, написанная для архитектуры x86_64. На данный момент в стадии разработки.
│     4: 
│     5: ## TODO
│     6: 
│     7: - [x] **Bootloader**: Limine Barebone
│     8: - [x] **Графика**: Базовая поддержка фреймбуфера
│     9: - [x] **Шрифты**: Поддержка PSF шрифтов
│    10: - [x] **Порты ввода-вывода**: Базовые операции с портами
│    11: - [x] **Последовательный порт**: Отладочный вывод через COM1
│    12: - [x] **Минимальная libc**: Базовая стандартная библиотека C
│    13: - [x] **GDT**: Глобальная таблица дескрипторов
│    14: - [ ] **IDT**: Таблица дескрипторов прерываний
│    15: - [ ] **SIMD**: Поддержка инструкций SSE/AVX
│    16: - [ ] **PMM**: Менеджер физической памяти
│    17: - [ ] **VMM**: Менеджер виртуальной памяти
│    18: - [ ] **PAGING**
│    19: - [ ] **ACPI**: Парсинг таблиц ACPI
│    20: - [ ] **APIC**: Расширенный программируемый контроллер прерываний
│    21: - [ ] **IOAPIC**: Контроллер прерываний ввода-вывода
│    22: - [ ] **LAPIC**: Локальный APIC
│    23: - [ ] **HPET**: Таймер высокой точности
│    24: - [ ] **APIC-TIMER**: Таймер на основе APIC
│    25: - [ ] **SMP**: Симметричная многопроцессорность
│    26: - [ ] **Multitasking**: Многозадачность и планировщик
│    27: - [ ] **Syscalls**: Системные вызовы
│    28: - [ ] **Userspace**: Пространство пользователя
│    29: - [ ] **Веселье начинается**: Дальнейшее развитие
│    30: 
│    31: ## Быстрый старт
│    32: 
│    33: ### Требования
│    34: 
│    35: - Компилятор GCC для x86_64
│    36: - NASM, GAS
│    37: - QEMU
│    38: - xorriso
│    39:   
│    40: ### Сборка
│    41: 
│    42: ```bash
│    43: 
│    44: python3 build.py run
│    45: ```
│    46: 
├── TODO (1.6 KB)

================================================================================
Statistics:
- Total files: 90
- Total size: 2064.7 KB
- Files by type:
  [no extension]: 11
  .EFI: 5
  .TXT: 2
  .asm: 1
  .c: 42
  .conf: 1
  .exe: 1
  .h: 20
  .lds: 1
  .md: 3
  .psf: 1
  .py: 1
  .txt: 1
